{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TextXtract","text":"<p>TextXtract is a robust, professional Python library for extracting text from a wide range of document formats\u2014synchronously or asynchronously\u2014with a focus on extensibility, security, and performance.</p> <ul> <li>Supported formats: PDF, DOCX, DOC, TXT, ZIP, Markdown, RTF, HTML, CSV, JSON, XML, and more.</li> <li>Features: Modular handler system, optional dependencies, strong error handling, logging, async support, and easy extensibility.</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Synchronous and asynchronous APIs</li> <li>Modular, extensible file type handlers</li> <li>Optional dependencies for lightweight installs</li> <li>Professional error handling and logging</li> <li>Easy to add new file types</li> <li>Comprehensive test suite</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from textxtract.sync.extractor import SyncTextExtractor\nextractor = SyncTextExtractor()\ntext = extractor.extract(file_bytes, filename)\n\nfrom textxtract.aio.extractor import AsyncTextExtractor\nimport asyncio\nasync_extractor = AsyncTextExtractor()\ntext = asyncio.run(async_extractor.extract_async(file_bytes, filename))\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Architecture Plan</li> <li>Installation</li> <li>Usage</li> <li>Testing</li> <li>API Reference</li> <li>Contributing</li> <li>Changelog</li> </ul>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#extractors","title":"Extractors","text":""},{"location":"api/#synctextextractor","title":"<code>SyncTextExtractor</code>","text":"<ul> <li>Location: <code>from textxtract import SyncTextExtractor</code></li> <li>Methods:</li> <li><code>extract(file_bytes: bytes, filename: str, config: Optional[dict] = None) -&gt; str</code></li> <li><code>extract_async(...)</code> (raises NotImplementedError)</li> </ul>"},{"location":"api/#asynctextextractor","title":"<code>AsyncTextExtractor</code>","text":"<ul> <li>Location: <code>from textxtract.aio import AsyncTextExtractor</code></li> <li>Methods:</li> <li><code>extract_async(file_bytes: bytes, filename: str, config: Optional[dict] = None) -&gt; str</code></li> <li><code>extract(...)</code> (raises NotImplementedError)</li> </ul>"},{"location":"api/#exceptions","title":"Exceptions","text":"<ul> <li><code>ExtractionError</code></li> <li><code>InvalidFileError</code></li> <li><code>FileTypeNotSupportedError</code></li> <li><code>ExtractionTimeoutError</code></li> </ul>"},{"location":"api/#handlers","title":"Handlers","text":"<p>Each file type has a handler class in <code>textxtract.handlers</code> (e.g., <code>PDFHandler</code>, <code>DOCXHandler</code>, etc.), all implementing:</p> <ul> <li><code>extract(file_path: Path, config: Optional[dict] = None) -&gt; str</code></li> <li><code>extract_async(file_path: Path, config: Optional[dict] = None) -&gt; str</code></li> </ul>"},{"location":"api/#configuration","title":"Configuration","text":"<ul> <li><code>ExtractorConfig</code> in <code>textxtract.core.config</code></li> <li>Register custom handlers, set encoding, logging, and timeouts.</li> </ul>"},{"location":"api/#logging","title":"Logging","text":"<ul> <li>Uses Python's <code>logging</code> module.</li> <li>Configure via <code>logging.basicConfig(level=logging.DEBUG)</code>.</li> </ul>"},{"location":"architecture/","title":"Text Extractor Package: Architectural Plan","text":""},{"location":"architecture/#1-package-structure","title":"1. Package Structure","text":"<pre><code>textxtract/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 core/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 base.py                # Abstract base classes for extractors and handlers\n\u2502   \u251c\u2500\u2500 utils.py               # File validation, temp file management, security\n\u2502   \u251c\u2500\u2500 config.py              # Configuration system (env, validation, per-handler)\n\u2502   \u251c\u2500\u2500 exceptions.py          # Custom exceptions\n\u2502   \u251c\u2500\u2500 logging_config.py      # Logging setup\n\u2502   \u2514\u2500\u2500 registry.py            # Central handler registry (singleton, lazy loading)\n\u251c\u2500\u2500 sync/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 extractor.py           # Synchronous extraction logic (uses registry)\n\u251c\u2500\u2500 aio/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 extractor.py           # Asynchronous extraction logic (ThreadPool, context manager)\n\u251c\u2500\u2500 handlers/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 pdf.py                 # PDF extraction (robust, empty page handling)\n\u2502   \u251c\u2500\u2500 docx.py                # DOCX extraction\n\u2502   \u251c\u2500\u2500 doc.py                 # DOC extraction (antiword + fallback)\n\u2502   \u251c\u2500\u2500 txt.py                 # TXT extraction\n\u2502   \u251c\u2500\u2500 zip.py                 # ZIP extraction (security checks, recursion)\n\u2502   \u251c\u2500\u2500 rtf.py                 # RTF extraction (striprtf)\n\u2502   \u251c\u2500\u2500 html.py                # HTML extraction\n\u2502   \u251c\u2500\u2500 md.py                  # Markdown extraction\n\u2502   \u251c\u2500\u2500 csv.py                 # CSV extraction\n\u2502   \u251c\u2500\u2500 json.py                # JSON extraction\n\u2502   \u2514\u2500\u2500 xml.py                 # XML extraction\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 test_sync.py\n\u2502   \u251c\u2500\u2500 test_async.py\n\u2502   \u251c\u2500\u2500 test_edge_cases.py     # Security, resource, and error edge cases\n\u2502   \u251c\u2500\u2500 test_exceptions.py\n\u2502   \u2514\u2500\u2500 files/                 # Test data files\n\u251c\u2500\u2500 __main__.py                # CLI entry point (optional)\n</code></pre>"},{"location":"architecture/#2-abstractions","title":"2. Abstractions","text":"<ul> <li><code>core/base.py</code>:  </li> <li><code>TextExtractor</code> (ABC): defines extract/extract_async, config, error handling.</li> <li><code>FileTypeHandler</code> (ABC): interface for file-specific extraction.</li> </ul>"},{"location":"architecture/#3-sync-async-extraction","title":"3. Sync &amp; Async Extraction","text":"<ul> <li><code>sync/extractor.py</code>:  </li> <li>Implements sync extraction using handler registry.</li> <li><code>aio/extractor.py</code>:  </li> <li>Implements async extraction using handler registry, ThreadPoolExecutor, proper resource cleanup, async context manager.</li> </ul>"},{"location":"architecture/#4-file-handlers","title":"4. File Handlers","text":"<ul> <li><code>handlers/*</code>:  </li> <li>Each file type (PDF, DOCX, DOC, TXT, ZIP, RTF, HTML, MD, CSV, JSON, XML) has a dedicated handler.</li> <li>Handlers registered and managed via the central registry.</li> <li>Security: ZIP handler checks for path traversal, file size, malicious names.</li> </ul>"},{"location":"architecture/#5-error-handling-logging","title":"5. Error Handling &amp; Logging","text":"<ul> <li><code>core/exceptions.py</code>:  </li> <li>Custom exceptions: <code>InvalidFileError</code>, <code>ExtractionError</code>, <code>FileTypeNotSupportedError</code>, etc.</li> <li><code>core/logging_config.py</code>:  </li> <li>Centralized logging, configurable via config.</li> </ul>"},{"location":"architecture/#6-configuration-customization","title":"6. Configuration &amp; Customization","text":"<ul> <li><code>core/config.py</code>:  </li> <li>Supports environment variables, type validation, per-handler config, and config files (JSON/YAML/TOML).</li> </ul>"},{"location":"architecture/#7-security-resource-management","title":"7. Security &amp; Resource Management","text":"<ul> <li><code>core/utils.py</code>:  </li> <li>File size limits, filename/path validation, temp file cleanup.</li> <li><code>aio/extractor.py</code>:  </li> <li>ThreadPoolExecutor cleanup, atexit registration, async context manager.</li> </ul>"},{"location":"architecture/#8-testing","title":"8. Testing","text":"<ul> <li><code>tests/</code>:  </li> <li>Unit and edge case tests for all handlers, extractors, and error conditions.</li> <li>Uses <code>pytest</code> and <code>pytest-asyncio</code>.</li> </ul>"},{"location":"architecture/#9-documentation","title":"9. Documentation","text":"<ul> <li>[<code>mkdocs.yml</code> + <code>scripts/generate_docs.py</code>]:  </li> <li>Automated API docs for all modules.</li> <li>Material theme, search, and navigation enhancements.</li> </ul>"},{"location":"architecture/#10-dependencies","title":"10. Dependencies","text":"<ul> <li><code>pyproject.toml</code>:  </li> <li>Main, optional, and dev dependencies clearly separated.</li> </ul>"},{"location":"architecture/#mermaid-diagram-high-level-architecture","title":"Mermaid Diagram: High-Level Architecture","text":"<pre><code>classDiagram\n    class TextExtractor {\n        +extract()\n        +extract_async()\n    }\n    class FileTypeHandler {\n        +extract(file_path, config)\n    }\n    TextExtractor &lt;|-- SyncTextExtractor\n    TextExtractor &lt;|-- AsyncTextExtractor\n    FileTypeHandler &lt;|-- PDFHandler\n    FileTypeHandler &lt;|-- DOCXHandler\n    FileTypeHandler &lt;|-- DOCHandler\n    FileTypeHandler &lt;|-- TXTHandler\n    FileTypeHandler &lt;|-- ZIPHandler\n    FileTypeHandler &lt;|-- RTFHandler\n    FileTypeHandler &lt;|-- HTMLHandler\n    FileTypeHandler &lt;|-- MDHandler\n    FileTypeHandler &lt;|-- CSVHandler\n    FileTypeHandler &lt;|-- JSONHandler\n    FileTypeHandler &lt;|-- XMLHandler\n    SyncTextExtractor o-- FileTypeHandler\n    AsyncTextExtractor o-- FileTypeHandler\n    SyncTextExtractor o-- Registry\n    AsyncTextExtractor o-- Registry\n    Registry o-- FileTypeHandler</code></pre>"},{"location":"architecture/#key-features","title":"Key Features","text":"<ul> <li>Extensible: Add new file handlers by subclassing <code>FileTypeHandler</code> and registering.</li> <li>Sync &amp; Async: Both interfaces, async is truly non-blocking.</li> <li>Robust: Comprehensive error handling, logging, and resource management.</li> <li>Configurable: Encoding, logging, handler registration, timeouts, per-handler config.</li> <li>Testable: Pytest-based tests for all components, including edge cases.</li> <li>Scalable: Lazy loading, caching, parallel processing (future-proofed).</li> <li>Secure: Input validation, safe file handling, ZIP traversal protection.</li> </ul>"},{"location":"architecture/#implementation-steps","title":"Implementation Steps","text":"<ol> <li>Scaffold the directory and file structure.</li> <li>Implement core abstractions and utilities.</li> <li>Implement file type handlers.</li> <li>Implement sync and async extractors.</li> <li>Add configuration, logging, and error handling.</li> <li>Write comprehensive tests (unit, async, edge cases).</li> <li>Document usage and API (auto-generated docs).</li> <li>Finalize dependencies and code quality checks.</li> </ol>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p>"},{"location":"changelog/#010-initial-release","title":"[0.1.0] - Initial Release","text":"<ul> <li>Initial implementation of text-extractor package</li> <li>Synchronous and asynchronous extractors</li> <li>Modular handler system for PDF, DOCX, DOC, TXT, ZIP, MD, RTF, HTML, CSV, JSON, XML</li> <li>Optional dependencies for each file type</li> <li>Robust error handling and logging</li> <li>Professional documentation with Material for MkDocs</li> <li>Comprehensive test suite</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to Text Extractor!</p>"},{"location":"contributing/#how-to-contribute","title":"How to Contribute","text":"<ol> <li>Fork the repository and clone your fork.</li> <li>Create a new branch for your feature or bugfix.</li> <li>Write clear, well-documented code following PEP 8.</li> <li>Add or update tests in <code>textxtract/tests/</code>.</li> <li>Document your changes in the relevant <code>docs/</code> files.</li> <li>Run all tests to ensure nothing is broken.</li> <li>Submit a pull request with a clear description.</li> </ol>"},{"location":"contributing/#code-style","title":"Code Style","text":"<ul> <li>Follow PEP 8 guidelines.</li> <li>Use type hints and docstrings.</li> <li>Write clear commit messages.</li> </ul>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":"<ul> <li>Use the GitHub Issues page.</li> <li>Provide as much detail as possible (error messages, OS, Python version, etc.).</li> </ul>"},{"location":"contributing/#feature-requests","title":"Feature Requests","text":"<ul> <li>Open an issue describing your idea.</li> <li>Explain the use case and benefits.</li> </ul>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<ul> <li>Be respectful and inclusive.</li> <li>Review and discuss constructively.</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#basic-install","title":"Basic Install","text":"<p>Install the core package (no extra dependencies):</p> <pre><code>pip install text-extractor\n</code></pre>"},{"location":"installation/#optional-file-type-support","title":"Optional File Type Support","text":"<p>Install with support for specific file types:</p> <pre><code>pip install text-extractor[pdf]\npip install text-extractor[docx]\npip install text-extractor[md]\npip install text-extractor[rtf]\npip install text-extractor[html]\npip install text-extractor[all]  # All supported types\n</code></pre> <p>See pyproject.toml for all available extras.</p>"},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.9+</li> <li>Optional: Only the dependencies for the file types you use</li> </ul>"},{"location":"installation/#upgrading","title":"Upgrading","text":"<pre><code>pip install --upgrade text-extractor\n</code></pre>"},{"location":"testing/","title":"Testing","text":""},{"location":"testing/#running-the-test-suite","title":"Running the Test Suite","text":"<p>This project uses pytest for all tests.</p>"},{"location":"testing/#run-all-tests","title":"Run all tests","text":"<pre><code>pytest\n</code></pre>"},{"location":"testing/#run-a-specific-test-file","title":"Run a specific test file","text":"<pre><code>pytest textxtract/tests/test_sync.py\npytest textxtract/tests/test_async.py\n</code></pre>"},{"location":"testing/#run-tests-with-extra-dependencies","title":"Run tests with extra dependencies","text":"<p>If you want to test extraction for optional file types, install the relevant extras:</p> <pre><code>pip install text-extractor[all]\npytest\n</code></pre>"},{"location":"testing/#test-coverage","title":"Test Coverage","text":"<ul> <li>Handlers for all supported file types</li> <li>Error handling and exceptions</li> <li>Synchronous and asynchronous extractors</li> <li>Edge cases and invalid files</li> </ul>"},{"location":"testing/#adding-new-tests","title":"Adding New Tests","text":"<ol> <li>Add your test file in <code>textxtract/tests/</code> or <code>textxtract/tests/test_handlers/</code>.</li> <li>Use descriptive test names and docstrings.</li> <li>Run <code>pytest</code> to verify.</li> </ol>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#synchronous-extraction","title":"Synchronous Extraction","text":"<pre><code>from textxtract import SyncTextExtractor\n\n# file_bytes: bytes of your file\n# filename: name of your file (e.g. \"document.pdf\")\nextractor = SyncTextExtractor()\ntext = extractor.extract(file_bytes, filename)\nprint(text)\n</code></pre>"},{"location":"usage/#asynchronous-extraction","title":"Asynchronous Extraction","text":"<pre><code>from textxtract.aio import AsyncTextExtractor\nimport asyncio\n\nextractor = AsyncTextExtractor()\ntext = asyncio.run(extractor.extract_async(file_bytes, filename))\nprint(text)\n</code></pre>"},{"location":"usage/#supported-file-types","title":"Supported File Types","text":"Extension Extra Dependency Handler .pdf [pdf] PyMuPDF .docx [docx] python-docx .doc [doc] antiword .txt stdlib .md [md] markdown .rtf [rtf] pyrtf-ng .html/.htm [html] beautifulsoup4 .csv stdlib .json stdlib .xml [xml] lxml .zip stdlib"},{"location":"usage/#error-handling","title":"Error Handling","text":"<p>All extractors raise custom exceptions from <code>textxtract.core.exceptions</code>: - <code>ExtractionError</code> - <code>InvalidFileError</code> - <code>FileTypeNotSupportedError</code> - <code>ExtractionTimeoutError</code></p>"},{"location":"usage/#logging","title":"Logging","text":"<p>Configure logging as desired. By default, debug and info logs are available:</p> <pre><code>import logging\nlogging.basicConfig(level=logging.DEBUG)\n</code></pre>"},{"location":"usage/#custom-handlers","title":"Custom Handlers","text":"<p>You can register your own file type handlers via the configuration API.</p>"},{"location":"reference/","title":"API Reference","text":"<p>Welcome to the Text Extractor API reference documentation.</p>"},{"location":"reference/#main-components","title":"Main Components","text":"<ul> <li>Sync Extractor - Synchronous text extraction</li> <li>Async Extractor - Asynchronous text extraction</li> <li>Core Components - Base classes and utilities</li> <li>Handlers - File format handlers</li> </ul>"},{"location":"reference/__init__/","title":"Text Extractor Package","text":"<p>Text Extractor package root.</p> <p>Modules:</p> Name Description <code>aio</code> <p>Asynchronous extraction logic package.</p> <code>core</code> <p>Core components for textxtract package.</p> <code>handlers</code> <p>File type-specific handlers package.</p> <code>sync</code> <p>Synchronous extraction logic package.</p> <code>tests</code> <p>Test suite for textxtract package.</p> <p>Classes:</p> Name Description <code>SyncTextExtractor</code> <p>Synchronous text extractor with improved error handling and resource management.</p>"},{"location":"reference/__init__/#textxtract-attributes","title":"Attributes","text":""},{"location":"reference/__init__/#textxtract.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['SyncTextExtractor']\n</code></pre>"},{"location":"reference/__init__/#textxtract-classes","title":"Classes","text":""},{"location":"reference/__init__/#textxtract.SyncTextExtractor","title":"SyncTextExtractor","text":"<p>               Bases: <code>TextExtractor</code></p> <p>Synchronous text extractor with improved error handling and resource management.</p> <p>Provides synchronous text extraction from various file types. Logs debug and info level messages for tracing and diagnostics. Supports context manager protocol for proper cleanup.</p> <p>Methods:</p> Name Description <code>__enter__</code> <p>Context manager entry.</p> <code>__exit__</code> <p>Context manager exit.</p> <code>__init__</code> <code>extract</code> <p>Extract text synchronously from file bytes.</p> <code>extract_async</code> <p>Async interface for compatibility; delegates to sync extract.</p> <p>Attributes:</p> Name Type Description <code>config</code> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>class SyncTextExtractor(TextExtractor):\n    \"\"\"\n    Synchronous text extractor with improved error handling and resource management.\n\n    Provides synchronous text extraction from various file types.\n    Logs debug and info level messages for tracing and diagnostics.\n    Supports context manager protocol for proper cleanup.\n    \"\"\"\n\n    def __init__(self, config: Optional[ExtractorConfig] = None):\n        self.config = config or ExtractorConfig()\n        logger.debug(\n            \"SyncTextExtractor initialized with config: %s\", self.config.__dict__\n        )\n\n    def extract(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"\n        Extract text synchronously from file bytes.\n\n        Args:\n            file_bytes (bytes): The file content as bytes.\n            filename (str): The name of the file (used for extension).\n            config (Optional[dict]): Optional configuration overrides.\n\n        Returns:\n            str: Extracted text.\n\n        Raises:\n            FileTypeNotSupportedError: If the file extension is not supported.\n            ExtractionError: If extraction fails.\n            InvalidFileError: If the file is invalid or corrupted.\n        \"\"\"\n        file_info = get_file_info(file_bytes, filename)\n        temp_path = create_temp_file(\n            file_bytes, filename, config and config.get(\"max_file_size\")\n        )\n\n        logger.debug(\n            \"Temporary file created at %s for file info: %s\", temp_path, file_info\n        )\n\n        try:\n            suffix = Path(filename).suffix.lower()\n            logger.debug(\"Detected file suffix: %s\", suffix)\n\n            handler = registry.get_handler(suffix)\n            handler_name = handler.__class__.__name__\n\n            logger.info(\n                \"Using handler %s for file %s (size: %s MB)\",\n                handler_name,\n                filename,\n                file_info[\"size_mb\"],\n            )\n\n            try:\n                result = handler.extract(temp_path, config or self.config.__dict__)\n            except Exception as e:\n                from textxtract.core.exceptions import (\n                    ExtractionError,\n                    InvalidFileError,\n                )\n\n                logger.error(\n                    \"Extraction failed for file %s (handler: %s): %s\",\n                    filename,\n                    handler_name,\n                    e,\n                )\n\n                # If it's already a custom extraction error, re-raise\n                if isinstance(e, ExtractionError):\n                    raise\n                # If it's a known invalid file error, wrap it\n                if isinstance(e, (ValueError, OSError)):\n                    raise InvalidFileError(\n                        f\"Invalid file: {filename} (handler: {handler_name}, error: {e})\"\n                    ) from e\n                # Otherwise, wrap as general extraction error\n                raise ExtractionError(\n                    f\"Extraction failed for file {filename} using {handler_name}: {e}\"\n                ) from e\n\n            logger.info(\n                \"Extraction successful for file %s (extracted %d characters)\",\n                filename,\n                len(result),\n            )\n            return result\n        finally:\n            safe_unlink(temp_path)\n            logger.debug(\"Temporary file %s deleted\", temp_path)\n\n    async def extract_async(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"\n        Async interface for compatibility; delegates to sync extract.\n\n        Raises:\n            NotImplementedError: Always, as sync extractor does not support async.\n        \"\"\"\n        raise NotImplementedError(\n            \"Synchronous extractor does not support async extraction. Use AsyncTextExtractor instead.\"\n        )\n\n    def __enter__(self):\n        \"\"\"Context manager entry.\"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit.\"\"\"\n        pass  # No resources to clean up for sync extractor\n</code></pre>"},{"location":"reference/__init__/#textxtract.SyncTextExtractor-attributes","title":"Attributes","text":""},{"location":"reference/__init__/#textxtract.SyncTextExtractor.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = config or ExtractorConfig()\n</code></pre>"},{"location":"reference/__init__/#textxtract.SyncTextExtractor-functions","title":"Functions","text":""},{"location":"reference/__init__/#textxtract.SyncTextExtractor.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>Context manager entry.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/__init__/#textxtract.SyncTextExtractor.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Context manager exit.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    pass  # No resources to clean up for sync extractor\n</code></pre>"},{"location":"reference/__init__/#textxtract.SyncTextExtractor.__init__","title":"__init__","text":"<pre><code>__init__(config=None)\n</code></pre> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def __init__(self, config: Optional[ExtractorConfig] = None):\n    self.config = config or ExtractorConfig()\n    logger.debug(\n        \"SyncTextExtractor initialized with config: %s\", self.config.__dict__\n    )\n</code></pre>"},{"location":"reference/__init__/#textxtract.SyncTextExtractor.extract","title":"extract","text":"<pre><code>extract(file_bytes, filename, config=None)\n</code></pre> <p>Extract text synchronously from file bytes.</p> <p>Parameters:</p> Name Type Description Default <code>bytes</code> <p>The file content as bytes.</p> required <code>str</code> <p>The name of the file (used for extension).</p> required <code>Optional[dict]</code> <p>Optional configuration overrides.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted text.</p> <p>Raises:</p> Type Description <code>FileTypeNotSupportedError</code> <p>If the file extension is not supported.</p> <code>ExtractionError</code> <p>If extraction fails.</p> <code>InvalidFileError</code> <p>If the file is invalid or corrupted.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def extract(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"\n    Extract text synchronously from file bytes.\n\n    Args:\n        file_bytes (bytes): The file content as bytes.\n        filename (str): The name of the file (used for extension).\n        config (Optional[dict]): Optional configuration overrides.\n\n    Returns:\n        str: Extracted text.\n\n    Raises:\n        FileTypeNotSupportedError: If the file extension is not supported.\n        ExtractionError: If extraction fails.\n        InvalidFileError: If the file is invalid or corrupted.\n    \"\"\"\n    file_info = get_file_info(file_bytes, filename)\n    temp_path = create_temp_file(\n        file_bytes, filename, config and config.get(\"max_file_size\")\n    )\n\n    logger.debug(\n        \"Temporary file created at %s for file info: %s\", temp_path, file_info\n    )\n\n    try:\n        suffix = Path(filename).suffix.lower()\n        logger.debug(\"Detected file suffix: %s\", suffix)\n\n        handler = registry.get_handler(suffix)\n        handler_name = handler.__class__.__name__\n\n        logger.info(\n            \"Using handler %s for file %s (size: %s MB)\",\n            handler_name,\n            filename,\n            file_info[\"size_mb\"],\n        )\n\n        try:\n            result = handler.extract(temp_path, config or self.config.__dict__)\n        except Exception as e:\n            from textxtract.core.exceptions import (\n                ExtractionError,\n                InvalidFileError,\n            )\n\n            logger.error(\n                \"Extraction failed for file %s (handler: %s): %s\",\n                filename,\n                handler_name,\n                e,\n            )\n\n            # If it's already a custom extraction error, re-raise\n            if isinstance(e, ExtractionError):\n                raise\n            # If it's a known invalid file error, wrap it\n            if isinstance(e, (ValueError, OSError)):\n                raise InvalidFileError(\n                    f\"Invalid file: {filename} (handler: {handler_name}, error: {e})\"\n                ) from e\n            # Otherwise, wrap as general extraction error\n            raise ExtractionError(\n                f\"Extraction failed for file {filename} using {handler_name}: {e}\"\n            ) from e\n\n        logger.info(\n            \"Extraction successful for file %s (extracted %d characters)\",\n            filename,\n            len(result),\n        )\n        return result\n    finally:\n        safe_unlink(temp_path)\n        logger.debug(\"Temporary file %s deleted\", temp_path)\n</code></pre>"},{"location":"reference/__init__/#textxtract.SyncTextExtractor.extract(file_bytes)","title":"<code>file_bytes</code>","text":""},{"location":"reference/__init__/#textxtract.SyncTextExtractor.extract(filename)","title":"<code>filename</code>","text":""},{"location":"reference/__init__/#textxtract.SyncTextExtractor.extract(config)","title":"<code>config</code>","text":""},{"location":"reference/__init__/#textxtract.SyncTextExtractor.extract_async","title":"extract_async  <code>async</code>","text":"<pre><code>extract_async(file_bytes, filename, config=None)\n</code></pre> <p>Async interface for compatibility; delegates to sync extract.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always, as sync extractor does not support async.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>async def extract_async(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"\n    Async interface for compatibility; delegates to sync extract.\n\n    Raises:\n        NotImplementedError: Always, as sync extractor does not support async.\n    \"\"\"\n    raise NotImplementedError(\n        \"Synchronous extractor does not support async extraction. Use AsyncTextExtractor instead.\"\n    )\n</code></pre>"},{"location":"reference/__init__/#textxtract-modules","title":"Modules","text":""},{"location":"reference/__init__/#textxtract.aio","title":"aio","text":"<p>Asynchronous extraction logic package.</p> <p>Modules:</p> Name Description <code>extractor</code> <p>Asynchronous text extraction logic.</p> <p>Classes:</p> Name Description <code>AsyncTextExtractor</code> <p>Asynchronous text extractor with proper resource management.</p>"},{"location":"reference/__init__/#textxtract.aio-attributes","title":"Attributes","text":""},{"location":"reference/__init__/#textxtract.aio.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['AsyncTextExtractor']\n</code></pre>"},{"location":"reference/__init__/#textxtract.aio-classes","title":"Classes","text":""},{"location":"reference/__init__/#textxtract.aio.AsyncTextExtractor","title":"AsyncTextExtractor","text":"<p>               Bases: <code>TextExtractor</code></p> <p>Asynchronous text extractor with proper resource management.</p> <p>Provides asynchronous text extraction from various file types. Logs debug and info level messages for tracing and diagnostics. Supports context manager protocol for proper cleanup.</p> <p>Methods:</p> Name Description <code>__aenter__</code> <p>Async context manager entry.</p> <code>__aexit__</code> <p>Async context manager exit.</p> <code>__del__</code> <p>Destructor to ensure cleanup.</p> <code>__enter__</code> <p>Context manager entry.</p> <code>__exit__</code> <p>Context manager exit.</p> <code>__init__</code> <code>close</code> <p>Close the extractor and clean up resources.</p> <code>extract</code> <p>Sync interface for compatibility; delegates to async extract.</p> <code>extract_async</code> <p>Extract text asynchronously from file bytes using a thread pool.</p> <p>Attributes:</p> Name Type Description <code>config</code> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>class AsyncTextExtractor(TextExtractor):\n    \"\"\"\n    Asynchronous text extractor with proper resource management.\n\n    Provides asynchronous text extraction from various file types.\n    Logs debug and info level messages for tracing and diagnostics.\n    Supports context manager protocol for proper cleanup.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: Optional[ExtractorConfig] = None,\n        max_workers: Optional[int] = None,\n    ):\n        self.config = config or ExtractorConfig()\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._closed = False\n\n        # Register cleanup on exit\n        atexit.register(self._cleanup)\n\n        logger.debug(\n            \"AsyncTextExtractor initialized with config: %s, max_workers: %s\",\n            self.config.__dict__,\n            max_workers,\n        )\n\n    def extract(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"\n        Sync interface for compatibility; delegates to async extract.\n\n        Raises:\n            NotImplementedError: Always, as async extractor requires async usage.\n        \"\"\"\n        raise NotImplementedError(\n            \"Use extract_async() for asynchronous extraction or use SyncTextExtractor\"\n        )\n\n    async def extract_async(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"\n        Extract text asynchronously from file bytes using a thread pool.\n\n        Args:\n            file_bytes (bytes): The file content as bytes.\n            filename (str): The name of the file (used for extension).\n            config (Optional[dict]): Optional configuration overrides.\n\n        Returns:\n            str: Extracted text.\n\n        Raises:\n            FileTypeNotSupportedError: If the file extension is not supported.\n            ExtractionError: If extraction fails.\n            RuntimeError: If extractor is closed.\n        \"\"\"\n        if self._closed:\n            raise RuntimeError(\"Extractor has been closed\")\n\n        file_info = get_file_info(file_bytes, filename)\n        temp_path = create_temp_file(\n            file_bytes, filename, config and config.get(\"max_file_size\")\n        )\n\n        logger.debug(\n            \"Temporary file created at %s for file info: %s\", temp_path, file_info\n        )\n\n        try:\n            suffix = Path(filename).suffix.lower()\n            logger.debug(\"Detected file suffix: %s\", suffix)\n\n            handler = registry.get_handler(suffix)\n            handler_name = handler.__class__.__name__\n\n            logger.info(\n                \"Using handler %s for file %s (size: %s MB)\",\n                handler_name,\n                filename,\n                file_info[\"size_mb\"],\n            )\n\n            loop = asyncio.get_running_loop()\n            try:\n                # Offload sync handler to thread pool for I/O-bound tasks\n                result = await loop.run_in_executor(\n                    self._executor,\n                    handler.extract,\n                    temp_path,\n                    config or self.config.__dict__,\n                )\n            except Exception as e:\n                from textxtract.core.exceptions import (\n                    ExtractionError,\n                    InvalidFileError,\n                )\n\n                logger.error(\n                    \"Extraction failed for file %s (handler: %s): %s\",\n                    filename,\n                    handler_name,\n                    e,\n                )\n\n                # If it's already a custom extraction error, re-raise\n                if isinstance(e, ExtractionError):\n                    raise\n                # If it's a known invalid file error, wrap it\n                if isinstance(e, (ValueError, OSError)):\n                    raise InvalidFileError(\n                        f\"Invalid file: {filename} (handler: {handler_name}, error: {e})\"\n                    ) from e\n                # Otherwise, wrap as general extraction error\n                raise ExtractionError(\n                    f\"Extraction failed for file {filename} using {handler_name}: {e}\"\n                ) from e\n\n            logger.info(\n                \"Extraction successful for file %s (extracted %d characters)\",\n                filename,\n                len(result),\n            )\n            return result\n        finally:\n            safe_unlink(temp_path)\n            logger.debug(\"Temporary file %s deleted\", temp_path)\n\n    def close(self):\n        \"\"\"Close the extractor and clean up resources.\"\"\"\n        if not self._closed:\n            self._cleanup()\n            self._closed = True\n\n    def _cleanup(self):\n        \"\"\"Internal cleanup method.\"\"\"\n        if hasattr(self, \"_executor\") and self._executor:\n            try:\n                self._executor.shutdown(wait=True, cancel_futures=True)\n                logger.debug(\"ThreadPoolExecutor shut down successfully\")\n            except Exception as e:\n                logger.warning(\"Error shutting down ThreadPoolExecutor: %s\", e)\n\n    def __enter__(self):\n        \"\"\"Context manager entry.\"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit.\"\"\"\n        self.close()\n\n    async def __aenter__(self):\n        \"\"\"Async context manager entry.\"\"\"\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Async context manager exit.\"\"\"\n        self.close()\n\n    def __del__(self):\n        \"\"\"Destructor to ensure cleanup.\"\"\"\n        if not self._closed:\n            self._cleanup()\n</code></pre>"},{"location":"reference/__init__/#textxtract.aio.AsyncTextExtractor-attributes","title":"Attributes","text":"config <code>instance-attribute</code> <pre><code>config = config or ExtractorConfig()\n</code></pre>"},{"location":"reference/__init__/#textxtract.aio.AsyncTextExtractor-functions","title":"Functions","text":"__aenter__ <code>async</code> <pre><code>__aenter__()\n</code></pre> <p>Async context manager entry.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def __aenter__(self):\n    \"\"\"Async context manager entry.\"\"\"\n    return self\n</code></pre> <code></code> __aexit__ <code>async</code> <pre><code>__aexit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Async context manager exit.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Async context manager exit.\"\"\"\n    self.close()\n</code></pre> <code></code> __del__ <pre><code>__del__()\n</code></pre> <p>Destructor to ensure cleanup.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __del__(self):\n    \"\"\"Destructor to ensure cleanup.\"\"\"\n    if not self._closed:\n        self._cleanup()\n</code></pre> <code></code> __enter__ <pre><code>__enter__()\n</code></pre> <p>Context manager entry.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    return self\n</code></pre> <code></code> __exit__ <pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Context manager exit.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    self.close()\n</code></pre> <code></code> __init__ <pre><code>__init__(config=None, max_workers=None)\n</code></pre> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __init__(\n    self,\n    config: Optional[ExtractorConfig] = None,\n    max_workers: Optional[int] = None,\n):\n    self.config = config or ExtractorConfig()\n    self._executor = ThreadPoolExecutor(max_workers=max_workers)\n    self._closed = False\n\n    # Register cleanup on exit\n    atexit.register(self._cleanup)\n\n    logger.debug(\n        \"AsyncTextExtractor initialized with config: %s, max_workers: %s\",\n        self.config.__dict__,\n        max_workers,\n    )\n</code></pre> <code></code> close <pre><code>close()\n</code></pre> <p>Close the extractor and clean up resources.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def close(self):\n    \"\"\"Close the extractor and clean up resources.\"\"\"\n    if not self._closed:\n        self._cleanup()\n        self._closed = True\n</code></pre> <code></code> extract <pre><code>extract(file_bytes, filename, config=None)\n</code></pre> <p>Sync interface for compatibility; delegates to async extract.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always, as async extractor requires async usage.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def extract(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"\n    Sync interface for compatibility; delegates to async extract.\n\n    Raises:\n        NotImplementedError: Always, as async extractor requires async usage.\n    \"\"\"\n    raise NotImplementedError(\n        \"Use extract_async() for asynchronous extraction or use SyncTextExtractor\"\n    )\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_bytes, filename, config=None)\n</code></pre> <p>Extract text asynchronously from file bytes using a thread pool.</p> <p>Parameters:</p> Name Type Description Default <code>file_bytes</code> <code>bytes</code> <p>The file content as bytes.</p> required <code>filename</code> <code>str</code> <p>The name of the file (used for extension).</p> required <code>config</code> <code>Optional[dict]</code> <p>Optional configuration overrides.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted text.</p> <p>Raises:</p> Type Description <code>FileTypeNotSupportedError</code> <p>If the file extension is not supported.</p> <code>ExtractionError</code> <p>If extraction fails.</p> <code>RuntimeError</code> <p>If extractor is closed.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def extract_async(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"\n    Extract text asynchronously from file bytes using a thread pool.\n\n    Args:\n        file_bytes (bytes): The file content as bytes.\n        filename (str): The name of the file (used for extension).\n        config (Optional[dict]): Optional configuration overrides.\n\n    Returns:\n        str: Extracted text.\n\n    Raises:\n        FileTypeNotSupportedError: If the file extension is not supported.\n        ExtractionError: If extraction fails.\n        RuntimeError: If extractor is closed.\n    \"\"\"\n    if self._closed:\n        raise RuntimeError(\"Extractor has been closed\")\n\n    file_info = get_file_info(file_bytes, filename)\n    temp_path = create_temp_file(\n        file_bytes, filename, config and config.get(\"max_file_size\")\n    )\n\n    logger.debug(\n        \"Temporary file created at %s for file info: %s\", temp_path, file_info\n    )\n\n    try:\n        suffix = Path(filename).suffix.lower()\n        logger.debug(\"Detected file suffix: %s\", suffix)\n\n        handler = registry.get_handler(suffix)\n        handler_name = handler.__class__.__name__\n\n        logger.info(\n            \"Using handler %s for file %s (size: %s MB)\",\n            handler_name,\n            filename,\n            file_info[\"size_mb\"],\n        )\n\n        loop = asyncio.get_running_loop()\n        try:\n            # Offload sync handler to thread pool for I/O-bound tasks\n            result = await loop.run_in_executor(\n                self._executor,\n                handler.extract,\n                temp_path,\n                config or self.config.__dict__,\n            )\n        except Exception as e:\n            from textxtract.core.exceptions import (\n                ExtractionError,\n                InvalidFileError,\n            )\n\n            logger.error(\n                \"Extraction failed for file %s (handler: %s): %s\",\n                filename,\n                handler_name,\n                e,\n            )\n\n            # If it's already a custom extraction error, re-raise\n            if isinstance(e, ExtractionError):\n                raise\n            # If it's a known invalid file error, wrap it\n            if isinstance(e, (ValueError, OSError)):\n                raise InvalidFileError(\n                    f\"Invalid file: {filename} (handler: {handler_name}, error: {e})\"\n                ) from e\n            # Otherwise, wrap as general extraction error\n            raise ExtractionError(\n                f\"Extraction failed for file {filename} using {handler_name}: {e}\"\n            ) from e\n\n        logger.info(\n            \"Extraction successful for file %s (extracted %d characters)\",\n            filename,\n            len(result),\n        )\n        return result\n    finally:\n        safe_unlink(temp_path)\n        logger.debug(\"Temporary file %s deleted\", temp_path)\n</code></pre>"},{"location":"reference/__init__/#textxtract.aio-modules","title":"Modules","text":""},{"location":"reference/__init__/#textxtract.aio.extractor","title":"extractor","text":"<p>Asynchronous text extraction logic.</p> <p>Classes:</p> Name Description <code>AsyncTextExtractor</code> <p>Asynchronous text extractor with proper resource management.</p> <p>Attributes:</p> Name Type Description <code>logger</code>"},{"location":"reference/__init__/#textxtract.aio.extractor-attributes","title":"Attributes","text":"logger <code>module-attribute</code> <pre><code>logger = getLogger('textxtract.aio')\n</code></pre>"},{"location":"reference/__init__/#textxtract.aio.extractor-classes","title":"Classes","text":"AsyncTextExtractor <p>               Bases: <code>TextExtractor</code></p> <p>Asynchronous text extractor with proper resource management.</p> <p>Provides asynchronous text extraction from various file types. Logs debug and info level messages for tracing and diagnostics. Supports context manager protocol for proper cleanup.</p> <p>Methods:</p> Name Description <code>__aenter__</code> <p>Async context manager entry.</p> <code>__aexit__</code> <p>Async context manager exit.</p> <code>__del__</code> <p>Destructor to ensure cleanup.</p> <code>__enter__</code> <p>Context manager entry.</p> <code>__exit__</code> <p>Context manager exit.</p> <code>__init__</code> <code>close</code> <p>Close the extractor and clean up resources.</p> <code>extract</code> <p>Sync interface for compatibility; delegates to async extract.</p> <code>extract_async</code> <p>Extract text asynchronously from file bytes using a thread pool.</p> <p>Attributes:</p> Name Type Description <code>config</code> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>class AsyncTextExtractor(TextExtractor):\n    \"\"\"\n    Asynchronous text extractor with proper resource management.\n\n    Provides asynchronous text extraction from various file types.\n    Logs debug and info level messages for tracing and diagnostics.\n    Supports context manager protocol for proper cleanup.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: Optional[ExtractorConfig] = None,\n        max_workers: Optional[int] = None,\n    ):\n        self.config = config or ExtractorConfig()\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._closed = False\n\n        # Register cleanup on exit\n        atexit.register(self._cleanup)\n\n        logger.debug(\n            \"AsyncTextExtractor initialized with config: %s, max_workers: %s\",\n            self.config.__dict__,\n            max_workers,\n        )\n\n    def extract(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"\n        Sync interface for compatibility; delegates to async extract.\n\n        Raises:\n            NotImplementedError: Always, as async extractor requires async usage.\n        \"\"\"\n        raise NotImplementedError(\n            \"Use extract_async() for asynchronous extraction or use SyncTextExtractor\"\n        )\n\n    async def extract_async(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"\n        Extract text asynchronously from file bytes using a thread pool.\n\n        Args:\n            file_bytes (bytes): The file content as bytes.\n            filename (str): The name of the file (used for extension).\n            config (Optional[dict]): Optional configuration overrides.\n\n        Returns:\n            str: Extracted text.\n\n        Raises:\n            FileTypeNotSupportedError: If the file extension is not supported.\n            ExtractionError: If extraction fails.\n            RuntimeError: If extractor is closed.\n        \"\"\"\n        if self._closed:\n            raise RuntimeError(\"Extractor has been closed\")\n\n        file_info = get_file_info(file_bytes, filename)\n        temp_path = create_temp_file(\n            file_bytes, filename, config and config.get(\"max_file_size\")\n        )\n\n        logger.debug(\n            \"Temporary file created at %s for file info: %s\", temp_path, file_info\n        )\n\n        try:\n            suffix = Path(filename).suffix.lower()\n            logger.debug(\"Detected file suffix: %s\", suffix)\n\n            handler = registry.get_handler(suffix)\n            handler_name = handler.__class__.__name__\n\n            logger.info(\n                \"Using handler %s for file %s (size: %s MB)\",\n                handler_name,\n                filename,\n                file_info[\"size_mb\"],\n            )\n\n            loop = asyncio.get_running_loop()\n            try:\n                # Offload sync handler to thread pool for I/O-bound tasks\n                result = await loop.run_in_executor(\n                    self._executor,\n                    handler.extract,\n                    temp_path,\n                    config or self.config.__dict__,\n                )\n            except Exception as e:\n                from textxtract.core.exceptions import (\n                    ExtractionError,\n                    InvalidFileError,\n                )\n\n                logger.error(\n                    \"Extraction failed for file %s (handler: %s): %s\",\n                    filename,\n                    handler_name,\n                    e,\n                )\n\n                # If it's already a custom extraction error, re-raise\n                if isinstance(e, ExtractionError):\n                    raise\n                # If it's a known invalid file error, wrap it\n                if isinstance(e, (ValueError, OSError)):\n                    raise InvalidFileError(\n                        f\"Invalid file: {filename} (handler: {handler_name}, error: {e})\"\n                    ) from e\n                # Otherwise, wrap as general extraction error\n                raise ExtractionError(\n                    f\"Extraction failed for file {filename} using {handler_name}: {e}\"\n                ) from e\n\n            logger.info(\n                \"Extraction successful for file %s (extracted %d characters)\",\n                filename,\n                len(result),\n            )\n            return result\n        finally:\n            safe_unlink(temp_path)\n            logger.debug(\"Temporary file %s deleted\", temp_path)\n\n    def close(self):\n        \"\"\"Close the extractor and clean up resources.\"\"\"\n        if not self._closed:\n            self._cleanup()\n            self._closed = True\n\n    def _cleanup(self):\n        \"\"\"Internal cleanup method.\"\"\"\n        if hasattr(self, \"_executor\") and self._executor:\n            try:\n                self._executor.shutdown(wait=True, cancel_futures=True)\n                logger.debug(\"ThreadPoolExecutor shut down successfully\")\n            except Exception as e:\n                logger.warning(\"Error shutting down ThreadPoolExecutor: %s\", e)\n\n    def __enter__(self):\n        \"\"\"Context manager entry.\"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit.\"\"\"\n        self.close()\n\n    async def __aenter__(self):\n        \"\"\"Async context manager entry.\"\"\"\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Async context manager exit.\"\"\"\n        self.close()\n\n    def __del__(self):\n        \"\"\"Destructor to ensure cleanup.\"\"\"\n        if not self._closed:\n            self._cleanup()\n</code></pre> Attributes <code></code> config <code>instance-attribute</code> <pre><code>config = config or ExtractorConfig()\n</code></pre> Functions <code></code> __aenter__ <code>async</code> <pre><code>__aenter__()\n</code></pre> <p>Async context manager entry.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def __aenter__(self):\n    \"\"\"Async context manager entry.\"\"\"\n    return self\n</code></pre> <code></code> __aexit__ <code>async</code> <pre><code>__aexit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Async context manager exit.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Async context manager exit.\"\"\"\n    self.close()\n</code></pre> <code></code> __del__ <pre><code>__del__()\n</code></pre> <p>Destructor to ensure cleanup.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __del__(self):\n    \"\"\"Destructor to ensure cleanup.\"\"\"\n    if not self._closed:\n        self._cleanup()\n</code></pre> <code></code> __enter__ <pre><code>__enter__()\n</code></pre> <p>Context manager entry.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    return self\n</code></pre> <code></code> __exit__ <pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Context manager exit.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    self.close()\n</code></pre> <code></code> __init__ <pre><code>__init__(config=None, max_workers=None)\n</code></pre> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __init__(\n    self,\n    config: Optional[ExtractorConfig] = None,\n    max_workers: Optional[int] = None,\n):\n    self.config = config or ExtractorConfig()\n    self._executor = ThreadPoolExecutor(max_workers=max_workers)\n    self._closed = False\n\n    # Register cleanup on exit\n    atexit.register(self._cleanup)\n\n    logger.debug(\n        \"AsyncTextExtractor initialized with config: %s, max_workers: %s\",\n        self.config.__dict__,\n        max_workers,\n    )\n</code></pre> <code></code> close <pre><code>close()\n</code></pre> <p>Close the extractor and clean up resources.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def close(self):\n    \"\"\"Close the extractor and clean up resources.\"\"\"\n    if not self._closed:\n        self._cleanup()\n        self._closed = True\n</code></pre> <code></code> extract <pre><code>extract(file_bytes, filename, config=None)\n</code></pre> <p>Sync interface for compatibility; delegates to async extract.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always, as async extractor requires async usage.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def extract(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"\n    Sync interface for compatibility; delegates to async extract.\n\n    Raises:\n        NotImplementedError: Always, as async extractor requires async usage.\n    \"\"\"\n    raise NotImplementedError(\n        \"Use extract_async() for asynchronous extraction or use SyncTextExtractor\"\n    )\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_bytes, filename, config=None)\n</code></pre> <p>Extract text asynchronously from file bytes using a thread pool.</p> <p>Parameters:</p> Name Type Description Default <code>file_bytes</code> <code>bytes</code> <p>The file content as bytes.</p> required <code>filename</code> <code>str</code> <p>The name of the file (used for extension).</p> required <code>config</code> <code>Optional[dict]</code> <p>Optional configuration overrides.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted text.</p> <p>Raises:</p> Type Description <code>FileTypeNotSupportedError</code> <p>If the file extension is not supported.</p> <code>ExtractionError</code> <p>If extraction fails.</p> <code>RuntimeError</code> <p>If extractor is closed.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def extract_async(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"\n    Extract text asynchronously from file bytes using a thread pool.\n\n    Args:\n        file_bytes (bytes): The file content as bytes.\n        filename (str): The name of the file (used for extension).\n        config (Optional[dict]): Optional configuration overrides.\n\n    Returns:\n        str: Extracted text.\n\n    Raises:\n        FileTypeNotSupportedError: If the file extension is not supported.\n        ExtractionError: If extraction fails.\n        RuntimeError: If extractor is closed.\n    \"\"\"\n    if self._closed:\n        raise RuntimeError(\"Extractor has been closed\")\n\n    file_info = get_file_info(file_bytes, filename)\n    temp_path = create_temp_file(\n        file_bytes, filename, config and config.get(\"max_file_size\")\n    )\n\n    logger.debug(\n        \"Temporary file created at %s for file info: %s\", temp_path, file_info\n    )\n\n    try:\n        suffix = Path(filename).suffix.lower()\n        logger.debug(\"Detected file suffix: %s\", suffix)\n\n        handler = registry.get_handler(suffix)\n        handler_name = handler.__class__.__name__\n\n        logger.info(\n            \"Using handler %s for file %s (size: %s MB)\",\n            handler_name,\n            filename,\n            file_info[\"size_mb\"],\n        )\n\n        loop = asyncio.get_running_loop()\n        try:\n            # Offload sync handler to thread pool for I/O-bound tasks\n            result = await loop.run_in_executor(\n                self._executor,\n                handler.extract,\n                temp_path,\n                config or self.config.__dict__,\n            )\n        except Exception as e:\n            from textxtract.core.exceptions import (\n                ExtractionError,\n                InvalidFileError,\n            )\n\n            logger.error(\n                \"Extraction failed for file %s (handler: %s): %s\",\n                filename,\n                handler_name,\n                e,\n            )\n\n            # If it's already a custom extraction error, re-raise\n            if isinstance(e, ExtractionError):\n                raise\n            # If it's a known invalid file error, wrap it\n            if isinstance(e, (ValueError, OSError)):\n                raise InvalidFileError(\n                    f\"Invalid file: {filename} (handler: {handler_name}, error: {e})\"\n                ) from e\n            # Otherwise, wrap as general extraction error\n            raise ExtractionError(\n                f\"Extraction failed for file {filename} using {handler_name}: {e}\"\n            ) from e\n\n        logger.info(\n            \"Extraction successful for file %s (extracted %d characters)\",\n            filename,\n            len(result),\n        )\n        return result\n    finally:\n        safe_unlink(temp_path)\n        logger.debug(\"Temporary file %s deleted\", temp_path)\n</code></pre>"},{"location":"reference/__init__/#textxtract.aio.extractor-functions","title":"Functions","text":""},{"location":"reference/__init__/#textxtract.core","title":"core","text":"<p>Core components for textxtract package.</p> <p>Modules:</p> Name Description <code>base</code> <p>Abstract base classes for text extraction.</p> <code>config</code> <p>Configuration and customization for textxtract package.</p> <code>exceptions</code> <p>Custom exceptions for textxtract package.</p> <code>logging_config</code> <p>Logging configuration for textxtract package.</p> <code>registry</code> <p>Handler registry for centralized handler management.</p> <code>utils</code> <p>Utility functions for textxtract package.</p>"},{"location":"reference/__init__/#textxtract.core-modules","title":"Modules","text":""},{"location":"reference/__init__/#textxtract.core.base","title":"base","text":"<p>Abstract base classes for text extraction.</p> <p>Classes:</p> Name Description <code>FileTypeHandler</code> <p>Abstract base class for file type-specific handlers.</p> <code>TextExtractor</code> <p>Abstract base class for text extractors.</p>"},{"location":"reference/__init__/#textxtract.core.base-classes","title":"Classes","text":"FileTypeHandler <p>               Bases: <code>ABC</code></p> <p>Abstract base class for file type-specific handlers.</p> <p>Methods:</p> Name Description <code>extract</code> <p>Extract text synchronously from a file.</p> <code>extract_async</code> <p>Extract text asynchronously from a file.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>class FileTypeHandler(ABC):\n    \"\"\"Abstract base class for file type-specific handlers.\"\"\"\n\n    @abstractmethod\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        \"\"\"Extract text synchronously from a file.\"\"\"\n        pass\n\n    @abstractmethod\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"Extract text asynchronously from a file.\"\"\"\n        pass\n</code></pre> Functions <code></code> extract <code>abstractmethod</code> <pre><code>extract(file_path, config=None)\n</code></pre> <p>Extract text synchronously from a file.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>@abstractmethod\ndef extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    \"\"\"Extract text synchronously from a file.\"\"\"\n    pass\n</code></pre> <code></code> extract_async <code>abstractmethod</code> <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> <p>Extract text asynchronously from a file.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>@abstractmethod\nasync def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"Extract text asynchronously from a file.\"\"\"\n    pass\n</code></pre> <code></code> TextExtractor <p>               Bases: <code>ABC</code></p> <p>Abstract base class for text extractors.</p> <p>Methods:</p> Name Description <code>extract</code> <p>Extract text synchronously from file bytes.</p> <code>extract_async</code> <p>Extract text asynchronously from file bytes.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>class TextExtractor(ABC):\n    \"\"\"Abstract base class for text extractors.\"\"\"\n\n    @abstractmethod\n    def extract(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"Extract text synchronously from file bytes.\"\"\"\n        pass\n\n    @abstractmethod\n    async def extract_async(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"Extract text asynchronously from file bytes.\"\"\"\n        pass\n</code></pre> Functions <code></code> extract <code>abstractmethod</code> <pre><code>extract(file_bytes, filename, config=None)\n</code></pre> <p>Extract text synchronously from file bytes.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>@abstractmethod\ndef extract(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"Extract text synchronously from file bytes.\"\"\"\n    pass\n</code></pre> <code></code> extract_async <code>abstractmethod</code> <code>async</code> <pre><code>extract_async(file_bytes, filename, config=None)\n</code></pre> <p>Extract text asynchronously from file bytes.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>@abstractmethod\nasync def extract_async(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"Extract text asynchronously from file bytes.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/__init__/#textxtract.core.config","title":"config","text":"<p>Configuration and customization for textxtract package.</p> <p>Classes:</p> Name Description <code>ExtractorConfig</code> <p>Enhanced configuration options for text extraction with validation.</p>"},{"location":"reference/__init__/#textxtract.core.config-classes","title":"Classes","text":"ExtractorConfig <p>Enhanced configuration options for text extraction with validation.</p> <p>Methods:</p> Name Description <code>__init__</code> <code>__repr__</code> <code>from_file</code> <p>Load configuration from a file (JSON, YAML, or TOML).</p> <code>get_handler</code> <p>Retrieve a handler for a given file extension.</p> <code>get_handler_config</code> <p>Get configuration specific to a handler.</p> <code>register_handler</code> <p>Register a custom file type handler.</p> <code>to_dict</code> <p>Convert configuration to dictionary.</p> <p>Attributes:</p> Name Type Description <code>custom_handlers</code> <code>encoding</code> <code>extra_config</code> <code>logging_format</code> <code>logging_level</code> <code>max_file_size</code> <code>max_memory_usage</code> <code>timeout</code> Source code in <code>textxtract/core/config.py</code> <pre><code>class ExtractorConfig:\n    \"\"\"Enhanced configuration options for text extraction with validation.\"\"\"\n\n    def __init__(\n        self,\n        encoding: str = \"utf-8\",\n        logging_level: str = \"INFO\",\n        logging_format: Optional[str] = None,\n        timeout: Optional[float] = None,\n        max_file_size: Optional[int] = None,\n        max_memory_usage: Optional[int] = None,\n        custom_handlers: Optional[Dict[str, Callable]] = None,\n        **kwargs,\n    ):\n        # Validate and set basic options\n        self.encoding = self._validate_encoding(encoding)\n        self.logging_level = self._validate_logging_level(logging_level)\n        self.logging_format = (\n            logging_format or \"%(asctime)s %(levelname)s %(name)s: %(message)s\"\n        )\n        self.timeout = self._validate_timeout(timeout)\n        self.max_file_size = self._validate_max_file_size(max_file_size)\n        self.max_memory_usage = max_memory_usage\n        self.custom_handlers = custom_handlers or {}\n\n        # Load from environment variables\n        self._load_from_env()\n\n        # Store additional kwargs for handler-specific config\n        self.extra_config = kwargs\n\n    def _validate_encoding(self, encoding: str) -&gt; str:\n        \"\"\"Validate encoding parameter.\"\"\"\n        if not isinstance(encoding, str):\n            raise ValueError(\"Encoding must be a string\")\n\n        # Test if encoding is valid\n        try:\n            \"test\".encode(encoding)\n        except LookupError:\n            raise ValueError(f\"Invalid encoding: {encoding}\")\n\n        return encoding\n\n    def _validate_logging_level(self, level: str) -&gt; str:\n        \"\"\"Validate logging level parameter.\"\"\"\n        valid_levels = {\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"}\n        if level.upper() not in valid_levels:\n            raise ValueError(\n                f\"Invalid logging level: {level}. Must be one of {valid_levels}\"\n            )\n        return level.upper()\n\n    def _validate_timeout(self, timeout: Optional[float]) -&gt; Optional[float]:\n        \"\"\"Validate timeout parameter.\"\"\"\n        if timeout is not None:\n            if not isinstance(timeout, (int, float)) or timeout &lt;= 0:\n                raise ValueError(\"Timeout must be a positive number\")\n        return timeout\n\n    def _validate_max_file_size(self, size: Optional[int]) -&gt; Optional[int]:\n        \"\"\"Validate max file size parameter.\"\"\"\n        if size is not None:\n            if not isinstance(size, int) or size &lt;= 0:\n                raise ValueError(\"Max file size must be a positive integer\")\n        return size\n\n    def _load_from_env(self):\n        \"\"\"Load configuration from environment variables.\"\"\"\n        # Override with environment variables if present\n        env_encoding = os.getenv(\"TEXT_EXTRACTOR_ENCODING\")\n        if env_encoding:\n            self.encoding = self._validate_encoding(env_encoding)\n\n        env_logging = os.getenv(\"TEXT_EXTRACTOR_LOG_LEVEL\")\n        if env_logging:\n            self.logging_level = self._validate_logging_level(env_logging)\n\n        env_timeout = os.getenv(\"TEXT_EXTRACTOR_TIMEOUT\")\n        if env_timeout:\n            try:\n                self.timeout = float(env_timeout)\n            except ValueError:\n                pass  # Ignore invalid values\n\n        env_max_size = os.getenv(\"TEXT_EXTRACTOR_MAX_FILE_SIZE\")\n        if env_max_size:\n            try:\n                self.max_file_size = int(env_max_size)\n            except ValueError:\n                pass  # Ignore invalid values\n\n    def register_handler(self, extension: str, handler: Callable):\n        \"\"\"Register a custom file type handler.\"\"\"\n        if not extension.startswith(\".\"):\n            extension = f\".{extension}\"\n        self.custom_handlers[extension.lower()] = handler\n\n    def get_handler(self, extension: str) -&gt; Optional[Callable]:\n        \"\"\"Retrieve a handler for a given file extension.\"\"\"\n        return self.custom_handlers.get(extension.lower())\n\n    def get_handler_config(self, handler_name: str) -&gt; Dict[str, Any]:\n        \"\"\"Get configuration specific to a handler.\"\"\"\n        base_config = {\n            \"encoding\": self.encoding,\n            \"timeout\": self.timeout,\n            \"max_file_size\": self.max_file_size,\n            \"max_memory_usage\": self.max_memory_usage,\n        }\n\n        # Add handler-specific config\n        handler_config_key = f\"{handler_name.lower()}_config\"\n        if handler_config_key in self.extra_config:\n            base_config.update(self.extra_config[handler_config_key])\n\n        return base_config\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert configuration to dictionary.\"\"\"\n        return {\n            \"encoding\": self.encoding,\n            \"logging_level\": self.logging_level,\n            \"logging_format\": self.logging_format,\n            \"timeout\": self.timeout,\n            \"max_file_size\": self.max_file_size,\n            \"max_memory_usage\": self.max_memory_usage,\n            \"custom_handlers\": {k: str(v) for k, v in self.custom_handlers.items()},\n            **self.extra_config,\n        }\n\n    @classmethod\n    def from_file(cls, config_path: Union[str, Path]) -&gt; \"ExtractorConfig\":\n        \"\"\"Load configuration from a file (JSON, YAML, or TOML).\"\"\"\n        config_path = Path(config_path)\n\n        if not config_path.exists():\n            raise FileNotFoundError(f\"Configuration file not found: {config_path}\")\n\n        content = config_path.read_text()\n\n        if config_path.suffix.lower() == \".json\":\n            import json\n\n            config_data = json.loads(content)\n        elif config_path.suffix.lower() in (\".yaml\", \".yml\"):\n            try:\n                import yaml\n\n                config_data = yaml.safe_load(content)\n            except ImportError:\n                raise ImportError(\"PyYAML is required to load YAML configuration files\")\n        elif config_path.suffix.lower() == \".toml\":\n            try:\n                import tomli\n\n                config_data = tomli.loads(content)\n            except ImportError:\n                raise ImportError(\"tomli is required to load TOML configuration files\")\n        else:\n            raise ValueError(\n                f\"Unsupported configuration file format: {config_path.suffix}\"\n            )\n\n        return cls(**config_data)\n\n    def __repr__(self) -&gt; str:\n        return f\"ExtractorConfig(encoding='{self.encoding}', logging_level='{self.logging_level}', timeout={self.timeout})\"\n</code></pre> Attributes <code></code> custom_handlers <code>instance-attribute</code> <pre><code>custom_handlers = custom_handlers or {}\n</code></pre> <code></code> encoding <code>instance-attribute</code> <pre><code>encoding = _validate_encoding(encoding)\n</code></pre> <code></code> extra_config <code>instance-attribute</code> <pre><code>extra_config = kwargs\n</code></pre> <code></code> logging_format <code>instance-attribute</code> <pre><code>logging_format = logging_format or '%(asctime)s %(levelname)s %(name)s: %(message)s'\n</code></pre> <code></code> logging_level <code>instance-attribute</code> <pre><code>logging_level = _validate_logging_level(logging_level)\n</code></pre> <code></code> max_file_size <code>instance-attribute</code> <pre><code>max_file_size = _validate_max_file_size(max_file_size)\n</code></pre> <code></code> max_memory_usage <code>instance-attribute</code> <pre><code>max_memory_usage = max_memory_usage\n</code></pre> <code></code> timeout <code>instance-attribute</code> <pre><code>timeout = _validate_timeout(timeout)\n</code></pre> Functions <code></code> __init__ <pre><code>__init__(encoding='utf-8', logging_level='INFO', logging_format=None, timeout=None, max_file_size=None, max_memory_usage=None, custom_handlers=None, **kwargs)\n</code></pre> Source code in <code>textxtract/core/config.py</code> <pre><code>def __init__(\n    self,\n    encoding: str = \"utf-8\",\n    logging_level: str = \"INFO\",\n    logging_format: Optional[str] = None,\n    timeout: Optional[float] = None,\n    max_file_size: Optional[int] = None,\n    max_memory_usage: Optional[int] = None,\n    custom_handlers: Optional[Dict[str, Callable]] = None,\n    **kwargs,\n):\n    # Validate and set basic options\n    self.encoding = self._validate_encoding(encoding)\n    self.logging_level = self._validate_logging_level(logging_level)\n    self.logging_format = (\n        logging_format or \"%(asctime)s %(levelname)s %(name)s: %(message)s\"\n    )\n    self.timeout = self._validate_timeout(timeout)\n    self.max_file_size = self._validate_max_file_size(max_file_size)\n    self.max_memory_usage = max_memory_usage\n    self.custom_handlers = custom_handlers or {}\n\n    # Load from environment variables\n    self._load_from_env()\n\n    # Store additional kwargs for handler-specific config\n    self.extra_config = kwargs\n</code></pre> <code></code> __repr__ <pre><code>__repr__()\n</code></pre> Source code in <code>textxtract/core/config.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f\"ExtractorConfig(encoding='{self.encoding}', logging_level='{self.logging_level}', timeout={self.timeout})\"\n</code></pre> <code></code> from_file <code>classmethod</code> <pre><code>from_file(config_path)\n</code></pre> <p>Load configuration from a file (JSON, YAML, or TOML).</p> Source code in <code>textxtract/core/config.py</code> <pre><code>@classmethod\ndef from_file(cls, config_path: Union[str, Path]) -&gt; \"ExtractorConfig\":\n    \"\"\"Load configuration from a file (JSON, YAML, or TOML).\"\"\"\n    config_path = Path(config_path)\n\n    if not config_path.exists():\n        raise FileNotFoundError(f\"Configuration file not found: {config_path}\")\n\n    content = config_path.read_text()\n\n    if config_path.suffix.lower() == \".json\":\n        import json\n\n        config_data = json.loads(content)\n    elif config_path.suffix.lower() in (\".yaml\", \".yml\"):\n        try:\n            import yaml\n\n            config_data = yaml.safe_load(content)\n        except ImportError:\n            raise ImportError(\"PyYAML is required to load YAML configuration files\")\n    elif config_path.suffix.lower() == \".toml\":\n        try:\n            import tomli\n\n            config_data = tomli.loads(content)\n        except ImportError:\n            raise ImportError(\"tomli is required to load TOML configuration files\")\n    else:\n        raise ValueError(\n            f\"Unsupported configuration file format: {config_path.suffix}\"\n        )\n\n    return cls(**config_data)\n</code></pre> <code></code> get_handler <pre><code>get_handler(extension)\n</code></pre> <p>Retrieve a handler for a given file extension.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def get_handler(self, extension: str) -&gt; Optional[Callable]:\n    \"\"\"Retrieve a handler for a given file extension.\"\"\"\n    return self.custom_handlers.get(extension.lower())\n</code></pre> <code></code> get_handler_config <pre><code>get_handler_config(handler_name)\n</code></pre> <p>Get configuration specific to a handler.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def get_handler_config(self, handler_name: str) -&gt; Dict[str, Any]:\n    \"\"\"Get configuration specific to a handler.\"\"\"\n    base_config = {\n        \"encoding\": self.encoding,\n        \"timeout\": self.timeout,\n        \"max_file_size\": self.max_file_size,\n        \"max_memory_usage\": self.max_memory_usage,\n    }\n\n    # Add handler-specific config\n    handler_config_key = f\"{handler_name.lower()}_config\"\n    if handler_config_key in self.extra_config:\n        base_config.update(self.extra_config[handler_config_key])\n\n    return base_config\n</code></pre> <code></code> register_handler <pre><code>register_handler(extension, handler)\n</code></pre> <p>Register a custom file type handler.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def register_handler(self, extension: str, handler: Callable):\n    \"\"\"Register a custom file type handler.\"\"\"\n    if not extension.startswith(\".\"):\n        extension = f\".{extension}\"\n    self.custom_handlers[extension.lower()] = handler\n</code></pre> <code></code> to_dict <pre><code>to_dict()\n</code></pre> <p>Convert configuration to dictionary.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert configuration to dictionary.\"\"\"\n    return {\n        \"encoding\": self.encoding,\n        \"logging_level\": self.logging_level,\n        \"logging_format\": self.logging_format,\n        \"timeout\": self.timeout,\n        \"max_file_size\": self.max_file_size,\n        \"max_memory_usage\": self.max_memory_usage,\n        \"custom_handlers\": {k: str(v) for k, v in self.custom_handlers.items()},\n        **self.extra_config,\n    }\n</code></pre>"},{"location":"reference/__init__/#textxtract.core.exceptions","title":"exceptions","text":"<p>Custom exceptions for textxtract package.</p> <p>Classes:</p> Name Description <code>ExtractionError</code> <p>Raised when a general extraction error occurs.</p> <code>ExtractionTimeoutError</code> <p>Raised when extraction exceeds the allowed timeout.</p> <code>FileTypeNotSupportedError</code> <p>Raised when the file type is not supported.</p> <code>InvalidFileError</code> <p>Raised when the file is invalid or unsupported.</p>"},{"location":"reference/__init__/#textxtract.core.exceptions-classes","title":"Classes","text":"ExtractionError <p>               Bases: <code>Exception</code></p> <p>Raised when a general extraction error occurs.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class ExtractionError(Exception):\n    \"\"\"Raised when a general extraction error occurs.\"\"\"\n</code></pre> <code></code> ExtractionTimeoutError <p>               Bases: <code>ExtractionError</code></p> <p>Raised when extraction exceeds the allowed timeout.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class ExtractionTimeoutError(ExtractionError):\n    \"\"\"Raised when extraction exceeds the allowed timeout.\"\"\"\n</code></pre> <code></code> FileTypeNotSupportedError <p>               Bases: <code>ExtractionError</code></p> <p>Raised when the file type is not supported.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class FileTypeNotSupportedError(ExtractionError):\n    \"\"\"Raised when the file type is not supported.\"\"\"\n</code></pre> <code></code> InvalidFileError <p>               Bases: <code>ExtractionError</code></p> <p>Raised when the file is invalid or unsupported.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class InvalidFileError(ExtractionError):\n    \"\"\"Raised when the file is invalid or unsupported.\"\"\"\n</code></pre>"},{"location":"reference/__init__/#textxtract.core.logging_config","title":"logging_config","text":"<p>Logging configuration for textxtract package.</p> <p>Functions:</p> Name Description <code>setup_logging</code> <p>Configure logging for the package.</p>"},{"location":"reference/__init__/#textxtract.core.logging_config-functions","title":"Functions","text":"setup_logging <pre><code>setup_logging(level='INFO', fmt='%(asctime)s %(levelname)s %(name)s: %(message)s')\n</code></pre> <p>Configure logging for the package.</p> Source code in <code>textxtract/core/logging_config.py</code> <pre><code>def setup_logging(\n    level: str = \"INFO\", fmt: str = \"%(asctime)s %(levelname)s %(name)s: %(message)s\"\n):\n    \"\"\"Configure logging for the package.\"\"\"\n    logging.basicConfig(level=getattr(logging, level.upper(), logging.INFO), format=fmt)\n</code></pre>"},{"location":"reference/__init__/#textxtract.core.registry","title":"registry","text":"<p>Handler registry for centralized handler management.</p> <p>Classes:</p> Name Description <code>HandlerRegistry</code> <p>Central registry for file type handlers with caching and lazy loading.</p> <p>Attributes:</p> Name Type Description <code>logger</code> <code>registry</code>"},{"location":"reference/__init__/#textxtract.core.registry-attributes","title":"Attributes","text":"logger <code>module-attribute</code> <pre><code>logger = getLogger('textxtract.registry')\n</code></pre> <code></code> registry <code>module-attribute</code> <pre><code>registry = HandlerRegistry()\n</code></pre>"},{"location":"reference/__init__/#textxtract.core.registry-classes","title":"Classes","text":"HandlerRegistry <p>Central registry for file type handlers with caching and lazy loading.</p> <p>Methods:</p> Name Description <code>__init__</code> <code>__new__</code> <code>get_handler</code> <p>Get handler instance for file extension with caching.</p> <code>get_supported_extensions</code> <p>Get list of all supported file extensions.</p> <code>is_supported</code> <p>Check if a file extension is supported.</p> <code>register_handler</code> <p>Register a custom handler for a file extension.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>class HandlerRegistry:\n    \"\"\"Central registry for file type handlers with caching and lazy loading.\"\"\"\n\n    _instance: Optional[\"HandlerRegistry\"] = None\n    _handlers: Dict[str, Type[FileTypeHandler]] = {}\n    _initialized = False\n\n    def __new__(cls) -&gt; \"HandlerRegistry\":\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n    def __init__(self):\n        if not self._initialized:\n            self._load_default_handlers()\n            self._initialized = True\n\n    def _load_default_handlers(self):\n        \"\"\"Load default handlers with lazy imports.\"\"\"\n        # Import handlers at runtime to support optional dependencies\n        try:\n            from textxtract.handlers.pdf import PDFHandler\n\n            self._handlers[\".pdf\"] = PDFHandler\n        except ImportError:\n            logger.debug(\"PDF handler not available - pymupdf not installed\")\n\n        try:\n            from textxtract.handlers.docx import DOCXHandler\n\n            self._handlers[\".docx\"] = DOCXHandler\n        except ImportError:\n            logger.debug(\"DOCX handler not available - python-docx not installed\")\n\n        try:\n            from textxtract.handlers.doc import DOCHandler\n\n            self._handlers[\".doc\"] = DOCHandler\n        except ImportError:\n            logger.debug(\"DOC handler not available - antiword not installed\")\n\n        # Always available handlers\n        from textxtract.handlers.txt import TXTHandler\n        from textxtract.handlers.zip import ZIPHandler\n\n        self._handlers[\".txt\"] = TXTHandler\n        self._handlers[\".text\"] = TXTHandler\n        self._handlers[\".zip\"] = ZIPHandler\n\n        # Optional handlers with graceful fallback\n        try:\n            from textxtract.handlers.md import MDHandler\n\n            self._handlers[\".md\"] = MDHandler\n        except ImportError:\n            logger.debug(\"MD handler not available - markdown not installed\")\n\n        try:\n            from textxtract.handlers.rtf import RTFHandler\n\n            self._handlers[\".rtf\"] = RTFHandler\n        except ImportError:\n            logger.debug(\"RTF handler not available - pyrtf-ng not installed\")\n\n        try:\n            from textxtract.handlers.html import HTMLHandler\n\n            self._handlers[\".html\"] = HTMLHandler\n            self._handlers[\".htm\"] = HTMLHandler\n        except ImportError:\n            logger.debug(\"HTML handler not available - beautifulsoup4 not installed\")\n\n        # Standard library handlers\n        from textxtract.handlers.csv import CSVHandler\n        from textxtract.handlers.json import JSONHandler\n\n        self._handlers[\".csv\"] = CSVHandler\n        self._handlers[\".json\"] = JSONHandler\n\n        try:\n            from textxtract.handlers.xml import XMLHandler\n\n            self._handlers[\".xml\"] = XMLHandler\n        except ImportError:\n            logger.debug(\"XML handler not available - lxml not installed\")\n\n    @lru_cache(maxsize=128)\n    def get_handler(self, extension: str) -&gt; FileTypeHandler:\n        \"\"\"Get handler instance for file extension with caching.\"\"\"\n        ext = extension.lower()\n        handler_cls = self._handlers.get(ext)\n\n        if not handler_cls:\n            available = list(self._handlers.keys())\n            raise FileTypeNotSupportedError(\n                f\"Unsupported file extension: {ext}. \"\n                f\"Supported extensions: {', '.join(available)}\"\n            )\n\n        # Create handler instance (handlers are lightweight and stateless)\n        return handler_cls()\n\n    def register_handler(self, extension: str, handler_cls: Type[FileTypeHandler]):\n        \"\"\"Register a custom handler for a file extension.\"\"\"\n        ext = extension.lower()\n        if not ext.startswith(\".\"):\n            ext = f\".{ext}\"\n\n        self._handlers[ext] = handler_cls\n        # Clear cache when new handlers are registered\n        self.get_handler.cache_clear()\n        logger.info(\n            \"Registered custom handler %s for extension %s\", handler_cls.__name__, ext\n        )\n\n    def get_supported_extensions(self) -&gt; List[str]:\n        \"\"\"Get list of all supported file extensions.\"\"\"\n        return list(self._handlers.keys())\n\n    def is_supported(self, extension: str) -&gt; bool:\n        \"\"\"Check if a file extension is supported.\"\"\"\n        return extension.lower() in self._handlers\n</code></pre> Functions <code></code> __init__ <pre><code>__init__()\n</code></pre> Source code in <code>textxtract/core/registry.py</code> <pre><code>def __init__(self):\n    if not self._initialized:\n        self._load_default_handlers()\n        self._initialized = True\n</code></pre> <code></code> __new__ <pre><code>__new__()\n</code></pre> Source code in <code>textxtract/core/registry.py</code> <pre><code>def __new__(cls) -&gt; \"HandlerRegistry\":\n    if cls._instance is None:\n        cls._instance = super().__new__(cls)\n    return cls._instance\n</code></pre> <code></code> get_handler <code>cached</code> <pre><code>get_handler(extension)\n</code></pre> <p>Get handler instance for file extension with caching.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>@lru_cache(maxsize=128)\ndef get_handler(self, extension: str) -&gt; FileTypeHandler:\n    \"\"\"Get handler instance for file extension with caching.\"\"\"\n    ext = extension.lower()\n    handler_cls = self._handlers.get(ext)\n\n    if not handler_cls:\n        available = list(self._handlers.keys())\n        raise FileTypeNotSupportedError(\n            f\"Unsupported file extension: {ext}. \"\n            f\"Supported extensions: {', '.join(available)}\"\n        )\n\n    # Create handler instance (handlers are lightweight and stateless)\n    return handler_cls()\n</code></pre> <code></code> get_supported_extensions <pre><code>get_supported_extensions()\n</code></pre> <p>Get list of all supported file extensions.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>def get_supported_extensions(self) -&gt; List[str]:\n    \"\"\"Get list of all supported file extensions.\"\"\"\n    return list(self._handlers.keys())\n</code></pre> <code></code> is_supported <pre><code>is_supported(extension)\n</code></pre> <p>Check if a file extension is supported.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>def is_supported(self, extension: str) -&gt; bool:\n    \"\"\"Check if a file extension is supported.\"\"\"\n    return extension.lower() in self._handlers\n</code></pre> <code></code> register_handler <pre><code>register_handler(extension, handler_cls)\n</code></pre> <p>Register a custom handler for a file extension.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>def register_handler(self, extension: str, handler_cls: Type[FileTypeHandler]):\n    \"\"\"Register a custom handler for a file extension.\"\"\"\n    ext = extension.lower()\n    if not ext.startswith(\".\"):\n        ext = f\".{ext}\"\n\n    self._handlers[ext] = handler_cls\n    # Clear cache when new handlers are registered\n    self.get_handler.cache_clear()\n    logger.info(\n        \"Registered custom handler %s for extension %s\", handler_cls.__name__, ext\n    )\n</code></pre>"},{"location":"reference/__init__/#textxtract.core.utils","title":"utils","text":"<p>Utility functions for textxtract package.</p> <p>Functions:</p> Name Description <code>create_temp_file</code> <p>Create a temporary file from bytes and return its path with security validation.</p> <code>get_file_info</code> <p>Get basic file information for logging and debugging.</p> <code>safe_unlink</code> <p>Safely delete a file if it exists, optionally logging errors.</p> <code>validate_file_extension</code> <p>Check if the file has an allowed extension.</p> <code>validate_file_size</code> <p>Validate file size doesn't exceed limits.</p> <code>validate_filename</code> <p>Validate filename for security issues.</p> <p>Attributes:</p> Name Type Description <code>DEFAULT_MAX_FILE_SIZE</code> <code>DEFAULT_MAX_TEMP_FILES</code>"},{"location":"reference/__init__/#textxtract.core.utils-attributes","title":"Attributes","text":"DEFAULT_MAX_FILE_SIZE <code>module-attribute</code> <pre><code>DEFAULT_MAX_FILE_SIZE = 100 * 1024 * 1024\n</code></pre> <code></code> DEFAULT_MAX_TEMP_FILES <code>module-attribute</code> <pre><code>DEFAULT_MAX_TEMP_FILES = 1000\n</code></pre>"},{"location":"reference/__init__/#textxtract.core.utils-functions","title":"Functions","text":"create_temp_file <pre><code>create_temp_file(file_bytes, filename, max_size=None)\n</code></pre> <p>Create a temporary file from bytes and return its path with security validation.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def create_temp_file(\n    file_bytes: bytes, filename: str, max_size: Optional[int] = None\n) -&gt; Path:\n    \"\"\"Create a temporary file from bytes and return its path with security validation.\"\"\"\n    validate_filename(filename)\n    validate_file_size(file_bytes, max_size)\n\n    file_ext = Path(filename).suffix\n    with tempfile.NamedTemporaryFile(delete=False, suffix=file_ext) as temp_file:\n        temp_file.write(file_bytes)\n        temp_path = Path(temp_file.name)\n\n    # Ensure file was created successfully\n    if not temp_path.exists():\n        raise RuntimeError(\"Failed to create temporary file\")\n\n    return temp_path\n</code></pre> <code></code> get_file_info <pre><code>get_file_info(file_bytes, filename)\n</code></pre> <p>Get basic file information for logging and debugging.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def get_file_info(file_bytes: bytes, filename: str) -&gt; dict:\n    \"\"\"Get basic file information for logging and debugging.\"\"\"\n    return {\n        \"filename\": filename,\n        \"size_bytes\": len(file_bytes),\n        \"size_mb\": round(len(file_bytes) / (1024 * 1024), 2),\n        \"extension\": Path(filename).suffix.lower(),\n    }\n</code></pre> <code></code> safe_unlink <pre><code>safe_unlink(path, log_errors=True)\n</code></pre> <p>Safely delete a file if it exists, optionally logging errors.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def safe_unlink(path: Path, log_errors: bool = True) -&gt; bool:\n    \"\"\"Safely delete a file if it exists, optionally logging errors.\"\"\"\n    try:\n        if path.exists():\n            path.unlink()\n            return True\n        return False\n    except Exception as e:\n        if log_errors:\n            import logging\n\n            logger = logging.getLogger(\"textxtract.utils\")\n            logger.warning(\"Failed to delete temporary file %s: %s\", path, e)\n        return False\n</code></pre> <code></code> validate_file_extension <pre><code>validate_file_extension(filename, allowed_extensions)\n</code></pre> <p>Check if the file has an allowed extension.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def validate_file_extension(filename: str, allowed_extensions: list[str]) -&gt; bool:\n    \"\"\"Check if the file has an allowed extension.\"\"\"\n    return Path(filename).suffix.lower() in allowed_extensions\n</code></pre> <code></code> validate_file_size <pre><code>validate_file_size(file_bytes, max_size=None)\n</code></pre> <p>Validate file size doesn't exceed limits.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def validate_file_size(file_bytes: bytes, max_size: Optional[int] = None) -&gt; None:\n    \"\"\"Validate file size doesn't exceed limits.\"\"\"\n    max_size = max_size or DEFAULT_MAX_FILE_SIZE\n    if len(file_bytes) == 0:\n        raise ValueError(\"File is empty (0 bytes)\")\n    if len(file_bytes) &gt; max_size:\n        raise ValueError(\n            f\"File size ({len(file_bytes):,} bytes) exceeds maximum \"\n            f\"allowed size ({max_size:,} bytes)\"\n        )\n</code></pre> <code></code> validate_filename <pre><code>validate_filename(filename)\n</code></pre> <p>Validate filename for security issues.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def validate_filename(filename: str) -&gt; None:\n    \"\"\"Validate filename for security issues.\"\"\"\n    if not filename:\n        raise ValueError(\"Filename cannot be empty\")\n\n    # Check for null bytes\n    if \"\\x00\" in filename:\n        raise ValueError(f\"Invalid filename: contains null byte\")\n\n    # Check for path traversal attempts\n    if \"..\" in filename:\n        raise ValueError(f\"Invalid filename: path traversal detected\")\n\n    # Check for absolute paths (both Unix and Windows)\n    if filename.startswith(\"/\") or (len(filename) &gt; 1 and filename[1] == \":\"):\n        raise ValueError(f\"Invalid filename: absolute path not allowed\")\n\n    # Check for Windows path separators in suspicious contexts\n    if \"\\\\\" in filename and (\"..\" in filename or filename.count(\"\\\\\") &gt; 2):\n        raise ValueError(f\"Invalid filename: suspicious path structure\")\n\n    # Check filename length\n    if len(filename) &gt; 255:\n        raise ValueError(\"Filename too long\")\n</code></pre>"},{"location":"reference/__init__/#textxtract.handlers","title":"handlers","text":"<p>File type-specific handlers package.</p> <p>Modules:</p> Name Description <code>csv</code> <p>CSV file handler for text extraction.</p> <code>doc</code> <p>DOC file handler for text extraction.</p> <code>docx</code> <p>DOCX file handler for text extraction.</p> <code>html</code> <p>HTML file handler for text extraction.</p> <code>json</code> <p>JSON file handler for text extraction.</p> <code>md</code> <p>Markdown (.md) file handler for text extraction.</p> <code>pdf</code> <p>PDF file handler for text extraction.</p> <code>rtf</code> <p>RTF file handler for text extraction.</p> <code>txt</code> <p>TXT file handler for text extraction.</p> <code>xml</code> <p>XML file handler for text extraction.</p> <code>zip</code> <p>ZIP file handler for text extraction.</p>"},{"location":"reference/__init__/#textxtract.handlers-modules","title":"Modules","text":""},{"location":"reference/__init__/#textxtract.handlers.csv","title":"csv","text":"<p>CSV file handler for text extraction.</p> <p>Classes:</p> Name Description <code>CSVHandler</code> <p>Handler for extracting text from CSV files.</p>"},{"location":"reference/__init__/#textxtract.handlers.csv-classes","title":"Classes","text":"CSVHandler <p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from CSV files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/csv.py</code> <pre><code>class CSVHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from CSV files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            encoding = (config or {}).get(\"encoding\", \"utf-8\")\n            with open(file_path, \"r\", encoding=encoding, newline=\"\") as f:\n                reader = csv.reader(f)\n                return \"\\n\".join([\", \".join(row) for row in reader])\n        except Exception as e:\n            raise ExtractionError(f\"CSV extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre> Functions <code></code> extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/csv.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        with open(file_path, \"r\", encoding=encoding, newline=\"\") as f:\n            reader = csv.reader(f)\n            return \"\\n\".join([\", \".join(row) for row in reader])\n    except Exception as e:\n        raise ExtractionError(f\"CSV extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/csv.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/__init__/#textxtract.handlers.doc","title":"doc","text":"<p>DOC file handler for text extraction.</p> <p>Classes:</p> Name Description <code>DOCHandler</code> <p>Handler for extracting text from DOC files with fallback options.</p>"},{"location":"reference/__init__/#textxtract.handlers.doc-classes","title":"Classes","text":"DOCHandler <p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from DOC files with fallback options.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/doc.py</code> <pre><code>class DOCHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from DOC files with fallback options.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        # Try antiword first\n        try:\n            return self._extract_with_antiword(file_path)\n        except FileNotFoundError:\n            # Try alternative methods if antiword is not available\n            return self._extract_with_fallback(file_path, config)\n        except Exception as e:\n            if isinstance(e, ExtractionError):\n                raise\n            raise ExtractionError(f\"DOC extraction failed: {e}\")\n\n    def _extract_with_antiword(self, file_path: Path) -&gt; str:\n        \"\"\"Extract text using antiword command.\"\"\"\n        import subprocess\n\n        try:\n            result = subprocess.run(\n                [\"antiword\", str(file_path)],\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n                check=True,\n                timeout=30,  # Add timeout\n            )\n            content = result.stdout.decode(\"utf-8\").strip()\n            if not content:\n                raise ExtractionError(\"antiword returned empty content\")\n            return content\n        except subprocess.TimeoutExpired:\n            raise ExtractionError(\"antiword extraction timed out\")\n        except subprocess.CalledProcessError as e:\n            error_msg = e.stderr.decode() if e.stderr else str(e)\n            raise ExtractionError(f\"antiword extraction failed: {error_msg}\")\n\n    def _extract_with_fallback(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"Fallback extraction methods when antiword is not available.\"\"\"\n\n        # Try python-docx (works for some DOC files)\n        try:\n            from docx import Document\n\n            doc = Document(file_path)\n            text = \"\\n\".join(paragraph.text for paragraph in doc.paragraphs)\n            if text.strip():\n                return text\n        except Exception:\n            pass  # Silent fail, try next method\n\n        # Try reading as binary and looking for text patterns\n        try:\n            with open(file_path, \"rb\") as f:\n                content = f.read()\n\n            # Simple heuristic: look for readable text in the binary\n            text_content = []\n            current_text = []\n\n            for byte in content:\n                if 32 &lt;= byte &lt;= 126:  # Printable ASCII\n                    current_text.append(chr(byte))\n                else:\n                    if len(current_text) &gt; 3:  # Minimum word length\n                        text_content.append(\"\".join(current_text))\n                    current_text = []\n\n            if current_text and len(current_text) &gt; 3:\n                text_content.append(\"\".join(current_text))\n\n            result = \" \".join(text_content)\n            if result.strip():\n                return f\"[Extracted using fallback method - may contain formatting artifacts]\\n{result}\"\n\n        except Exception:\n            pass\n\n        # If all methods fail\n        raise ExtractionError(\n            \"DOC extraction failed. Please install 'antiword' command for better DOC support: \"\n            \"sudo apt-get install antiword (Ubuntu/Debian) or brew install antiword (macOS)\"\n        )\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre> Functions <code></code> extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/doc.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    # Try antiword first\n    try:\n        return self._extract_with_antiword(file_path)\n    except FileNotFoundError:\n        # Try alternative methods if antiword is not available\n        return self._extract_with_fallback(file_path, config)\n    except Exception as e:\n        if isinstance(e, ExtractionError):\n            raise\n        raise ExtractionError(f\"DOC extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/doc.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/__init__/#textxtract.handlers.docx","title":"docx","text":"<p>DOCX file handler for text extraction.</p> <p>Classes:</p> Name Description <code>DOCXHandler</code> <p>Handler for extracting text from DOCX files.</p>"},{"location":"reference/__init__/#textxtract.handlers.docx-classes","title":"Classes","text":"DOCXHandler <p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from DOCX files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/docx.py</code> <pre><code>class DOCXHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from DOCX files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            from docx import Document\n\n            doc = Document(file_path)\n            return \"\\n\".join(paragraph.text for paragraph in doc.paragraphs)\n        except Exception as e:\n            raise ExtractionError(f\"DOCX extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre> Functions <code></code> extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/docx.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        from docx import Document\n\n        doc = Document(file_path)\n        return \"\\n\".join(paragraph.text for paragraph in doc.paragraphs)\n    except Exception as e:\n        raise ExtractionError(f\"DOCX extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/docx.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/__init__/#textxtract.handlers.html","title":"html","text":"<p>HTML file handler for text extraction.</p> <p>Classes:</p> Name Description <code>HTMLHandler</code> <p>Handler for extracting text from HTML files.</p>"},{"location":"reference/__init__/#textxtract.handlers.html-classes","title":"Classes","text":"HTMLHandler <p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from HTML files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/html.py</code> <pre><code>class HTMLHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from HTML files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                from bs4 import BeautifulSoup\n            except ImportError:\n                raise ExtractionError(\n                    \"beautifulsoup4 package is not installed. Install with 'pip install text-extractor[html]'\"\n                )\n            text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n            soup = BeautifulSoup(text, \"html.parser\")\n            return soup.get_text()\n        except Exception as e:\n            raise ExtractionError(f\"HTML extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre> Functions <code></code> extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/html.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            from bs4 import BeautifulSoup\n        except ImportError:\n            raise ExtractionError(\n                \"beautifulsoup4 package is not installed. Install with 'pip install text-extractor[html]'\"\n            )\n        text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n        soup = BeautifulSoup(text, \"html.parser\")\n        return soup.get_text()\n    except Exception as e:\n        raise ExtractionError(f\"HTML extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/html.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/__init__/#textxtract.handlers.json","title":"json","text":"<p>JSON file handler for text extraction.</p> <p>Classes:</p> Name Description <code>JSONHandler</code> <p>Handler for extracting text from JSON files.</p>"},{"location":"reference/__init__/#textxtract.handlers.json-classes","title":"Classes","text":"JSONHandler <p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from JSON files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/json.py</code> <pre><code>class JSONHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from JSON files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            encoding = (config or {}).get(\"encoding\", \"utf-8\")\n            with open(file_path, \"r\", encoding=encoding) as f:\n                data = json.load(f)\n                # Pretty print JSON as text\n                return json.dumps(data, indent=2, ensure_ascii=False)\n        except Exception as e:\n            raise ExtractionError(f\"JSON extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre> Functions <code></code> extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/json.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        with open(file_path, \"r\", encoding=encoding) as f:\n            data = json.load(f)\n            # Pretty print JSON as text\n            return json.dumps(data, indent=2, ensure_ascii=False)\n    except Exception as e:\n        raise ExtractionError(f\"JSON extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/json.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/__init__/#textxtract.handlers.md","title":"md","text":"<p>Markdown (.md) file handler for text extraction.</p> <p>Classes:</p> Name Description <code>MDHandler</code> <p>Handler for extracting text from Markdown files.</p>"},{"location":"reference/__init__/#textxtract.handlers.md-classes","title":"Classes","text":"MDHandler <p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from Markdown files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/md.py</code> <pre><code>class MDHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from Markdown files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                import markdown\n            except ImportError:\n                raise ExtractionError(\n                    \"markdown package is not installed. Install with 'pip install text-extractor[md]'\"\n                )\n            text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n            # Optionally, convert markdown to plain text (strip HTML)\n            html = markdown.markdown(text)\n            # Remove HTML tags (best effort, fallback to raw text)\n            try:\n                from bs4 import BeautifulSoup\n\n                soup = BeautifulSoup(html, \"html.parser\")\n                return soup.get_text()\n            except ImportError:\n                return text\n        except Exception as e:\n            raise ExtractionError(f\"MD extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre> Functions <code></code> extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/md.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            import markdown\n        except ImportError:\n            raise ExtractionError(\n                \"markdown package is not installed. Install with 'pip install text-extractor[md]'\"\n            )\n        text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n        # Optionally, convert markdown to plain text (strip HTML)\n        html = markdown.markdown(text)\n        # Remove HTML tags (best effort, fallback to raw text)\n        try:\n            from bs4 import BeautifulSoup\n\n            soup = BeautifulSoup(html, \"html.parser\")\n            return soup.get_text()\n        except ImportError:\n            return text\n    except Exception as e:\n        raise ExtractionError(f\"MD extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/md.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/__init__/#textxtract.handlers.pdf","title":"pdf","text":"<p>PDF file handler for text extraction.</p> <p>Classes:</p> Name Description <code>PDFHandler</code> <p>Handler for extracting text from PDF files with improved error handling.</p>"},{"location":"reference/__init__/#textxtract.handlers.pdf-classes","title":"Classes","text":"PDFHandler <p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from PDF files with improved error handling.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/pdf.py</code> <pre><code>class PDFHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from PDF files with improved error handling.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                import fitz  # PyMuPDF\n            except ImportError:\n                raise ExtractionError(\n                    \"PyMuPDF package is not installed. Install with 'pip install text-extractor[pdf]'\"\n                )\n\n            doc = fitz.open(file_path)\n            extracted_text = []\n            empty_pages = 0\n\n            for page_num, page in enumerate(doc):\n                page_text = page.get_text(\"text\").strip()\n                if not page_text:\n                    empty_pages += 1\n                    # Try OCR-like text extraction for images\n                    page_text = page.get_text(\"dict\")  # Get structured text\n                    if page_text and \"blocks\" in page_text:\n                        # Check if page has images but no text\n                        has_images = any(\n                            block.get(\"type\") == 1\n                            for block in page_text.get(\"blocks\", [])\n                        )\n                        if has_images:\n                            extracted_text.append(\n                                f\"[Page {page_num + 1}: Contains images but no extractable text]\"\n                            )\n                        else:\n                            extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n                    else:\n                        extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n                else:\n                    extracted_text.append(page_text)\n\n            doc.close()\n\n            # Only raise error if ALL pages are empty and there's no content at all\n            if not any(\n                text.strip() and not text.startswith(\"[Page\") for text in extracted_text\n            ):\n                if empty_pages == len(extracted_text):\n                    raise InvalidFileError(\n                        f\"PDF contains {empty_pages} empty pages with no extractable text. \"\n                        \"This may be a scanned PDF that requires OCR.\"\n                    )\n\n            result = \"\\n\".join(extracted_text)\n            return result\n\n        except fitz.FileDataError as e:\n            raise InvalidFileError(f\"Invalid or corrupted PDF file: {e}\")\n        except fitz.EmptyFileError:\n            raise InvalidFileError(\"PDF file is empty\")\n        except Exception as e:\n            if isinstance(e, (ExtractionError, InvalidFileError)):\n                raise\n            raise ExtractionError(f\"PDF extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre> Functions <code></code> extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/pdf.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            import fitz  # PyMuPDF\n        except ImportError:\n            raise ExtractionError(\n                \"PyMuPDF package is not installed. Install with 'pip install text-extractor[pdf]'\"\n            )\n\n        doc = fitz.open(file_path)\n        extracted_text = []\n        empty_pages = 0\n\n        for page_num, page in enumerate(doc):\n            page_text = page.get_text(\"text\").strip()\n            if not page_text:\n                empty_pages += 1\n                # Try OCR-like text extraction for images\n                page_text = page.get_text(\"dict\")  # Get structured text\n                if page_text and \"blocks\" in page_text:\n                    # Check if page has images but no text\n                    has_images = any(\n                        block.get(\"type\") == 1\n                        for block in page_text.get(\"blocks\", [])\n                    )\n                    if has_images:\n                        extracted_text.append(\n                            f\"[Page {page_num + 1}: Contains images but no extractable text]\"\n                        )\n                    else:\n                        extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n                else:\n                    extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n            else:\n                extracted_text.append(page_text)\n\n        doc.close()\n\n        # Only raise error if ALL pages are empty and there's no content at all\n        if not any(\n            text.strip() and not text.startswith(\"[Page\") for text in extracted_text\n        ):\n            if empty_pages == len(extracted_text):\n                raise InvalidFileError(\n                    f\"PDF contains {empty_pages} empty pages with no extractable text. \"\n                    \"This may be a scanned PDF that requires OCR.\"\n                )\n\n        result = \"\\n\".join(extracted_text)\n        return result\n\n    except fitz.FileDataError as e:\n        raise InvalidFileError(f\"Invalid or corrupted PDF file: {e}\")\n    except fitz.EmptyFileError:\n        raise InvalidFileError(\"PDF file is empty\")\n    except Exception as e:\n        if isinstance(e, (ExtractionError, InvalidFileError)):\n            raise\n        raise ExtractionError(f\"PDF extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/pdf.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/__init__/#textxtract.handlers.rtf","title":"rtf","text":"<p>RTF file handler for text extraction.</p> <p>Classes:</p> Name Description <code>RTFHandler</code> <p>Handler for extracting text from RTF files.</p>"},{"location":"reference/__init__/#textxtract.handlers.rtf-classes","title":"Classes","text":"RTFHandler <p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from RTF files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/rtf.py</code> <pre><code>class RTFHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from RTF files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                from striprtf.striprtf import rtf_to_text\n            except ImportError:\n                raise ExtractionError(\n                    \"striprtf package is not installed. Install with 'pip install text-extractor[rtf]'\"\n                )\n\n            with open(\n                file_path, \"r\", encoding=(config or {}).get(\"encoding\", \"utf-8\")\n            ) as f:\n                rtf_content = f.read()\n                return rtf_to_text(rtf_content)\n        except Exception as e:\n            raise ExtractionError(f\"RTF extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre> Functions <code></code> extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/rtf.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            from striprtf.striprtf import rtf_to_text\n        except ImportError:\n            raise ExtractionError(\n                \"striprtf package is not installed. Install with 'pip install text-extractor[rtf]'\"\n            )\n\n        with open(\n            file_path, \"r\", encoding=(config or {}).get(\"encoding\", \"utf-8\")\n        ) as f:\n            rtf_content = f.read()\n            return rtf_to_text(rtf_content)\n    except Exception as e:\n        raise ExtractionError(f\"RTF extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/rtf.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/__init__/#textxtract.handlers.txt","title":"txt","text":"<p>TXT file handler for text extraction.</p> <p>Classes:</p> Name Description <code>TXTHandler</code> <p>Handler for extracting text from TXT files.</p>"},{"location":"reference/__init__/#textxtract.handlers.txt-classes","title":"Classes","text":"TXTHandler <p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from TXT files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/txt.py</code> <pre><code>class TXTHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from TXT files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        try:\n            return file_path.read_text(encoding=encoding)\n        except Exception as e:\n            raise ExtractionError(f\"TXT extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre> Functions <code></code> extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/txt.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    encoding = (config or {}).get(\"encoding\", \"utf-8\")\n    try:\n        return file_path.read_text(encoding=encoding)\n    except Exception as e:\n        raise ExtractionError(f\"TXT extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/txt.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/__init__/#textxtract.handlers.xml","title":"xml","text":"<p>XML file handler for text extraction.</p> <p>Classes:</p> Name Description <code>XMLHandler</code> <p>Handler for extracting text from XML files.</p>"},{"location":"reference/__init__/#textxtract.handlers.xml-classes","title":"Classes","text":"XMLHandler <p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from XML files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/xml.py</code> <pre><code>class XMLHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from XML files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                from lxml import etree\n            except ImportError:\n                raise ExtractionError(\n                    \"lxml package is not installed. Install with 'pip install text-extractor[xml]'\"\n                )\n            encoding = (config or {}).get(\"encoding\", \"utf-8\")\n            with open(file_path, \"r\", encoding=encoding) as f:\n                tree = etree.parse(f)\n                return \" \".join(tree.xpath(\"//text()\"))\n        except Exception as e:\n            raise ExtractionError(f\"XML extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre> Functions <code></code> extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/xml.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            from lxml import etree\n        except ImportError:\n            raise ExtractionError(\n                \"lxml package is not installed. Install with 'pip install text-extractor[xml]'\"\n            )\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        with open(file_path, \"r\", encoding=encoding) as f:\n            tree = etree.parse(f)\n            return \" \".join(tree.xpath(\"//text()\"))\n    except Exception as e:\n        raise ExtractionError(f\"XML extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/xml.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/__init__/#textxtract.handlers.zip","title":"zip","text":"<p>ZIP file handler for text extraction.</p> <p>Classes:</p> Name Description <code>ZIPHandler</code> <p>Handler for extracting text from ZIP archives with security checks.</p> <p>Attributes:</p> Name Type Description <code>logger</code>"},{"location":"reference/__init__/#textxtract.handlers.zip-attributes","title":"Attributes","text":"logger <code>module-attribute</code> <pre><code>logger = getLogger('textxtract.handlers.zip')\n</code></pre>"},{"location":"reference/__init__/#textxtract.handlers.zip-classes","title":"Classes","text":"ZIPHandler <p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from ZIP archives with security checks.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> <p>Attributes:</p> Name Type Description <code>MAX_EXTRACT_SIZE</code> <code>MAX_FILES</code> Source code in <code>textxtract/handlers/zip.py</code> <pre><code>class ZIPHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from ZIP archives with security checks.\"\"\"\n\n    MAX_EXTRACT_SIZE = 1024 * 1024 * 1024  # 1GB total\n    MAX_FILES = 1000  # Maximum files to process\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; List[str]:\n        extracted_texts = []\n        total_size = 0\n        file_count = 0\n\n        try:\n            with zipfile.ZipFile(file_path, \"r\") as zip_file:\n                for file_info in zip_file.infolist():\n                    if file_info.is_dir():\n                        continue\n\n                    # Security checks\n                    if file_count &gt;= self.MAX_FILES:\n                        logger.warning(\"Maximum file limit reached in ZIP archive\")\n                        break\n\n                    # Check for path traversal\n                    if self._is_unsafe_path(file_info.filename):\n                        logger.warning(\"Skipping unsafe path: %s\", file_info.filename)\n                        continue\n\n                    # Check file size\n                    if file_info.file_size &gt; 100 * 1024 * 1024:  # 100MB per file\n                        logger.warning(\n                            \"Skipping large file: %s (%d bytes)\",\n                            file_info.filename,\n                            file_info.file_size,\n                        )\n                        continue\n\n                    total_size += file_info.file_size\n                    if total_size &gt; self.MAX_EXTRACT_SIZE:\n                        logger.warning(\"Total extract size limit reached\")\n                        break\n\n                    file_count += 1\n\n                    try:\n                        with zip_file.open(file_info.filename) as source_file:\n                            file_bytes = source_file.read()\n                            suffix = Path(file_info.filename).suffix.lower()\n\n                            # Use registry to get handler\n                            from textxtract.core.registry import registry\n\n                            if registry.is_supported(suffix):\n                                handler = registry.get_handler(suffix)\n                                with tempfile.NamedTemporaryFile(\n                                    delete=False, suffix=suffix\n                                ) as temp_file:\n                                    temp_file.write(file_bytes)\n                                    temp_path = Path(temp_file.name)\n                                try:\n                                    text = handler.extract(temp_path, config)\n                                    extracted_texts.append(text)\n                                    logger.debug(\n                                        \"Extracted text from %s\", file_info.filename\n                                    )\n                                except Exception as e:\n                                    logger.warning(\n                                        \"Failed to extract text from %s: %s\",\n                                        file_info.filename,\n                                        e,\n                                    )\n                                finally:\n                                    temp_path.unlink(missing_ok=True)\n                            else:\n                                logger.debug(\n                                    \"Unsupported file type: %s\", file_info.filename\n                                )\n\n                    except Exception as e:\n                        logger.warning(\n                            \"Error processing file %s: %s\", file_info.filename, e\n                        )\n                        continue\n\n            logger.info(\n                \"Extracted text from %d files in ZIP archive\", len(extracted_texts)\n            )\n            return extracted_texts\n\n        except Exception as e:\n            raise ExtractionError(f\"ZIP extraction failed: {e}\")\n\n    def _is_unsafe_path(self, path: str) -&gt; bool:\n        \"\"\"Check if a path contains unsafe elements.\"\"\"\n        # Normalize path separators\n        normalized = path.replace(\"\\\\\", \"/\")\n\n        # Check for path traversal attempts\n        if \"..\" in normalized or normalized.startswith(\"/\"):\n            return True\n\n        # Check for absolute paths on Windows\n        if len(normalized) &gt; 1 and normalized[1] == \":\":\n            return True\n\n        return False\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; List[str]:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre> Attributes <code></code> MAX_EXTRACT_SIZE <code>class-attribute</code> <code>instance-attribute</code> <pre><code>MAX_EXTRACT_SIZE = 1024 * 1024 * 1024\n</code></pre> <code></code> MAX_FILES <code>class-attribute</code> <code>instance-attribute</code> <pre><code>MAX_FILES = 1000\n</code></pre> Functions <code></code> extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/zip.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; List[str]:\n    extracted_texts = []\n    total_size = 0\n    file_count = 0\n\n    try:\n        with zipfile.ZipFile(file_path, \"r\") as zip_file:\n            for file_info in zip_file.infolist():\n                if file_info.is_dir():\n                    continue\n\n                # Security checks\n                if file_count &gt;= self.MAX_FILES:\n                    logger.warning(\"Maximum file limit reached in ZIP archive\")\n                    break\n\n                # Check for path traversal\n                if self._is_unsafe_path(file_info.filename):\n                    logger.warning(\"Skipping unsafe path: %s\", file_info.filename)\n                    continue\n\n                # Check file size\n                if file_info.file_size &gt; 100 * 1024 * 1024:  # 100MB per file\n                    logger.warning(\n                        \"Skipping large file: %s (%d bytes)\",\n                        file_info.filename,\n                        file_info.file_size,\n                    )\n                    continue\n\n                total_size += file_info.file_size\n                if total_size &gt; self.MAX_EXTRACT_SIZE:\n                    logger.warning(\"Total extract size limit reached\")\n                    break\n\n                file_count += 1\n\n                try:\n                    with zip_file.open(file_info.filename) as source_file:\n                        file_bytes = source_file.read()\n                        suffix = Path(file_info.filename).suffix.lower()\n\n                        # Use registry to get handler\n                        from textxtract.core.registry import registry\n\n                        if registry.is_supported(suffix):\n                            handler = registry.get_handler(suffix)\n                            with tempfile.NamedTemporaryFile(\n                                delete=False, suffix=suffix\n                            ) as temp_file:\n                                temp_file.write(file_bytes)\n                                temp_path = Path(temp_file.name)\n                            try:\n                                text = handler.extract(temp_path, config)\n                                extracted_texts.append(text)\n                                logger.debug(\n                                    \"Extracted text from %s\", file_info.filename\n                                )\n                            except Exception as e:\n                                logger.warning(\n                                    \"Failed to extract text from %s: %s\",\n                                    file_info.filename,\n                                    e,\n                                )\n                            finally:\n                                temp_path.unlink(missing_ok=True)\n                        else:\n                            logger.debug(\n                                \"Unsupported file type: %s\", file_info.filename\n                            )\n\n                except Exception as e:\n                    logger.warning(\n                        \"Error processing file %s: %s\", file_info.filename, e\n                    )\n                    continue\n\n        logger.info(\n            \"Extracted text from %d files in ZIP archive\", len(extracted_texts)\n        )\n        return extracted_texts\n\n    except Exception as e:\n        raise ExtractionError(f\"ZIP extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/zip.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; List[str]:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/__init__/#textxtract.sync","title":"sync","text":"<p>Synchronous extraction logic package.</p> <p>Modules:</p> Name Description <code>extractor</code> <p>Synchronous text extraction logic.</p>"},{"location":"reference/__init__/#textxtract.sync-modules","title":"Modules","text":""},{"location":"reference/__init__/#textxtract.sync.extractor","title":"extractor","text":"<p>Synchronous text extraction logic.</p> <p>Classes:</p> Name Description <code>SyncTextExtractor</code> <p>Synchronous text extractor with improved error handling and resource management.</p> <p>Attributes:</p> Name Type Description <code>logger</code>"},{"location":"reference/__init__/#textxtract.sync.extractor-attributes","title":"Attributes","text":"logger <code>module-attribute</code> <pre><code>logger = getLogger('textxtract.sync')\n</code></pre>"},{"location":"reference/__init__/#textxtract.sync.extractor-classes","title":"Classes","text":"SyncTextExtractor <p>               Bases: <code>TextExtractor</code></p> <p>Synchronous text extractor with improved error handling and resource management.</p> <p>Provides synchronous text extraction from various file types. Logs debug and info level messages for tracing and diagnostics. Supports context manager protocol for proper cleanup.</p> <p>Methods:</p> Name Description <code>__enter__</code> <p>Context manager entry.</p> <code>__exit__</code> <p>Context manager exit.</p> <code>__init__</code> <code>extract</code> <p>Extract text synchronously from file bytes.</p> <code>extract_async</code> <p>Async interface for compatibility; delegates to sync extract.</p> <p>Attributes:</p> Name Type Description <code>config</code> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>class SyncTextExtractor(TextExtractor):\n    \"\"\"\n    Synchronous text extractor with improved error handling and resource management.\n\n    Provides synchronous text extraction from various file types.\n    Logs debug and info level messages for tracing and diagnostics.\n    Supports context manager protocol for proper cleanup.\n    \"\"\"\n\n    def __init__(self, config: Optional[ExtractorConfig] = None):\n        self.config = config or ExtractorConfig()\n        logger.debug(\n            \"SyncTextExtractor initialized with config: %s\", self.config.__dict__\n        )\n\n    def extract(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"\n        Extract text synchronously from file bytes.\n\n        Args:\n            file_bytes (bytes): The file content as bytes.\n            filename (str): The name of the file (used for extension).\n            config (Optional[dict]): Optional configuration overrides.\n\n        Returns:\n            str: Extracted text.\n\n        Raises:\n            FileTypeNotSupportedError: If the file extension is not supported.\n            ExtractionError: If extraction fails.\n            InvalidFileError: If the file is invalid or corrupted.\n        \"\"\"\n        file_info = get_file_info(file_bytes, filename)\n        temp_path = create_temp_file(\n            file_bytes, filename, config and config.get(\"max_file_size\")\n        )\n\n        logger.debug(\n            \"Temporary file created at %s for file info: %s\", temp_path, file_info\n        )\n\n        try:\n            suffix = Path(filename).suffix.lower()\n            logger.debug(\"Detected file suffix: %s\", suffix)\n\n            handler = registry.get_handler(suffix)\n            handler_name = handler.__class__.__name__\n\n            logger.info(\n                \"Using handler %s for file %s (size: %s MB)\",\n                handler_name,\n                filename,\n                file_info[\"size_mb\"],\n            )\n\n            try:\n                result = handler.extract(temp_path, config or self.config.__dict__)\n            except Exception as e:\n                from textxtract.core.exceptions import (\n                    ExtractionError,\n                    InvalidFileError,\n                )\n\n                logger.error(\n                    \"Extraction failed for file %s (handler: %s): %s\",\n                    filename,\n                    handler_name,\n                    e,\n                )\n\n                # If it's already a custom extraction error, re-raise\n                if isinstance(e, ExtractionError):\n                    raise\n                # If it's a known invalid file error, wrap it\n                if isinstance(e, (ValueError, OSError)):\n                    raise InvalidFileError(\n                        f\"Invalid file: {filename} (handler: {handler_name}, error: {e})\"\n                    ) from e\n                # Otherwise, wrap as general extraction error\n                raise ExtractionError(\n                    f\"Extraction failed for file {filename} using {handler_name}: {e}\"\n                ) from e\n\n            logger.info(\n                \"Extraction successful for file %s (extracted %d characters)\",\n                filename,\n                len(result),\n            )\n            return result\n        finally:\n            safe_unlink(temp_path)\n            logger.debug(\"Temporary file %s deleted\", temp_path)\n\n    async def extract_async(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"\n        Async interface for compatibility; delegates to sync extract.\n\n        Raises:\n            NotImplementedError: Always, as sync extractor does not support async.\n        \"\"\"\n        raise NotImplementedError(\n            \"Synchronous extractor does not support async extraction. Use AsyncTextExtractor instead.\"\n        )\n\n    def __enter__(self):\n        \"\"\"Context manager entry.\"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit.\"\"\"\n        pass  # No resources to clean up for sync extractor\n</code></pre> Attributes <code></code> config <code>instance-attribute</code> <pre><code>config = config or ExtractorConfig()\n</code></pre> Functions <code></code> __enter__ <pre><code>__enter__()\n</code></pre> <p>Context manager entry.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    return self\n</code></pre> <code></code> __exit__ <pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Context manager exit.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    pass  # No resources to clean up for sync extractor\n</code></pre> <code></code> __init__ <pre><code>__init__(config=None)\n</code></pre> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def __init__(self, config: Optional[ExtractorConfig] = None):\n    self.config = config or ExtractorConfig()\n    logger.debug(\n        \"SyncTextExtractor initialized with config: %s\", self.config.__dict__\n    )\n</code></pre> <code></code> extract <pre><code>extract(file_bytes, filename, config=None)\n</code></pre> <p>Extract text synchronously from file bytes.</p> <p>Parameters:</p> Name Type Description Default <code>file_bytes</code> <code>bytes</code> <p>The file content as bytes.</p> required <code>filename</code> <code>str</code> <p>The name of the file (used for extension).</p> required <code>config</code> <code>Optional[dict]</code> <p>Optional configuration overrides.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted text.</p> <p>Raises:</p> Type Description <code>FileTypeNotSupportedError</code> <p>If the file extension is not supported.</p> <code>ExtractionError</code> <p>If extraction fails.</p> <code>InvalidFileError</code> <p>If the file is invalid or corrupted.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def extract(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"\n    Extract text synchronously from file bytes.\n\n    Args:\n        file_bytes (bytes): The file content as bytes.\n        filename (str): The name of the file (used for extension).\n        config (Optional[dict]): Optional configuration overrides.\n\n    Returns:\n        str: Extracted text.\n\n    Raises:\n        FileTypeNotSupportedError: If the file extension is not supported.\n        ExtractionError: If extraction fails.\n        InvalidFileError: If the file is invalid or corrupted.\n    \"\"\"\n    file_info = get_file_info(file_bytes, filename)\n    temp_path = create_temp_file(\n        file_bytes, filename, config and config.get(\"max_file_size\")\n    )\n\n    logger.debug(\n        \"Temporary file created at %s for file info: %s\", temp_path, file_info\n    )\n\n    try:\n        suffix = Path(filename).suffix.lower()\n        logger.debug(\"Detected file suffix: %s\", suffix)\n\n        handler = registry.get_handler(suffix)\n        handler_name = handler.__class__.__name__\n\n        logger.info(\n            \"Using handler %s for file %s (size: %s MB)\",\n            handler_name,\n            filename,\n            file_info[\"size_mb\"],\n        )\n\n        try:\n            result = handler.extract(temp_path, config or self.config.__dict__)\n        except Exception as e:\n            from textxtract.core.exceptions import (\n                ExtractionError,\n                InvalidFileError,\n            )\n\n            logger.error(\n                \"Extraction failed for file %s (handler: %s): %s\",\n                filename,\n                handler_name,\n                e,\n            )\n\n            # If it's already a custom extraction error, re-raise\n            if isinstance(e, ExtractionError):\n                raise\n            # If it's a known invalid file error, wrap it\n            if isinstance(e, (ValueError, OSError)):\n                raise InvalidFileError(\n                    f\"Invalid file: {filename} (handler: {handler_name}, error: {e})\"\n                ) from e\n            # Otherwise, wrap as general extraction error\n            raise ExtractionError(\n                f\"Extraction failed for file {filename} using {handler_name}: {e}\"\n            ) from e\n\n        logger.info(\n            \"Extraction successful for file %s (extracted %d characters)\",\n            filename,\n            len(result),\n        )\n        return result\n    finally:\n        safe_unlink(temp_path)\n        logger.debug(\"Temporary file %s deleted\", temp_path)\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_bytes, filename, config=None)\n</code></pre> <p>Async interface for compatibility; delegates to sync extract.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always, as sync extractor does not support async.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>async def extract_async(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"\n    Async interface for compatibility; delegates to sync extract.\n\n    Raises:\n        NotImplementedError: Always, as sync extractor does not support async.\n    \"\"\"\n    raise NotImplementedError(\n        \"Synchronous extractor does not support async extraction. Use AsyncTextExtractor instead.\"\n    )\n</code></pre>"},{"location":"reference/__init__/#textxtract.sync.extractor-functions","title":"Functions","text":""},{"location":"reference/__init__/#textxtract.tests","title":"tests","text":"<p>Test suite for textxtract package.</p> <p>Modules:</p> Name Description <code>test_async</code> <p>Comprehensive tests for AsyncTextExtractor using all sample files.</p> <code>test_edge_cases</code> <p>Edge case tests for text extractor.</p> <code>test_exceptions</code> <p>Unit tests for custom exceptions.</p> <code>test_sync</code> <p>Comprehensive tests for SyncTextExtractor using all sample files.</p>"},{"location":"reference/__init__/#textxtract.tests-modules","title":"Modules","text":""},{"location":"reference/__init__/#textxtract.tests.test_async","title":"test_async","text":"<p>Comprehensive tests for AsyncTextExtractor using all sample files.</p> <p>Functions:</p> Name Description <code>test_async_extractor_all_types</code> <p>Attributes:</p> Name Type Description <code>TEST_FILES_DIR</code>"},{"location":"reference/__init__/#textxtract.tests.test_async-attributes","title":"Attributes","text":"TEST_FILES_DIR <code>module-attribute</code> <pre><code>TEST_FILES_DIR = parent / 'files'\n</code></pre>"},{"location":"reference/__init__/#textxtract.tests.test_async-classes","title":"Classes","text":""},{"location":"reference/__init__/#textxtract.tests.test_async-functions","title":"Functions","text":"test_async_extractor_all_types <code>async</code> <pre><code>test_async_extractor_all_types(filename, should_succeed)\n</code></pre> Source code in <code>textxtract/tests/test_async.py</code> <pre><code>@pytest.mark.parametrize(\n    \"filename,should_succeed\",\n    [\n        (\"text_file.txt\", True),\n        (\"text_file.text\", True),\n        (\"markdown.md\", True),\n        (\"text_file.pdf\", True),\n        (\"text_file.docx\", True),\n        (\"text_file.doc\", True),\n        (\"text_file.rtf\", True),\n        (\"text.html\", True),\n        (\"text.csv\", True),\n        (\"text.json\", True),\n        (\"text.xml\", True),\n        (\"text_zip.zip\", True),\n        (\"text_file.odt\", False),  # Not supported, should fail\n    ],\n)\n@pytest.mark.asyncio\nasync def test_async_extractor_all_types(filename, should_succeed):\n    extractor = AsyncTextExtractor()\n    file_path = TEST_FILES_DIR / filename\n    file_bytes = file_path.read_bytes()\n    try:\n        text = await extractor.extract_async(file_bytes, filename)\n        assert should_succeed, f\"Extraction should have failed for {filename}\"\n        assert isinstance(text, (str, list)), \"Extracted text should be str or list\"\n        assert text, \"Extracted text should not be empty\"\n    except FileTypeNotSupportedError:\n        assert not should_succeed, (\n            f\"FileTypeNotSupportedError unexpected for {filename}\"\n        )\n    except (ExtractionError, InvalidFileError):\n        assert not should_succeed, (\n            f\"ExtractionError/InvalidFileError unexpected for {filename}\"\n        )\n</code></pre>"},{"location":"reference/__init__/#textxtract.tests.test_edge_cases","title":"test_edge_cases","text":"<p>Edge case tests for text extractor.</p> <p>Classes:</p> Name Description <code>TestEdgeCases</code> <p>Test edge cases and error conditions.</p> <code>TestErrorMessages</code> <p>Test that error messages are helpful and informative.</p>"},{"location":"reference/__init__/#textxtract.tests.test_edge_cases-classes","title":"Classes","text":"TestEdgeCases <p>Test edge cases and error conditions.</p> <p>Methods:</p> Name Description <code>test_async_context_manager_cleanup</code> <p>Test that async context manager properly cleans up.</p> <code>test_async_extractor_closed</code> <p>Test that closed async extractor raises error.</p> <code>test_concurrent_extractions</code> <p>Test multiple concurrent extractions.</p> <code>test_config_from_environment</code> <p>Test loading configuration from environment variables.</p> <code>test_config_validation</code> <p>Test configuration validation.</p> <code>test_context_manager_cleanup</code> <p>Test that context managers properly clean up resources.</p> <code>test_corrupted_pdf</code> <p>Test extraction from corrupted PDF.</p> <code>test_custom_config_per_extraction</code> <p>Test passing custom config per extraction call.</p> <code>test_empty_file</code> <p>Test extraction from empty file.</p> <code>test_handler_import_errors</code> <p>Test graceful handling of missing optional dependencies.</p> <code>test_large_file_rejection</code> <p>Test that very large files are rejected.</p> <code>test_malicious_filename</code> <p>Test that malicious filenames are rejected.</p> <code>test_memory_pressure_handling</code> <p>Test behavior under memory pressure.</p> <code>test_temp_file_cleanup_on_error</code> <p>Test that temporary files are cleaned up even when errors occur.</p> <code>test_unsupported_file_type</code> <p>Test extraction from unsupported file type.</p> <code>test_zip_security_checks</code> <p>Test ZIP handler security checks.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>class TestEdgeCases:\n    \"\"\"Test edge cases and error conditions.\"\"\"\n\n    def test_empty_file(self):\n        \"\"\"Test extraction from empty file.\"\"\"\n        extractor = SyncTextExtractor()\n        empty_content = b\"\"\n\n        with pytest.raises(ValueError, match=\"File is empty\"):\n            extractor.extract(empty_content, \"empty.txt\")\n\n    def test_large_file_rejection(self):\n        \"\"\"Test that very large files are rejected.\"\"\"\n        extractor = SyncTextExtractor()\n        # Create content larger than default limit\n        large_content = b\"x\" * (101 * 1024 * 1024)  # 101MB\n\n        with pytest.raises(ValueError, match=\"File size.*exceeds\"):\n            extractor.extract(large_content, \"large.txt\")\n\n    def test_malicious_filename(self):\n        \"\"\"Test that malicious filenames are rejected.\"\"\"\n        extractor = SyncTextExtractor()\n        content = b\"test content\"\n\n        malicious_names = [\n            \"../../../etc/passwd\",\n            \"..\\\\..\\\\windows\\\\system32\\\\config\",\n            \"/absolute/path/file.txt\",\n            \"file\\x00name.txt\",  # Null byte injection\n            \"a\" * 300 + \".txt\",  # Very long filename\n        ]\n\n        expected_errors = [\n            \"path traversal detected\",\n            \"path traversal detected\",\n            \"absolute path not allowed\",\n            \"contains null byte\",\n            \"Filename too long\",\n        ]\n\n        for malicious_name, expected_error in zip(malicious_names, expected_errors):\n            with pytest.raises(ValueError, match=expected_error):\n                extractor.extract(content, malicious_name)\n\n    def test_unsupported_file_type(self):\n        \"\"\"Test extraction from unsupported file type.\"\"\"\n        extractor = SyncTextExtractor()\n        content = b\"test content\"\n\n        with pytest.raises(FileTypeNotSupportedError):\n            extractor.extract(content, \"file.unsupported\")\n\n    def test_corrupted_pdf(self):\n        \"\"\"Test extraction from corrupted PDF.\"\"\"\n        extractor = SyncTextExtractor()\n        # Create fake PDF content\n        corrupted_pdf = b\"%%PDF-1.4\\n%corrupted content\"\n\n        with pytest.raises((ExtractionError, InvalidFileError)):\n            extractor.extract(corrupted_pdf, \"corrupted.pdf\")\n\n    @pytest.mark.asyncio\n    async def test_async_extractor_closed(self):\n        \"\"\"Test that closed async extractor raises error.\"\"\"\n        async with AsyncTextExtractor() as extractor:\n            pass  # Context manager closes extractor\n\n        content = b\"test content\"\n        with pytest.raises(RuntimeError, match=\"Extractor has been closed\"):\n            await extractor.extract_async(content, \"test.txt\")\n\n    def test_config_validation(self):\n        \"\"\"Test configuration validation.\"\"\"\n        # Invalid encoding\n        with pytest.raises(ValueError, match=\"Invalid encoding\"):\n            ExtractorConfig(encoding=\"invalid-encoding\")\n\n        # Invalid logging level\n        with pytest.raises(ValueError, match=\"Invalid logging level\"):\n            ExtractorConfig(logging_level=\"INVALID\")\n\n        # Invalid timeout\n        with pytest.raises(ValueError, match=\"Timeout must be a positive number\"):\n            ExtractorConfig(timeout=-1)\n\n        # Invalid max file size\n        with pytest.raises(\n            ValueError, match=\"Max file size must be a positive integer\"\n        ):\n            ExtractorConfig(max_file_size=-1)\n\n    def test_config_from_environment(self):\n        \"\"\"Test loading configuration from environment variables.\"\"\"\n        with patch.dict(\n            \"os.environ\",\n            {\n                \"TEXT_EXTRACTOR_ENCODING\": \"latin-1\",\n                \"TEXT_EXTRACTOR_LOG_LEVEL\": \"DEBUG\",\n                \"TEXT_EXTRACTOR_TIMEOUT\": \"30.0\",\n                \"TEXT_EXTRACTOR_MAX_FILE_SIZE\": \"50000000\",\n            },\n        ):\n            config = ExtractorConfig()\n            assert config.encoding == \"latin-1\"\n            assert config.logging_level == \"DEBUG\"\n            assert config.timeout == 30.0\n            assert config.max_file_size == 50000000\n\n    @pytest.mark.asyncio\n    async def test_concurrent_extractions(self):\n        \"\"\"Test multiple concurrent extractions.\"\"\"\n        import asyncio\n\n        async with AsyncTextExtractor(max_workers=2) as extractor:\n            content = b\"test content\"\n\n            # Run multiple extractions concurrently\n            tasks = [\n                extractor.extract_async(content, f\"test_{i}.txt\") for i in range(5)\n            ]\n\n            results = await asyncio.gather(*tasks)\n            assert len(results) == 5\n            assert all(result == \"test content\" for result in results)\n\n    def test_context_manager_cleanup(self):\n        \"\"\"Test that context managers properly clean up resources.\"\"\"\n        with SyncTextExtractor() as extractor:\n            content = b\"test content\"\n            result = extractor.extract(content, \"test.txt\")\n            assert result == \"test content\"\n        # No specific cleanup needed for sync extractor\n\n    @pytest.mark.asyncio\n    async def test_async_context_manager_cleanup(self):\n        \"\"\"Test that async context manager properly cleans up.\"\"\"\n        extractor = AsyncTextExtractor()\n\n        async with extractor:\n            content = b\"test content\"\n            result = await extractor.extract_async(content, \"test.txt\")\n            assert result == \"test content\"\n\n        # Verify extractor is closed\n        assert extractor._closed\n\n    def test_zip_security_checks(self):\n        \"\"\"Test ZIP handler security checks.\"\"\"\n        from textxtract.handlers.zip import ZIPHandler\n\n        handler = ZIPHandler()\n\n        # Test path traversal detection\n        assert handler._is_unsafe_path(\"../../../etc/passwd\")\n        assert handler._is_unsafe_path(\"..\\\\..\\\\windows\\\\system32\")\n        assert handler._is_unsafe_path(\"/absolute/path\")\n        assert handler._is_unsafe_path(\"C:\\\\windows\\\\system32\")\n\n        # Test safe paths\n        assert not handler._is_unsafe_path(\"safe/file.txt\")\n        assert not handler._is_unsafe_path(\"folder/subfolder/file.txt\")\n\n    def test_memory_pressure_handling(self):\n        \"\"\"Test behavior under memory pressure.\"\"\"\n        # This would require more sophisticated testing in a real scenario\n        # For now, just test that large text files are handled gracefully\n        extractor = SyncTextExtractor()\n\n        # Create a large text file\n        large_text = \"Large content line\\n\" * 100000  # ~1.7MB of text\n        large_content = large_text.encode(\"utf-8\")\n\n        # Should work fine for reasonable sizes\n        result = extractor.extract(large_content, \"large.txt\")\n        assert len(result) &gt; 1000000\n\n    def test_handler_import_errors(self):\n        \"\"\"Test graceful handling of missing optional dependencies.\"\"\"\n        # Mock import error for PDF handler\n        with patch(\"textxtract.core.registry.logger\") as mock_logger:\n            # This would test the registry's handling of import errors\n            # The actual test would need to mock the import process\n            pass\n\n    def test_temp_file_cleanup_on_error(self):\n        \"\"\"Test that temporary files are cleaned up even when errors occur.\"\"\"\n        extractor = SyncTextExtractor()\n\n        # Use a handler that will definitely fail\n        with pytest.raises(FileTypeNotSupportedError):\n            extractor.extract(b\"content\", \"file.unsupported\")\n\n        # Verify no temp files are left behind\n        # This is tricky to test directly, but the safe_unlink in finally blocks should handle it\n\n    def test_custom_config_per_extraction(self):\n        \"\"\"Test passing custom config per extraction call.\"\"\"\n        extractor = SyncTextExtractor()\n        content = b\"test content\"\n\n        # Test with custom encoding\n        result = extractor.extract(content, \"test.txt\", {\"encoding\": \"utf-8\"})\n        assert result == \"test content\"\n\n        # Test with custom max file size\n        with pytest.raises(ValueError):\n            extractor.extract(content, \"test.txt\", {\"max_file_size\": 5})\n</code></pre> Functions <code></code> test_async_context_manager_cleanup <code>async</code> <pre><code>test_async_context_manager_cleanup()\n</code></pre> <p>Test that async context manager properly cleans up.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>@pytest.mark.asyncio\nasync def test_async_context_manager_cleanup(self):\n    \"\"\"Test that async context manager properly cleans up.\"\"\"\n    extractor = AsyncTextExtractor()\n\n    async with extractor:\n        content = b\"test content\"\n        result = await extractor.extract_async(content, \"test.txt\")\n        assert result == \"test content\"\n\n    # Verify extractor is closed\n    assert extractor._closed\n</code></pre> <code></code> test_async_extractor_closed <code>async</code> <pre><code>test_async_extractor_closed()\n</code></pre> <p>Test that closed async extractor raises error.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>@pytest.mark.asyncio\nasync def test_async_extractor_closed(self):\n    \"\"\"Test that closed async extractor raises error.\"\"\"\n    async with AsyncTextExtractor() as extractor:\n        pass  # Context manager closes extractor\n\n    content = b\"test content\"\n    with pytest.raises(RuntimeError, match=\"Extractor has been closed\"):\n        await extractor.extract_async(content, \"test.txt\")\n</code></pre> <code></code> test_concurrent_extractions <code>async</code> <pre><code>test_concurrent_extractions()\n</code></pre> <p>Test multiple concurrent extractions.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>@pytest.mark.asyncio\nasync def test_concurrent_extractions(self):\n    \"\"\"Test multiple concurrent extractions.\"\"\"\n    import asyncio\n\n    async with AsyncTextExtractor(max_workers=2) as extractor:\n        content = b\"test content\"\n\n        # Run multiple extractions concurrently\n        tasks = [\n            extractor.extract_async(content, f\"test_{i}.txt\") for i in range(5)\n        ]\n\n        results = await asyncio.gather(*tasks)\n        assert len(results) == 5\n        assert all(result == \"test content\" for result in results)\n</code></pre> <code></code> test_config_from_environment <pre><code>test_config_from_environment()\n</code></pre> <p>Test loading configuration from environment variables.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>def test_config_from_environment(self):\n    \"\"\"Test loading configuration from environment variables.\"\"\"\n    with patch.dict(\n        \"os.environ\",\n        {\n            \"TEXT_EXTRACTOR_ENCODING\": \"latin-1\",\n            \"TEXT_EXTRACTOR_LOG_LEVEL\": \"DEBUG\",\n            \"TEXT_EXTRACTOR_TIMEOUT\": \"30.0\",\n            \"TEXT_EXTRACTOR_MAX_FILE_SIZE\": \"50000000\",\n        },\n    ):\n        config = ExtractorConfig()\n        assert config.encoding == \"latin-1\"\n        assert config.logging_level == \"DEBUG\"\n        assert config.timeout == 30.0\n        assert config.max_file_size == 50000000\n</code></pre> <code></code> test_config_validation <pre><code>test_config_validation()\n</code></pre> <p>Test configuration validation.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>def test_config_validation(self):\n    \"\"\"Test configuration validation.\"\"\"\n    # Invalid encoding\n    with pytest.raises(ValueError, match=\"Invalid encoding\"):\n        ExtractorConfig(encoding=\"invalid-encoding\")\n\n    # Invalid logging level\n    with pytest.raises(ValueError, match=\"Invalid logging level\"):\n        ExtractorConfig(logging_level=\"INVALID\")\n\n    # Invalid timeout\n    with pytest.raises(ValueError, match=\"Timeout must be a positive number\"):\n        ExtractorConfig(timeout=-1)\n\n    # Invalid max file size\n    with pytest.raises(\n        ValueError, match=\"Max file size must be a positive integer\"\n    ):\n        ExtractorConfig(max_file_size=-1)\n</code></pre> <code></code> test_context_manager_cleanup <pre><code>test_context_manager_cleanup()\n</code></pre> <p>Test that context managers properly clean up resources.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>def test_context_manager_cleanup(self):\n    \"\"\"Test that context managers properly clean up resources.\"\"\"\n    with SyncTextExtractor() as extractor:\n        content = b\"test content\"\n        result = extractor.extract(content, \"test.txt\")\n        assert result == \"test content\"\n</code></pre> <code></code> test_corrupted_pdf <pre><code>test_corrupted_pdf()\n</code></pre> <p>Test extraction from corrupted PDF.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>def test_corrupted_pdf(self):\n    \"\"\"Test extraction from corrupted PDF.\"\"\"\n    extractor = SyncTextExtractor()\n    # Create fake PDF content\n    corrupted_pdf = b\"%%PDF-1.4\\n%corrupted content\"\n\n    with pytest.raises((ExtractionError, InvalidFileError)):\n        extractor.extract(corrupted_pdf, \"corrupted.pdf\")\n</code></pre> <code></code> test_custom_config_per_extraction <pre><code>test_custom_config_per_extraction()\n</code></pre> <p>Test passing custom config per extraction call.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>def test_custom_config_per_extraction(self):\n    \"\"\"Test passing custom config per extraction call.\"\"\"\n    extractor = SyncTextExtractor()\n    content = b\"test content\"\n\n    # Test with custom encoding\n    result = extractor.extract(content, \"test.txt\", {\"encoding\": \"utf-8\"})\n    assert result == \"test content\"\n\n    # Test with custom max file size\n    with pytest.raises(ValueError):\n        extractor.extract(content, \"test.txt\", {\"max_file_size\": 5})\n</code></pre> <code></code> test_empty_file <pre><code>test_empty_file()\n</code></pre> <p>Test extraction from empty file.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>def test_empty_file(self):\n    \"\"\"Test extraction from empty file.\"\"\"\n    extractor = SyncTextExtractor()\n    empty_content = b\"\"\n\n    with pytest.raises(ValueError, match=\"File is empty\"):\n        extractor.extract(empty_content, \"empty.txt\")\n</code></pre> <code></code> test_handler_import_errors <pre><code>test_handler_import_errors()\n</code></pre> <p>Test graceful handling of missing optional dependencies.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>def test_handler_import_errors(self):\n    \"\"\"Test graceful handling of missing optional dependencies.\"\"\"\n    # Mock import error for PDF handler\n    with patch(\"textxtract.core.registry.logger\") as mock_logger:\n        # This would test the registry's handling of import errors\n        # The actual test would need to mock the import process\n        pass\n</code></pre> <code></code> test_large_file_rejection <pre><code>test_large_file_rejection()\n</code></pre> <p>Test that very large files are rejected.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>def test_large_file_rejection(self):\n    \"\"\"Test that very large files are rejected.\"\"\"\n    extractor = SyncTextExtractor()\n    # Create content larger than default limit\n    large_content = b\"x\" * (101 * 1024 * 1024)  # 101MB\n\n    with pytest.raises(ValueError, match=\"File size.*exceeds\"):\n        extractor.extract(large_content, \"large.txt\")\n</code></pre> <code></code> test_malicious_filename <pre><code>test_malicious_filename()\n</code></pre> <p>Test that malicious filenames are rejected.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>def test_malicious_filename(self):\n    \"\"\"Test that malicious filenames are rejected.\"\"\"\n    extractor = SyncTextExtractor()\n    content = b\"test content\"\n\n    malicious_names = [\n        \"../../../etc/passwd\",\n        \"..\\\\..\\\\windows\\\\system32\\\\config\",\n        \"/absolute/path/file.txt\",\n        \"file\\x00name.txt\",  # Null byte injection\n        \"a\" * 300 + \".txt\",  # Very long filename\n    ]\n\n    expected_errors = [\n        \"path traversal detected\",\n        \"path traversal detected\",\n        \"absolute path not allowed\",\n        \"contains null byte\",\n        \"Filename too long\",\n    ]\n\n    for malicious_name, expected_error in zip(malicious_names, expected_errors):\n        with pytest.raises(ValueError, match=expected_error):\n            extractor.extract(content, malicious_name)\n</code></pre> <code></code> test_memory_pressure_handling <pre><code>test_memory_pressure_handling()\n</code></pre> <p>Test behavior under memory pressure.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>def test_memory_pressure_handling(self):\n    \"\"\"Test behavior under memory pressure.\"\"\"\n    # This would require more sophisticated testing in a real scenario\n    # For now, just test that large text files are handled gracefully\n    extractor = SyncTextExtractor()\n\n    # Create a large text file\n    large_text = \"Large content line\\n\" * 100000  # ~1.7MB of text\n    large_content = large_text.encode(\"utf-8\")\n\n    # Should work fine for reasonable sizes\n    result = extractor.extract(large_content, \"large.txt\")\n    assert len(result) &gt; 1000000\n</code></pre> <code></code> test_temp_file_cleanup_on_error <pre><code>test_temp_file_cleanup_on_error()\n</code></pre> <p>Test that temporary files are cleaned up even when errors occur.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>def test_temp_file_cleanup_on_error(self):\n    \"\"\"Test that temporary files are cleaned up even when errors occur.\"\"\"\n    extractor = SyncTextExtractor()\n\n    # Use a handler that will definitely fail\n    with pytest.raises(FileTypeNotSupportedError):\n        extractor.extract(b\"content\", \"file.unsupported\")\n</code></pre> <code></code> test_unsupported_file_type <pre><code>test_unsupported_file_type()\n</code></pre> <p>Test extraction from unsupported file type.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>def test_unsupported_file_type(self):\n    \"\"\"Test extraction from unsupported file type.\"\"\"\n    extractor = SyncTextExtractor()\n    content = b\"test content\"\n\n    with pytest.raises(FileTypeNotSupportedError):\n        extractor.extract(content, \"file.unsupported\")\n</code></pre> <code></code> test_zip_security_checks <pre><code>test_zip_security_checks()\n</code></pre> <p>Test ZIP handler security checks.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>def test_zip_security_checks(self):\n    \"\"\"Test ZIP handler security checks.\"\"\"\n    from textxtract.handlers.zip import ZIPHandler\n\n    handler = ZIPHandler()\n\n    # Test path traversal detection\n    assert handler._is_unsafe_path(\"../../../etc/passwd\")\n    assert handler._is_unsafe_path(\"..\\\\..\\\\windows\\\\system32\")\n    assert handler._is_unsafe_path(\"/absolute/path\")\n    assert handler._is_unsafe_path(\"C:\\\\windows\\\\system32\")\n\n    # Test safe paths\n    assert not handler._is_unsafe_path(\"safe/file.txt\")\n    assert not handler._is_unsafe_path(\"folder/subfolder/file.txt\")\n</code></pre> <code></code> TestErrorMessages <p>Test that error messages are helpful and informative.</p> <p>Methods:</p> Name Description <code>test_file_size_error_message</code> <p>Test that file size errors include actual vs allowed size.</p> <code>test_unsupported_extension_message</code> <p>Test that unsupported extension errors include helpful info.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>class TestErrorMessages:\n    \"\"\"Test that error messages are helpful and informative.\"\"\"\n\n    def test_unsupported_extension_message(self):\n        \"\"\"Test that unsupported extension errors include helpful info.\"\"\"\n        extractor = SyncTextExtractor()\n\n        with pytest.raises(FileTypeNotSupportedError) as exc_info:\n            extractor.extract(b\"content\", \"file.xyz\")\n\n        error_msg = str(exc_info.value)\n        assert \"xyz\" in error_msg\n        assert \"Supported extensions\" in error_msg\n\n    def test_file_size_error_message(self):\n        \"\"\"Test that file size errors include actual vs allowed size.\"\"\"\n        extractor = SyncTextExtractor()\n        large_content = b\"x\" * 1000\n\n        with pytest.raises(ValueError) as exc_info:\n            extractor.extract(large_content, \"test.txt\", {\"max_file_size\": 500})\n\n        error_msg = str(exc_info.value)\n        assert \"1,000 bytes\" in error_msg\n        assert \"500 bytes\" in error_msg\n</code></pre> Functions <code></code> test_file_size_error_message <pre><code>test_file_size_error_message()\n</code></pre> <p>Test that file size errors include actual vs allowed size.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>def test_file_size_error_message(self):\n    \"\"\"Test that file size errors include actual vs allowed size.\"\"\"\n    extractor = SyncTextExtractor()\n    large_content = b\"x\" * 1000\n\n    with pytest.raises(ValueError) as exc_info:\n        extractor.extract(large_content, \"test.txt\", {\"max_file_size\": 500})\n\n    error_msg = str(exc_info.value)\n    assert \"1,000 bytes\" in error_msg\n    assert \"500 bytes\" in error_msg\n</code></pre> <code></code> test_unsupported_extension_message <pre><code>test_unsupported_extension_message()\n</code></pre> <p>Test that unsupported extension errors include helpful info.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>def test_unsupported_extension_message(self):\n    \"\"\"Test that unsupported extension errors include helpful info.\"\"\"\n    extractor = SyncTextExtractor()\n\n    with pytest.raises(FileTypeNotSupportedError) as exc_info:\n        extractor.extract(b\"content\", \"file.xyz\")\n\n    error_msg = str(exc_info.value)\n    assert \"xyz\" in error_msg\n    assert \"Supported extensions\" in error_msg\n</code></pre>"},{"location":"reference/__init__/#textxtract.tests.test_exceptions","title":"test_exceptions","text":"<p>Unit tests for custom exceptions.</p> <p>Functions:</p> Name Description <code>test_extraction_error</code> <code>test_extraction_timeout_error</code> <code>test_file_type_not_supported_error</code> <code>test_invalid_file_error</code>"},{"location":"reference/__init__/#textxtract.tests.test_exceptions-classes","title":"Classes","text":""},{"location":"reference/__init__/#textxtract.tests.test_exceptions-functions","title":"Functions","text":"test_extraction_error <pre><code>test_extraction_error()\n</code></pre> Source code in <code>textxtract/tests/test_exceptions.py</code> <pre><code>def test_extraction_error():\n    e = ExtractionError(\"error\")\n    assert str(e) == \"error\"\n</code></pre> <code></code> test_extraction_timeout_error <pre><code>test_extraction_timeout_error()\n</code></pre> Source code in <code>textxtract/tests/test_exceptions.py</code> <pre><code>def test_extraction_timeout_error():\n    e = ExtractionTimeoutError(\"timeout\")\n    assert str(e) == \"timeout\"\n</code></pre> <code></code> test_file_type_not_supported_error <pre><code>test_file_type_not_supported_error()\n</code></pre> Source code in <code>textxtract/tests/test_exceptions.py</code> <pre><code>def test_file_type_not_supported_error():\n    e = FileTypeNotSupportedError(\"not supported\")\n    assert str(e) == \"not supported\"\n</code></pre> <code></code> test_invalid_file_error <pre><code>test_invalid_file_error()\n</code></pre> Source code in <code>textxtract/tests/test_exceptions.py</code> <pre><code>def test_invalid_file_error():\n    e = InvalidFileError(\"invalid\")\n    assert str(e) == \"invalid\"\n</code></pre>"},{"location":"reference/__init__/#textxtract.tests.test_sync","title":"test_sync","text":"<p>Comprehensive tests for SyncTextExtractor using all sample files.</p> <p>Functions:</p> Name Description <code>test_sync_extractor_all_types</code> <p>Attributes:</p> Name Type Description <code>TEST_FILES_DIR</code>"},{"location":"reference/__init__/#textxtract.tests.test_sync-attributes","title":"Attributes","text":"TEST_FILES_DIR <code>module-attribute</code> <pre><code>TEST_FILES_DIR = parent / 'files'\n</code></pre>"},{"location":"reference/__init__/#textxtract.tests.test_sync-classes","title":"Classes","text":""},{"location":"reference/__init__/#textxtract.tests.test_sync-functions","title":"Functions","text":"test_sync_extractor_all_types <pre><code>test_sync_extractor_all_types(filename, should_succeed)\n</code></pre> Source code in <code>textxtract/tests/test_sync.py</code> <pre><code>@pytest.mark.parametrize(\n    \"filename,should_succeed\",\n    [\n        (\"text_file.txt\", True),\n        (\"text_file.text\", True),\n        (\"markdown.md\", True),\n        (\"text_file.pdf\", True),\n        (\"text_file.docx\", True),\n        (\"text_file.doc\", True),\n        (\"text_file.rtf\", True),\n        (\"text.html\", True),\n        (\"text.csv\", True),\n        (\"text.json\", True),\n        (\"text.xml\", True),\n        (\"text_zip.zip\", True),\n        (\"text_file.odt\", False),  # Not supported, should fail\n    ],\n)\ndef test_sync_extractor_all_types(filename, should_succeed):\n    extractor = SyncTextExtractor()\n    file_path = TEST_FILES_DIR / filename\n    file_bytes = file_path.read_bytes()\n    try:\n        text = extractor.extract(file_bytes, filename)\n        assert should_succeed, f\"Extraction should have failed for {filename}\"\n        assert isinstance(text, (str, list)), \"Extracted text should be str or list\"\n        assert text, \"Extracted text should not be empty\"\n    except FileTypeNotSupportedError:\n        assert not should_succeed, (\n            f\"FileTypeNotSupportedError unexpected for {filename}\"\n        )\n    except (ExtractionError, InvalidFileError):\n        assert not should_succeed, (\n            f\"ExtractionError/InvalidFileError unexpected for {filename}\"\n        )\n</code></pre>"},{"location":"reference/aio/","title":"Aio Module","text":""},{"location":"reference/aio/#overview","title":"Overview","text":"<p>Asynchronous text extraction components.</p> <p>Asynchronous extraction logic package.</p> <p>Modules:</p> Name Description <code>extractor</code> <p>Asynchronous text extraction logic.</p> <p>Classes:</p> Name Description <code>AsyncTextExtractor</code> <p>Asynchronous text extractor with proper resource management.</p>"},{"location":"reference/aio/#textxtract.aio-attributes","title":"Attributes","text":""},{"location":"reference/aio/#textxtract.aio.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['AsyncTextExtractor']\n</code></pre>"},{"location":"reference/aio/#textxtract.aio-classes","title":"Classes","text":""},{"location":"reference/aio/#textxtract.aio.AsyncTextExtractor","title":"AsyncTextExtractor","text":"<p>               Bases: <code>TextExtractor</code></p> <p>Asynchronous text extractor with proper resource management.</p> <p>Provides asynchronous text extraction from various file types. Logs debug and info level messages for tracing and diagnostics. Supports context manager protocol for proper cleanup.</p> <p>Methods:</p> Name Description <code>__aenter__</code> <p>Async context manager entry.</p> <code>__aexit__</code> <p>Async context manager exit.</p> <code>__del__</code> <p>Destructor to ensure cleanup.</p> <code>__enter__</code> <p>Context manager entry.</p> <code>__exit__</code> <p>Context manager exit.</p> <code>__init__</code> <code>close</code> <p>Close the extractor and clean up resources.</p> <code>extract</code> <p>Sync interface for compatibility; delegates to async extract.</p> <code>extract_async</code> <p>Extract text asynchronously from file bytes using a thread pool.</p> <p>Attributes:</p> Name Type Description <code>config</code> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>class AsyncTextExtractor(TextExtractor):\n    \"\"\"\n    Asynchronous text extractor with proper resource management.\n\n    Provides asynchronous text extraction from various file types.\n    Logs debug and info level messages for tracing and diagnostics.\n    Supports context manager protocol for proper cleanup.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: Optional[ExtractorConfig] = None,\n        max_workers: Optional[int] = None,\n    ):\n        self.config = config or ExtractorConfig()\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._closed = False\n\n        # Register cleanup on exit\n        atexit.register(self._cleanup)\n\n        logger.debug(\n            \"AsyncTextExtractor initialized with config: %s, max_workers: %s\",\n            self.config.__dict__,\n            max_workers,\n        )\n\n    def extract(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"\n        Sync interface for compatibility; delegates to async extract.\n\n        Raises:\n            NotImplementedError: Always, as async extractor requires async usage.\n        \"\"\"\n        raise NotImplementedError(\n            \"Use extract_async() for asynchronous extraction or use SyncTextExtractor\"\n        )\n\n    async def extract_async(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"\n        Extract text asynchronously from file bytes using a thread pool.\n\n        Args:\n            file_bytes (bytes): The file content as bytes.\n            filename (str): The name of the file (used for extension).\n            config (Optional[dict]): Optional configuration overrides.\n\n        Returns:\n            str: Extracted text.\n\n        Raises:\n            FileTypeNotSupportedError: If the file extension is not supported.\n            ExtractionError: If extraction fails.\n            RuntimeError: If extractor is closed.\n        \"\"\"\n        if self._closed:\n            raise RuntimeError(\"Extractor has been closed\")\n\n        file_info = get_file_info(file_bytes, filename)\n        temp_path = create_temp_file(\n            file_bytes, filename, config and config.get(\"max_file_size\")\n        )\n\n        logger.debug(\n            \"Temporary file created at %s for file info: %s\", temp_path, file_info\n        )\n\n        try:\n            suffix = Path(filename).suffix.lower()\n            logger.debug(\"Detected file suffix: %s\", suffix)\n\n            handler = registry.get_handler(suffix)\n            handler_name = handler.__class__.__name__\n\n            logger.info(\n                \"Using handler %s for file %s (size: %s MB)\",\n                handler_name,\n                filename,\n                file_info[\"size_mb\"],\n            )\n\n            loop = asyncio.get_running_loop()\n            try:\n                # Offload sync handler to thread pool for I/O-bound tasks\n                result = await loop.run_in_executor(\n                    self._executor,\n                    handler.extract,\n                    temp_path,\n                    config or self.config.__dict__,\n                )\n            except Exception as e:\n                from textxtract.core.exceptions import (\n                    ExtractionError,\n                    InvalidFileError,\n                )\n\n                logger.error(\n                    \"Extraction failed for file %s (handler: %s): %s\",\n                    filename,\n                    handler_name,\n                    e,\n                )\n\n                # If it's already a custom extraction error, re-raise\n                if isinstance(e, ExtractionError):\n                    raise\n                # If it's a known invalid file error, wrap it\n                if isinstance(e, (ValueError, OSError)):\n                    raise InvalidFileError(\n                        f\"Invalid file: {filename} (handler: {handler_name}, error: {e})\"\n                    ) from e\n                # Otherwise, wrap as general extraction error\n                raise ExtractionError(\n                    f\"Extraction failed for file {filename} using {handler_name}: {e}\"\n                ) from e\n\n            logger.info(\n                \"Extraction successful for file %s (extracted %d characters)\",\n                filename,\n                len(result),\n            )\n            return result\n        finally:\n            safe_unlink(temp_path)\n            logger.debug(\"Temporary file %s deleted\", temp_path)\n\n    def close(self):\n        \"\"\"Close the extractor and clean up resources.\"\"\"\n        if not self._closed:\n            self._cleanup()\n            self._closed = True\n\n    def _cleanup(self):\n        \"\"\"Internal cleanup method.\"\"\"\n        if hasattr(self, \"_executor\") and self._executor:\n            try:\n                self._executor.shutdown(wait=True, cancel_futures=True)\n                logger.debug(\"ThreadPoolExecutor shut down successfully\")\n            except Exception as e:\n                logger.warning(\"Error shutting down ThreadPoolExecutor: %s\", e)\n\n    def __enter__(self):\n        \"\"\"Context manager entry.\"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit.\"\"\"\n        self.close()\n\n    async def __aenter__(self):\n        \"\"\"Async context manager entry.\"\"\"\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Async context manager exit.\"\"\"\n        self.close()\n\n    def __del__(self):\n        \"\"\"Destructor to ensure cleanup.\"\"\"\n        if not self._closed:\n            self._cleanup()\n</code></pre>"},{"location":"reference/aio/#textxtract.aio.AsyncTextExtractor-attributes","title":"Attributes","text":""},{"location":"reference/aio/#textxtract.aio.AsyncTextExtractor.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = config or ExtractorConfig()\n</code></pre>"},{"location":"reference/aio/#textxtract.aio.AsyncTextExtractor-functions","title":"Functions","text":""},{"location":"reference/aio/#textxtract.aio.AsyncTextExtractor.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__()\n</code></pre> <p>Async context manager entry.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def __aenter__(self):\n    \"\"\"Async context manager entry.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/aio/#textxtract.aio.AsyncTextExtractor.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Async context manager exit.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Async context manager exit.\"\"\"\n    self.close()\n</code></pre>"},{"location":"reference/aio/#textxtract.aio.AsyncTextExtractor.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Destructor to ensure cleanup.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __del__(self):\n    \"\"\"Destructor to ensure cleanup.\"\"\"\n    if not self._closed:\n        self._cleanup()\n</code></pre>"},{"location":"reference/aio/#textxtract.aio.AsyncTextExtractor.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>Context manager entry.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/aio/#textxtract.aio.AsyncTextExtractor.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Context manager exit.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    self.close()\n</code></pre>"},{"location":"reference/aio/#textxtract.aio.AsyncTextExtractor.__init__","title":"__init__","text":"<pre><code>__init__(config=None, max_workers=None)\n</code></pre> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __init__(\n    self,\n    config: Optional[ExtractorConfig] = None,\n    max_workers: Optional[int] = None,\n):\n    self.config = config or ExtractorConfig()\n    self._executor = ThreadPoolExecutor(max_workers=max_workers)\n    self._closed = False\n\n    # Register cleanup on exit\n    atexit.register(self._cleanup)\n\n    logger.debug(\n        \"AsyncTextExtractor initialized with config: %s, max_workers: %s\",\n        self.config.__dict__,\n        max_workers,\n    )\n</code></pre>"},{"location":"reference/aio/#textxtract.aio.AsyncTextExtractor.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Close the extractor and clean up resources.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def close(self):\n    \"\"\"Close the extractor and clean up resources.\"\"\"\n    if not self._closed:\n        self._cleanup()\n        self._closed = True\n</code></pre>"},{"location":"reference/aio/#textxtract.aio.AsyncTextExtractor.extract","title":"extract","text":"<pre><code>extract(file_bytes, filename, config=None)\n</code></pre> <p>Sync interface for compatibility; delegates to async extract.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always, as async extractor requires async usage.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def extract(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"\n    Sync interface for compatibility; delegates to async extract.\n\n    Raises:\n        NotImplementedError: Always, as async extractor requires async usage.\n    \"\"\"\n    raise NotImplementedError(\n        \"Use extract_async() for asynchronous extraction or use SyncTextExtractor\"\n    )\n</code></pre>"},{"location":"reference/aio/#textxtract.aio.AsyncTextExtractor.extract_async","title":"extract_async  <code>async</code>","text":"<pre><code>extract_async(file_bytes, filename, config=None)\n</code></pre> <p>Extract text asynchronously from file bytes using a thread pool.</p> <p>Parameters:</p> Name Type Description Default <code>bytes</code> <p>The file content as bytes.</p> required <code>str</code> <p>The name of the file (used for extension).</p> required <code>Optional[dict]</code> <p>Optional configuration overrides.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted text.</p> <p>Raises:</p> Type Description <code>FileTypeNotSupportedError</code> <p>If the file extension is not supported.</p> <code>ExtractionError</code> <p>If extraction fails.</p> <code>RuntimeError</code> <p>If extractor is closed.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def extract_async(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"\n    Extract text asynchronously from file bytes using a thread pool.\n\n    Args:\n        file_bytes (bytes): The file content as bytes.\n        filename (str): The name of the file (used for extension).\n        config (Optional[dict]): Optional configuration overrides.\n\n    Returns:\n        str: Extracted text.\n\n    Raises:\n        FileTypeNotSupportedError: If the file extension is not supported.\n        ExtractionError: If extraction fails.\n        RuntimeError: If extractor is closed.\n    \"\"\"\n    if self._closed:\n        raise RuntimeError(\"Extractor has been closed\")\n\n    file_info = get_file_info(file_bytes, filename)\n    temp_path = create_temp_file(\n        file_bytes, filename, config and config.get(\"max_file_size\")\n    )\n\n    logger.debug(\n        \"Temporary file created at %s for file info: %s\", temp_path, file_info\n    )\n\n    try:\n        suffix = Path(filename).suffix.lower()\n        logger.debug(\"Detected file suffix: %s\", suffix)\n\n        handler = registry.get_handler(suffix)\n        handler_name = handler.__class__.__name__\n\n        logger.info(\n            \"Using handler %s for file %s (size: %s MB)\",\n            handler_name,\n            filename,\n            file_info[\"size_mb\"],\n        )\n\n        loop = asyncio.get_running_loop()\n        try:\n            # Offload sync handler to thread pool for I/O-bound tasks\n            result = await loop.run_in_executor(\n                self._executor,\n                handler.extract,\n                temp_path,\n                config or self.config.__dict__,\n            )\n        except Exception as e:\n            from textxtract.core.exceptions import (\n                ExtractionError,\n                InvalidFileError,\n            )\n\n            logger.error(\n                \"Extraction failed for file %s (handler: %s): %s\",\n                filename,\n                handler_name,\n                e,\n            )\n\n            # If it's already a custom extraction error, re-raise\n            if isinstance(e, ExtractionError):\n                raise\n            # If it's a known invalid file error, wrap it\n            if isinstance(e, (ValueError, OSError)):\n                raise InvalidFileError(\n                    f\"Invalid file: {filename} (handler: {handler_name}, error: {e})\"\n                ) from e\n            # Otherwise, wrap as general extraction error\n            raise ExtractionError(\n                f\"Extraction failed for file {filename} using {handler_name}: {e}\"\n            ) from e\n\n        logger.info(\n            \"Extraction successful for file %s (extracted %d characters)\",\n            filename,\n            len(result),\n        )\n        return result\n    finally:\n        safe_unlink(temp_path)\n        logger.debug(\"Temporary file %s deleted\", temp_path)\n</code></pre>"},{"location":"reference/aio/#textxtract.aio.AsyncTextExtractor.extract_async(file_bytes)","title":"<code>file_bytes</code>","text":""},{"location":"reference/aio/#textxtract.aio.AsyncTextExtractor.extract_async(filename)","title":"<code>filename</code>","text":""},{"location":"reference/aio/#textxtract.aio.AsyncTextExtractor.extract_async(config)","title":"<code>config</code>","text":""},{"location":"reference/aio/#textxtract.aio-modules","title":"Modules","text":""},{"location":"reference/aio/#textxtract.aio.extractor","title":"extractor","text":"<p>Asynchronous text extraction logic.</p> <p>Classes:</p> Name Description <code>AsyncTextExtractor</code> <p>Asynchronous text extractor with proper resource management.</p> <p>Attributes:</p> Name Type Description <code>logger</code>"},{"location":"reference/aio/#textxtract.aio.extractor-attributes","title":"Attributes","text":""},{"location":"reference/aio/#textxtract.aio.extractor.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger('textxtract.aio')\n</code></pre>"},{"location":"reference/aio/#textxtract.aio.extractor-classes","title":"Classes","text":""},{"location":"reference/aio/#textxtract.aio.extractor.AsyncTextExtractor","title":"AsyncTextExtractor","text":"<p>               Bases: <code>TextExtractor</code></p> <p>Asynchronous text extractor with proper resource management.</p> <p>Provides asynchronous text extraction from various file types. Logs debug and info level messages for tracing and diagnostics. Supports context manager protocol for proper cleanup.</p> <p>Methods:</p> Name Description <code>__aenter__</code> <p>Async context manager entry.</p> <code>__aexit__</code> <p>Async context manager exit.</p> <code>__del__</code> <p>Destructor to ensure cleanup.</p> <code>__enter__</code> <p>Context manager entry.</p> <code>__exit__</code> <p>Context manager exit.</p> <code>__init__</code> <code>close</code> <p>Close the extractor and clean up resources.</p> <code>extract</code> <p>Sync interface for compatibility; delegates to async extract.</p> <code>extract_async</code> <p>Extract text asynchronously from file bytes using a thread pool.</p> <p>Attributes:</p> Name Type Description <code>config</code> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>class AsyncTextExtractor(TextExtractor):\n    \"\"\"\n    Asynchronous text extractor with proper resource management.\n\n    Provides asynchronous text extraction from various file types.\n    Logs debug and info level messages for tracing and diagnostics.\n    Supports context manager protocol for proper cleanup.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: Optional[ExtractorConfig] = None,\n        max_workers: Optional[int] = None,\n    ):\n        self.config = config or ExtractorConfig()\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._closed = False\n\n        # Register cleanup on exit\n        atexit.register(self._cleanup)\n\n        logger.debug(\n            \"AsyncTextExtractor initialized with config: %s, max_workers: %s\",\n            self.config.__dict__,\n            max_workers,\n        )\n\n    def extract(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"\n        Sync interface for compatibility; delegates to async extract.\n\n        Raises:\n            NotImplementedError: Always, as async extractor requires async usage.\n        \"\"\"\n        raise NotImplementedError(\n            \"Use extract_async() for asynchronous extraction or use SyncTextExtractor\"\n        )\n\n    async def extract_async(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"\n        Extract text asynchronously from file bytes using a thread pool.\n\n        Args:\n            file_bytes (bytes): The file content as bytes.\n            filename (str): The name of the file (used for extension).\n            config (Optional[dict]): Optional configuration overrides.\n\n        Returns:\n            str: Extracted text.\n\n        Raises:\n            FileTypeNotSupportedError: If the file extension is not supported.\n            ExtractionError: If extraction fails.\n            RuntimeError: If extractor is closed.\n        \"\"\"\n        if self._closed:\n            raise RuntimeError(\"Extractor has been closed\")\n\n        file_info = get_file_info(file_bytes, filename)\n        temp_path = create_temp_file(\n            file_bytes, filename, config and config.get(\"max_file_size\")\n        )\n\n        logger.debug(\n            \"Temporary file created at %s for file info: %s\", temp_path, file_info\n        )\n\n        try:\n            suffix = Path(filename).suffix.lower()\n            logger.debug(\"Detected file suffix: %s\", suffix)\n\n            handler = registry.get_handler(suffix)\n            handler_name = handler.__class__.__name__\n\n            logger.info(\n                \"Using handler %s for file %s (size: %s MB)\",\n                handler_name,\n                filename,\n                file_info[\"size_mb\"],\n            )\n\n            loop = asyncio.get_running_loop()\n            try:\n                # Offload sync handler to thread pool for I/O-bound tasks\n                result = await loop.run_in_executor(\n                    self._executor,\n                    handler.extract,\n                    temp_path,\n                    config or self.config.__dict__,\n                )\n            except Exception as e:\n                from textxtract.core.exceptions import (\n                    ExtractionError,\n                    InvalidFileError,\n                )\n\n                logger.error(\n                    \"Extraction failed for file %s (handler: %s): %s\",\n                    filename,\n                    handler_name,\n                    e,\n                )\n\n                # If it's already a custom extraction error, re-raise\n                if isinstance(e, ExtractionError):\n                    raise\n                # If it's a known invalid file error, wrap it\n                if isinstance(e, (ValueError, OSError)):\n                    raise InvalidFileError(\n                        f\"Invalid file: {filename} (handler: {handler_name}, error: {e})\"\n                    ) from e\n                # Otherwise, wrap as general extraction error\n                raise ExtractionError(\n                    f\"Extraction failed for file {filename} using {handler_name}: {e}\"\n                ) from e\n\n            logger.info(\n                \"Extraction successful for file %s (extracted %d characters)\",\n                filename,\n                len(result),\n            )\n            return result\n        finally:\n            safe_unlink(temp_path)\n            logger.debug(\"Temporary file %s deleted\", temp_path)\n\n    def close(self):\n        \"\"\"Close the extractor and clean up resources.\"\"\"\n        if not self._closed:\n            self._cleanup()\n            self._closed = True\n\n    def _cleanup(self):\n        \"\"\"Internal cleanup method.\"\"\"\n        if hasattr(self, \"_executor\") and self._executor:\n            try:\n                self._executor.shutdown(wait=True, cancel_futures=True)\n                logger.debug(\"ThreadPoolExecutor shut down successfully\")\n            except Exception as e:\n                logger.warning(\"Error shutting down ThreadPoolExecutor: %s\", e)\n\n    def __enter__(self):\n        \"\"\"Context manager entry.\"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit.\"\"\"\n        self.close()\n\n    async def __aenter__(self):\n        \"\"\"Async context manager entry.\"\"\"\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Async context manager exit.\"\"\"\n        self.close()\n\n    def __del__(self):\n        \"\"\"Destructor to ensure cleanup.\"\"\"\n        if not self._closed:\n            self._cleanup()\n</code></pre>"},{"location":"reference/aio/#textxtract.aio.extractor.AsyncTextExtractor-attributes","title":"Attributes","text":"config <code>instance-attribute</code> <pre><code>config = config or ExtractorConfig()\n</code></pre>"},{"location":"reference/aio/#textxtract.aio.extractor.AsyncTextExtractor-functions","title":"Functions","text":"__aenter__ <code>async</code> <pre><code>__aenter__()\n</code></pre> <p>Async context manager entry.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def __aenter__(self):\n    \"\"\"Async context manager entry.\"\"\"\n    return self\n</code></pre> <code></code> __aexit__ <code>async</code> <pre><code>__aexit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Async context manager exit.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Async context manager exit.\"\"\"\n    self.close()\n</code></pre> <code></code> __del__ <pre><code>__del__()\n</code></pre> <p>Destructor to ensure cleanup.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __del__(self):\n    \"\"\"Destructor to ensure cleanup.\"\"\"\n    if not self._closed:\n        self._cleanup()\n</code></pre> <code></code> __enter__ <pre><code>__enter__()\n</code></pre> <p>Context manager entry.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    return self\n</code></pre> <code></code> __exit__ <pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Context manager exit.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    self.close()\n</code></pre> <code></code> __init__ <pre><code>__init__(config=None, max_workers=None)\n</code></pre> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __init__(\n    self,\n    config: Optional[ExtractorConfig] = None,\n    max_workers: Optional[int] = None,\n):\n    self.config = config or ExtractorConfig()\n    self._executor = ThreadPoolExecutor(max_workers=max_workers)\n    self._closed = False\n\n    # Register cleanup on exit\n    atexit.register(self._cleanup)\n\n    logger.debug(\n        \"AsyncTextExtractor initialized with config: %s, max_workers: %s\",\n        self.config.__dict__,\n        max_workers,\n    )\n</code></pre> <code></code> close <pre><code>close()\n</code></pre> <p>Close the extractor and clean up resources.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def close(self):\n    \"\"\"Close the extractor and clean up resources.\"\"\"\n    if not self._closed:\n        self._cleanup()\n        self._closed = True\n</code></pre> <code></code> extract <pre><code>extract(file_bytes, filename, config=None)\n</code></pre> <p>Sync interface for compatibility; delegates to async extract.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always, as async extractor requires async usage.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def extract(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"\n    Sync interface for compatibility; delegates to async extract.\n\n    Raises:\n        NotImplementedError: Always, as async extractor requires async usage.\n    \"\"\"\n    raise NotImplementedError(\n        \"Use extract_async() for asynchronous extraction or use SyncTextExtractor\"\n    )\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_bytes, filename, config=None)\n</code></pre> <p>Extract text asynchronously from file bytes using a thread pool.</p> <p>Parameters:</p> Name Type Description Default <code>file_bytes</code> <code>bytes</code> <p>The file content as bytes.</p> required <code>filename</code> <code>str</code> <p>The name of the file (used for extension).</p> required <code>config</code> <code>Optional[dict]</code> <p>Optional configuration overrides.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted text.</p> <p>Raises:</p> Type Description <code>FileTypeNotSupportedError</code> <p>If the file extension is not supported.</p> <code>ExtractionError</code> <p>If extraction fails.</p> <code>RuntimeError</code> <p>If extractor is closed.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def extract_async(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"\n    Extract text asynchronously from file bytes using a thread pool.\n\n    Args:\n        file_bytes (bytes): The file content as bytes.\n        filename (str): The name of the file (used for extension).\n        config (Optional[dict]): Optional configuration overrides.\n\n    Returns:\n        str: Extracted text.\n\n    Raises:\n        FileTypeNotSupportedError: If the file extension is not supported.\n        ExtractionError: If extraction fails.\n        RuntimeError: If extractor is closed.\n    \"\"\"\n    if self._closed:\n        raise RuntimeError(\"Extractor has been closed\")\n\n    file_info = get_file_info(file_bytes, filename)\n    temp_path = create_temp_file(\n        file_bytes, filename, config and config.get(\"max_file_size\")\n    )\n\n    logger.debug(\n        \"Temporary file created at %s for file info: %s\", temp_path, file_info\n    )\n\n    try:\n        suffix = Path(filename).suffix.lower()\n        logger.debug(\"Detected file suffix: %s\", suffix)\n\n        handler = registry.get_handler(suffix)\n        handler_name = handler.__class__.__name__\n\n        logger.info(\n            \"Using handler %s for file %s (size: %s MB)\",\n            handler_name,\n            filename,\n            file_info[\"size_mb\"],\n        )\n\n        loop = asyncio.get_running_loop()\n        try:\n            # Offload sync handler to thread pool for I/O-bound tasks\n            result = await loop.run_in_executor(\n                self._executor,\n                handler.extract,\n                temp_path,\n                config or self.config.__dict__,\n            )\n        except Exception as e:\n            from textxtract.core.exceptions import (\n                ExtractionError,\n                InvalidFileError,\n            )\n\n            logger.error(\n                \"Extraction failed for file %s (handler: %s): %s\",\n                filename,\n                handler_name,\n                e,\n            )\n\n            # If it's already a custom extraction error, re-raise\n            if isinstance(e, ExtractionError):\n                raise\n            # If it's a known invalid file error, wrap it\n            if isinstance(e, (ValueError, OSError)):\n                raise InvalidFileError(\n                    f\"Invalid file: {filename} (handler: {handler_name}, error: {e})\"\n                ) from e\n            # Otherwise, wrap as general extraction error\n            raise ExtractionError(\n                f\"Extraction failed for file {filename} using {handler_name}: {e}\"\n            ) from e\n\n        logger.info(\n            \"Extraction successful for file %s (extracted %d characters)\",\n            filename,\n            len(result),\n        )\n        return result\n    finally:\n        safe_unlink(temp_path)\n        logger.debug(\"Temporary file %s deleted\", temp_path)\n</code></pre>"},{"location":"reference/aio/#textxtract.aio.extractor-functions","title":"Functions","text":""},{"location":"reference/aio/__init__/","title":"Aio Module","text":"<p>Asynchronous extraction logic package.</p> <p>Modules:</p> Name Description <code>extractor</code> <p>Asynchronous text extraction logic.</p> <p>Classes:</p> Name Description <code>AsyncTextExtractor</code> <p>Asynchronous text extractor with proper resource management.</p>"},{"location":"reference/aio/__init__/#textxtract.aio-attributes","title":"Attributes","text":""},{"location":"reference/aio/__init__/#textxtract.aio.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['AsyncTextExtractor']\n</code></pre>"},{"location":"reference/aio/__init__/#textxtract.aio-classes","title":"Classes","text":""},{"location":"reference/aio/__init__/#textxtract.aio.AsyncTextExtractor","title":"AsyncTextExtractor","text":"<p>               Bases: <code>TextExtractor</code></p> <p>Asynchronous text extractor with proper resource management.</p> <p>Provides asynchronous text extraction from various file types. Logs debug and info level messages for tracing and diagnostics. Supports context manager protocol for proper cleanup.</p> <p>Methods:</p> Name Description <code>__aenter__</code> <p>Async context manager entry.</p> <code>__aexit__</code> <p>Async context manager exit.</p> <code>__del__</code> <p>Destructor to ensure cleanup.</p> <code>__enter__</code> <p>Context manager entry.</p> <code>__exit__</code> <p>Context manager exit.</p> <code>__init__</code> <code>close</code> <p>Close the extractor and clean up resources.</p> <code>extract</code> <p>Sync interface for compatibility; delegates to async extract.</p> <code>extract_async</code> <p>Extract text asynchronously from file bytes using a thread pool.</p> <p>Attributes:</p> Name Type Description <code>config</code> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>class AsyncTextExtractor(TextExtractor):\n    \"\"\"\n    Asynchronous text extractor with proper resource management.\n\n    Provides asynchronous text extraction from various file types.\n    Logs debug and info level messages for tracing and diagnostics.\n    Supports context manager protocol for proper cleanup.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: Optional[ExtractorConfig] = None,\n        max_workers: Optional[int] = None,\n    ):\n        self.config = config or ExtractorConfig()\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._closed = False\n\n        # Register cleanup on exit\n        atexit.register(self._cleanup)\n\n        logger.debug(\n            \"AsyncTextExtractor initialized with config: %s, max_workers: %s\",\n            self.config.__dict__,\n            max_workers,\n        )\n\n    def extract(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"\n        Sync interface for compatibility; delegates to async extract.\n\n        Raises:\n            NotImplementedError: Always, as async extractor requires async usage.\n        \"\"\"\n        raise NotImplementedError(\n            \"Use extract_async() for asynchronous extraction or use SyncTextExtractor\"\n        )\n\n    async def extract_async(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"\n        Extract text asynchronously from file bytes using a thread pool.\n\n        Args:\n            file_bytes (bytes): The file content as bytes.\n            filename (str): The name of the file (used for extension).\n            config (Optional[dict]): Optional configuration overrides.\n\n        Returns:\n            str: Extracted text.\n\n        Raises:\n            FileTypeNotSupportedError: If the file extension is not supported.\n            ExtractionError: If extraction fails.\n            RuntimeError: If extractor is closed.\n        \"\"\"\n        if self._closed:\n            raise RuntimeError(\"Extractor has been closed\")\n\n        file_info = get_file_info(file_bytes, filename)\n        temp_path = create_temp_file(\n            file_bytes, filename, config and config.get(\"max_file_size\")\n        )\n\n        logger.debug(\n            \"Temporary file created at %s for file info: %s\", temp_path, file_info\n        )\n\n        try:\n            suffix = Path(filename).suffix.lower()\n            logger.debug(\"Detected file suffix: %s\", suffix)\n\n            handler = registry.get_handler(suffix)\n            handler_name = handler.__class__.__name__\n\n            logger.info(\n                \"Using handler %s for file %s (size: %s MB)\",\n                handler_name,\n                filename,\n                file_info[\"size_mb\"],\n            )\n\n            loop = asyncio.get_running_loop()\n            try:\n                # Offload sync handler to thread pool for I/O-bound tasks\n                result = await loop.run_in_executor(\n                    self._executor,\n                    handler.extract,\n                    temp_path,\n                    config or self.config.__dict__,\n                )\n            except Exception as e:\n                from textxtract.core.exceptions import (\n                    ExtractionError,\n                    InvalidFileError,\n                )\n\n                logger.error(\n                    \"Extraction failed for file %s (handler: %s): %s\",\n                    filename,\n                    handler_name,\n                    e,\n                )\n\n                # If it's already a custom extraction error, re-raise\n                if isinstance(e, ExtractionError):\n                    raise\n                # If it's a known invalid file error, wrap it\n                if isinstance(e, (ValueError, OSError)):\n                    raise InvalidFileError(\n                        f\"Invalid file: {filename} (handler: {handler_name}, error: {e})\"\n                    ) from e\n                # Otherwise, wrap as general extraction error\n                raise ExtractionError(\n                    f\"Extraction failed for file {filename} using {handler_name}: {e}\"\n                ) from e\n\n            logger.info(\n                \"Extraction successful for file %s (extracted %d characters)\",\n                filename,\n                len(result),\n            )\n            return result\n        finally:\n            safe_unlink(temp_path)\n            logger.debug(\"Temporary file %s deleted\", temp_path)\n\n    def close(self):\n        \"\"\"Close the extractor and clean up resources.\"\"\"\n        if not self._closed:\n            self._cleanup()\n            self._closed = True\n\n    def _cleanup(self):\n        \"\"\"Internal cleanup method.\"\"\"\n        if hasattr(self, \"_executor\") and self._executor:\n            try:\n                self._executor.shutdown(wait=True, cancel_futures=True)\n                logger.debug(\"ThreadPoolExecutor shut down successfully\")\n            except Exception as e:\n                logger.warning(\"Error shutting down ThreadPoolExecutor: %s\", e)\n\n    def __enter__(self):\n        \"\"\"Context manager entry.\"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit.\"\"\"\n        self.close()\n\n    async def __aenter__(self):\n        \"\"\"Async context manager entry.\"\"\"\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Async context manager exit.\"\"\"\n        self.close()\n\n    def __del__(self):\n        \"\"\"Destructor to ensure cleanup.\"\"\"\n        if not self._closed:\n            self._cleanup()\n</code></pre>"},{"location":"reference/aio/__init__/#textxtract.aio.AsyncTextExtractor-attributes","title":"Attributes","text":""},{"location":"reference/aio/__init__/#textxtract.aio.AsyncTextExtractor.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = config or ExtractorConfig()\n</code></pre>"},{"location":"reference/aio/__init__/#textxtract.aio.AsyncTextExtractor-functions","title":"Functions","text":""},{"location":"reference/aio/__init__/#textxtract.aio.AsyncTextExtractor.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__()\n</code></pre> <p>Async context manager entry.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def __aenter__(self):\n    \"\"\"Async context manager entry.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/aio/__init__/#textxtract.aio.AsyncTextExtractor.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Async context manager exit.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Async context manager exit.\"\"\"\n    self.close()\n</code></pre>"},{"location":"reference/aio/__init__/#textxtract.aio.AsyncTextExtractor.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Destructor to ensure cleanup.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __del__(self):\n    \"\"\"Destructor to ensure cleanup.\"\"\"\n    if not self._closed:\n        self._cleanup()\n</code></pre>"},{"location":"reference/aio/__init__/#textxtract.aio.AsyncTextExtractor.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>Context manager entry.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/aio/__init__/#textxtract.aio.AsyncTextExtractor.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Context manager exit.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    self.close()\n</code></pre>"},{"location":"reference/aio/__init__/#textxtract.aio.AsyncTextExtractor.__init__","title":"__init__","text":"<pre><code>__init__(config=None, max_workers=None)\n</code></pre> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __init__(\n    self,\n    config: Optional[ExtractorConfig] = None,\n    max_workers: Optional[int] = None,\n):\n    self.config = config or ExtractorConfig()\n    self._executor = ThreadPoolExecutor(max_workers=max_workers)\n    self._closed = False\n\n    # Register cleanup on exit\n    atexit.register(self._cleanup)\n\n    logger.debug(\n        \"AsyncTextExtractor initialized with config: %s, max_workers: %s\",\n        self.config.__dict__,\n        max_workers,\n    )\n</code></pre>"},{"location":"reference/aio/__init__/#textxtract.aio.AsyncTextExtractor.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Close the extractor and clean up resources.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def close(self):\n    \"\"\"Close the extractor and clean up resources.\"\"\"\n    if not self._closed:\n        self._cleanup()\n        self._closed = True\n</code></pre>"},{"location":"reference/aio/__init__/#textxtract.aio.AsyncTextExtractor.extract","title":"extract","text":"<pre><code>extract(file_bytes, filename, config=None)\n</code></pre> <p>Sync interface for compatibility; delegates to async extract.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always, as async extractor requires async usage.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def extract(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"\n    Sync interface for compatibility; delegates to async extract.\n\n    Raises:\n        NotImplementedError: Always, as async extractor requires async usage.\n    \"\"\"\n    raise NotImplementedError(\n        \"Use extract_async() for asynchronous extraction or use SyncTextExtractor\"\n    )\n</code></pre>"},{"location":"reference/aio/__init__/#textxtract.aio.AsyncTextExtractor.extract_async","title":"extract_async  <code>async</code>","text":"<pre><code>extract_async(file_bytes, filename, config=None)\n</code></pre> <p>Extract text asynchronously from file bytes using a thread pool.</p> <p>Parameters:</p> Name Type Description Default <code>bytes</code> <p>The file content as bytes.</p> required <code>str</code> <p>The name of the file (used for extension).</p> required <code>Optional[dict]</code> <p>Optional configuration overrides.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted text.</p> <p>Raises:</p> Type Description <code>FileTypeNotSupportedError</code> <p>If the file extension is not supported.</p> <code>ExtractionError</code> <p>If extraction fails.</p> <code>RuntimeError</code> <p>If extractor is closed.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def extract_async(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"\n    Extract text asynchronously from file bytes using a thread pool.\n\n    Args:\n        file_bytes (bytes): The file content as bytes.\n        filename (str): The name of the file (used for extension).\n        config (Optional[dict]): Optional configuration overrides.\n\n    Returns:\n        str: Extracted text.\n\n    Raises:\n        FileTypeNotSupportedError: If the file extension is not supported.\n        ExtractionError: If extraction fails.\n        RuntimeError: If extractor is closed.\n    \"\"\"\n    if self._closed:\n        raise RuntimeError(\"Extractor has been closed\")\n\n    file_info = get_file_info(file_bytes, filename)\n    temp_path = create_temp_file(\n        file_bytes, filename, config and config.get(\"max_file_size\")\n    )\n\n    logger.debug(\n        \"Temporary file created at %s for file info: %s\", temp_path, file_info\n    )\n\n    try:\n        suffix = Path(filename).suffix.lower()\n        logger.debug(\"Detected file suffix: %s\", suffix)\n\n        handler = registry.get_handler(suffix)\n        handler_name = handler.__class__.__name__\n\n        logger.info(\n            \"Using handler %s for file %s (size: %s MB)\",\n            handler_name,\n            filename,\n            file_info[\"size_mb\"],\n        )\n\n        loop = asyncio.get_running_loop()\n        try:\n            # Offload sync handler to thread pool for I/O-bound tasks\n            result = await loop.run_in_executor(\n                self._executor,\n                handler.extract,\n                temp_path,\n                config or self.config.__dict__,\n            )\n        except Exception as e:\n            from textxtract.core.exceptions import (\n                ExtractionError,\n                InvalidFileError,\n            )\n\n            logger.error(\n                \"Extraction failed for file %s (handler: %s): %s\",\n                filename,\n                handler_name,\n                e,\n            )\n\n            # If it's already a custom extraction error, re-raise\n            if isinstance(e, ExtractionError):\n                raise\n            # If it's a known invalid file error, wrap it\n            if isinstance(e, (ValueError, OSError)):\n                raise InvalidFileError(\n                    f\"Invalid file: {filename} (handler: {handler_name}, error: {e})\"\n                ) from e\n            # Otherwise, wrap as general extraction error\n            raise ExtractionError(\n                f\"Extraction failed for file {filename} using {handler_name}: {e}\"\n            ) from e\n\n        logger.info(\n            \"Extraction successful for file %s (extracted %d characters)\",\n            filename,\n            len(result),\n        )\n        return result\n    finally:\n        safe_unlink(temp_path)\n        logger.debug(\"Temporary file %s deleted\", temp_path)\n</code></pre>"},{"location":"reference/aio/__init__/#textxtract.aio.AsyncTextExtractor.extract_async(file_bytes)","title":"<code>file_bytes</code>","text":""},{"location":"reference/aio/__init__/#textxtract.aio.AsyncTextExtractor.extract_async(filename)","title":"<code>filename</code>","text":""},{"location":"reference/aio/__init__/#textxtract.aio.AsyncTextExtractor.extract_async(config)","title":"<code>config</code>","text":""},{"location":"reference/aio/__init__/#textxtract.aio-modules","title":"Modules","text":""},{"location":"reference/aio/__init__/#textxtract.aio.extractor","title":"extractor","text":"<p>Asynchronous text extraction logic.</p> <p>Classes:</p> Name Description <code>AsyncTextExtractor</code> <p>Asynchronous text extractor with proper resource management.</p> <p>Attributes:</p> Name Type Description <code>logger</code>"},{"location":"reference/aio/__init__/#textxtract.aio.extractor-attributes","title":"Attributes","text":""},{"location":"reference/aio/__init__/#textxtract.aio.extractor.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger('textxtract.aio')\n</code></pre>"},{"location":"reference/aio/__init__/#textxtract.aio.extractor-classes","title":"Classes","text":""},{"location":"reference/aio/__init__/#textxtract.aio.extractor.AsyncTextExtractor","title":"AsyncTextExtractor","text":"<p>               Bases: <code>TextExtractor</code></p> <p>Asynchronous text extractor with proper resource management.</p> <p>Provides asynchronous text extraction from various file types. Logs debug and info level messages for tracing and diagnostics. Supports context manager protocol for proper cleanup.</p> <p>Methods:</p> Name Description <code>__aenter__</code> <p>Async context manager entry.</p> <code>__aexit__</code> <p>Async context manager exit.</p> <code>__del__</code> <p>Destructor to ensure cleanup.</p> <code>__enter__</code> <p>Context manager entry.</p> <code>__exit__</code> <p>Context manager exit.</p> <code>__init__</code> <code>close</code> <p>Close the extractor and clean up resources.</p> <code>extract</code> <p>Sync interface for compatibility; delegates to async extract.</p> <code>extract_async</code> <p>Extract text asynchronously from file bytes using a thread pool.</p> <p>Attributes:</p> Name Type Description <code>config</code> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>class AsyncTextExtractor(TextExtractor):\n    \"\"\"\n    Asynchronous text extractor with proper resource management.\n\n    Provides asynchronous text extraction from various file types.\n    Logs debug and info level messages for tracing and diagnostics.\n    Supports context manager protocol for proper cleanup.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: Optional[ExtractorConfig] = None,\n        max_workers: Optional[int] = None,\n    ):\n        self.config = config or ExtractorConfig()\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._closed = False\n\n        # Register cleanup on exit\n        atexit.register(self._cleanup)\n\n        logger.debug(\n            \"AsyncTextExtractor initialized with config: %s, max_workers: %s\",\n            self.config.__dict__,\n            max_workers,\n        )\n\n    def extract(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"\n        Sync interface for compatibility; delegates to async extract.\n\n        Raises:\n            NotImplementedError: Always, as async extractor requires async usage.\n        \"\"\"\n        raise NotImplementedError(\n            \"Use extract_async() for asynchronous extraction or use SyncTextExtractor\"\n        )\n\n    async def extract_async(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"\n        Extract text asynchronously from file bytes using a thread pool.\n\n        Args:\n            file_bytes (bytes): The file content as bytes.\n            filename (str): The name of the file (used for extension).\n            config (Optional[dict]): Optional configuration overrides.\n\n        Returns:\n            str: Extracted text.\n\n        Raises:\n            FileTypeNotSupportedError: If the file extension is not supported.\n            ExtractionError: If extraction fails.\n            RuntimeError: If extractor is closed.\n        \"\"\"\n        if self._closed:\n            raise RuntimeError(\"Extractor has been closed\")\n\n        file_info = get_file_info(file_bytes, filename)\n        temp_path = create_temp_file(\n            file_bytes, filename, config and config.get(\"max_file_size\")\n        )\n\n        logger.debug(\n            \"Temporary file created at %s for file info: %s\", temp_path, file_info\n        )\n\n        try:\n            suffix = Path(filename).suffix.lower()\n            logger.debug(\"Detected file suffix: %s\", suffix)\n\n            handler = registry.get_handler(suffix)\n            handler_name = handler.__class__.__name__\n\n            logger.info(\n                \"Using handler %s for file %s (size: %s MB)\",\n                handler_name,\n                filename,\n                file_info[\"size_mb\"],\n            )\n\n            loop = asyncio.get_running_loop()\n            try:\n                # Offload sync handler to thread pool for I/O-bound tasks\n                result = await loop.run_in_executor(\n                    self._executor,\n                    handler.extract,\n                    temp_path,\n                    config or self.config.__dict__,\n                )\n            except Exception as e:\n                from textxtract.core.exceptions import (\n                    ExtractionError,\n                    InvalidFileError,\n                )\n\n                logger.error(\n                    \"Extraction failed for file %s (handler: %s): %s\",\n                    filename,\n                    handler_name,\n                    e,\n                )\n\n                # If it's already a custom extraction error, re-raise\n                if isinstance(e, ExtractionError):\n                    raise\n                # If it's a known invalid file error, wrap it\n                if isinstance(e, (ValueError, OSError)):\n                    raise InvalidFileError(\n                        f\"Invalid file: {filename} (handler: {handler_name}, error: {e})\"\n                    ) from e\n                # Otherwise, wrap as general extraction error\n                raise ExtractionError(\n                    f\"Extraction failed for file {filename} using {handler_name}: {e}\"\n                ) from e\n\n            logger.info(\n                \"Extraction successful for file %s (extracted %d characters)\",\n                filename,\n                len(result),\n            )\n            return result\n        finally:\n            safe_unlink(temp_path)\n            logger.debug(\"Temporary file %s deleted\", temp_path)\n\n    def close(self):\n        \"\"\"Close the extractor and clean up resources.\"\"\"\n        if not self._closed:\n            self._cleanup()\n            self._closed = True\n\n    def _cleanup(self):\n        \"\"\"Internal cleanup method.\"\"\"\n        if hasattr(self, \"_executor\") and self._executor:\n            try:\n                self._executor.shutdown(wait=True, cancel_futures=True)\n                logger.debug(\"ThreadPoolExecutor shut down successfully\")\n            except Exception as e:\n                logger.warning(\"Error shutting down ThreadPoolExecutor: %s\", e)\n\n    def __enter__(self):\n        \"\"\"Context manager entry.\"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit.\"\"\"\n        self.close()\n\n    async def __aenter__(self):\n        \"\"\"Async context manager entry.\"\"\"\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Async context manager exit.\"\"\"\n        self.close()\n\n    def __del__(self):\n        \"\"\"Destructor to ensure cleanup.\"\"\"\n        if not self._closed:\n            self._cleanup()\n</code></pre>"},{"location":"reference/aio/__init__/#textxtract.aio.extractor.AsyncTextExtractor-attributes","title":"Attributes","text":"config <code>instance-attribute</code> <pre><code>config = config or ExtractorConfig()\n</code></pre>"},{"location":"reference/aio/__init__/#textxtract.aio.extractor.AsyncTextExtractor-functions","title":"Functions","text":"__aenter__ <code>async</code> <pre><code>__aenter__()\n</code></pre> <p>Async context manager entry.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def __aenter__(self):\n    \"\"\"Async context manager entry.\"\"\"\n    return self\n</code></pre> <code></code> __aexit__ <code>async</code> <pre><code>__aexit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Async context manager exit.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Async context manager exit.\"\"\"\n    self.close()\n</code></pre> <code></code> __del__ <pre><code>__del__()\n</code></pre> <p>Destructor to ensure cleanup.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __del__(self):\n    \"\"\"Destructor to ensure cleanup.\"\"\"\n    if not self._closed:\n        self._cleanup()\n</code></pre> <code></code> __enter__ <pre><code>__enter__()\n</code></pre> <p>Context manager entry.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    return self\n</code></pre> <code></code> __exit__ <pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Context manager exit.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    self.close()\n</code></pre> <code></code> __init__ <pre><code>__init__(config=None, max_workers=None)\n</code></pre> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __init__(\n    self,\n    config: Optional[ExtractorConfig] = None,\n    max_workers: Optional[int] = None,\n):\n    self.config = config or ExtractorConfig()\n    self._executor = ThreadPoolExecutor(max_workers=max_workers)\n    self._closed = False\n\n    # Register cleanup on exit\n    atexit.register(self._cleanup)\n\n    logger.debug(\n        \"AsyncTextExtractor initialized with config: %s, max_workers: %s\",\n        self.config.__dict__,\n        max_workers,\n    )\n</code></pre> <code></code> close <pre><code>close()\n</code></pre> <p>Close the extractor and clean up resources.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def close(self):\n    \"\"\"Close the extractor and clean up resources.\"\"\"\n    if not self._closed:\n        self._cleanup()\n        self._closed = True\n</code></pre> <code></code> extract <pre><code>extract(file_bytes, filename, config=None)\n</code></pre> <p>Sync interface for compatibility; delegates to async extract.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always, as async extractor requires async usage.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def extract(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"\n    Sync interface for compatibility; delegates to async extract.\n\n    Raises:\n        NotImplementedError: Always, as async extractor requires async usage.\n    \"\"\"\n    raise NotImplementedError(\n        \"Use extract_async() for asynchronous extraction or use SyncTextExtractor\"\n    )\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_bytes, filename, config=None)\n</code></pre> <p>Extract text asynchronously from file bytes using a thread pool.</p> <p>Parameters:</p> Name Type Description Default <code>file_bytes</code> <code>bytes</code> <p>The file content as bytes.</p> required <code>filename</code> <code>str</code> <p>The name of the file (used for extension).</p> required <code>config</code> <code>Optional[dict]</code> <p>Optional configuration overrides.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted text.</p> <p>Raises:</p> Type Description <code>FileTypeNotSupportedError</code> <p>If the file extension is not supported.</p> <code>ExtractionError</code> <p>If extraction fails.</p> <code>RuntimeError</code> <p>If extractor is closed.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def extract_async(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"\n    Extract text asynchronously from file bytes using a thread pool.\n\n    Args:\n        file_bytes (bytes): The file content as bytes.\n        filename (str): The name of the file (used for extension).\n        config (Optional[dict]): Optional configuration overrides.\n\n    Returns:\n        str: Extracted text.\n\n    Raises:\n        FileTypeNotSupportedError: If the file extension is not supported.\n        ExtractionError: If extraction fails.\n        RuntimeError: If extractor is closed.\n    \"\"\"\n    if self._closed:\n        raise RuntimeError(\"Extractor has been closed\")\n\n    file_info = get_file_info(file_bytes, filename)\n    temp_path = create_temp_file(\n        file_bytes, filename, config and config.get(\"max_file_size\")\n    )\n\n    logger.debug(\n        \"Temporary file created at %s for file info: %s\", temp_path, file_info\n    )\n\n    try:\n        suffix = Path(filename).suffix.lower()\n        logger.debug(\"Detected file suffix: %s\", suffix)\n\n        handler = registry.get_handler(suffix)\n        handler_name = handler.__class__.__name__\n\n        logger.info(\n            \"Using handler %s for file %s (size: %s MB)\",\n            handler_name,\n            filename,\n            file_info[\"size_mb\"],\n        )\n\n        loop = asyncio.get_running_loop()\n        try:\n            # Offload sync handler to thread pool for I/O-bound tasks\n            result = await loop.run_in_executor(\n                self._executor,\n                handler.extract,\n                temp_path,\n                config or self.config.__dict__,\n            )\n        except Exception as e:\n            from textxtract.core.exceptions import (\n                ExtractionError,\n                InvalidFileError,\n            )\n\n            logger.error(\n                \"Extraction failed for file %s (handler: %s): %s\",\n                filename,\n                handler_name,\n                e,\n            )\n\n            # If it's already a custom extraction error, re-raise\n            if isinstance(e, ExtractionError):\n                raise\n            # If it's a known invalid file error, wrap it\n            if isinstance(e, (ValueError, OSError)):\n                raise InvalidFileError(\n                    f\"Invalid file: {filename} (handler: {handler_name}, error: {e})\"\n                ) from e\n            # Otherwise, wrap as general extraction error\n            raise ExtractionError(\n                f\"Extraction failed for file {filename} using {handler_name}: {e}\"\n            ) from e\n\n        logger.info(\n            \"Extraction successful for file %s (extracted %d characters)\",\n            filename,\n            len(result),\n        )\n        return result\n    finally:\n        safe_unlink(temp_path)\n        logger.debug(\"Temporary file %s deleted\", temp_path)\n</code></pre>"},{"location":"reference/aio/__init__/#textxtract.aio.extractor-functions","title":"Functions","text":""},{"location":"reference/aio/extractor/","title":"Extractor Module","text":"<p>Asynchronous text extraction logic.</p> <p>Classes:</p> Name Description <code>AsyncTextExtractor</code> <p>Asynchronous text extractor with proper resource management.</p> <p>Attributes:</p> Name Type Description <code>logger</code>"},{"location":"reference/aio/extractor/#textxtract.aio.extractor-attributes","title":"Attributes","text":""},{"location":"reference/aio/extractor/#textxtract.aio.extractor.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger('textxtract.aio')\n</code></pre>"},{"location":"reference/aio/extractor/#textxtract.aio.extractor-classes","title":"Classes","text":""},{"location":"reference/aio/extractor/#textxtract.aio.extractor.AsyncTextExtractor","title":"AsyncTextExtractor","text":"<p>               Bases: <code>TextExtractor</code></p> <p>Asynchronous text extractor with proper resource management.</p> <p>Provides asynchronous text extraction from various file types. Logs debug and info level messages for tracing and diagnostics. Supports context manager protocol for proper cleanup.</p> <p>Methods:</p> Name Description <code>__aenter__</code> <p>Async context manager entry.</p> <code>__aexit__</code> <p>Async context manager exit.</p> <code>__del__</code> <p>Destructor to ensure cleanup.</p> <code>__enter__</code> <p>Context manager entry.</p> <code>__exit__</code> <p>Context manager exit.</p> <code>__init__</code> <code>close</code> <p>Close the extractor and clean up resources.</p> <code>extract</code> <p>Sync interface for compatibility; delegates to async extract.</p> <code>extract_async</code> <p>Extract text asynchronously from file bytes using a thread pool.</p> <p>Attributes:</p> Name Type Description <code>config</code> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>class AsyncTextExtractor(TextExtractor):\n    \"\"\"\n    Asynchronous text extractor with proper resource management.\n\n    Provides asynchronous text extraction from various file types.\n    Logs debug and info level messages for tracing and diagnostics.\n    Supports context manager protocol for proper cleanup.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: Optional[ExtractorConfig] = None,\n        max_workers: Optional[int] = None,\n    ):\n        self.config = config or ExtractorConfig()\n        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n        self._closed = False\n\n        # Register cleanup on exit\n        atexit.register(self._cleanup)\n\n        logger.debug(\n            \"AsyncTextExtractor initialized with config: %s, max_workers: %s\",\n            self.config.__dict__,\n            max_workers,\n        )\n\n    def extract(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"\n        Sync interface for compatibility; delegates to async extract.\n\n        Raises:\n            NotImplementedError: Always, as async extractor requires async usage.\n        \"\"\"\n        raise NotImplementedError(\n            \"Use extract_async() for asynchronous extraction or use SyncTextExtractor\"\n        )\n\n    async def extract_async(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"\n        Extract text asynchronously from file bytes using a thread pool.\n\n        Args:\n            file_bytes (bytes): The file content as bytes.\n            filename (str): The name of the file (used for extension).\n            config (Optional[dict]): Optional configuration overrides.\n\n        Returns:\n            str: Extracted text.\n\n        Raises:\n            FileTypeNotSupportedError: If the file extension is not supported.\n            ExtractionError: If extraction fails.\n            RuntimeError: If extractor is closed.\n        \"\"\"\n        if self._closed:\n            raise RuntimeError(\"Extractor has been closed\")\n\n        file_info = get_file_info(file_bytes, filename)\n        temp_path = create_temp_file(\n            file_bytes, filename, config and config.get(\"max_file_size\")\n        )\n\n        logger.debug(\n            \"Temporary file created at %s for file info: %s\", temp_path, file_info\n        )\n\n        try:\n            suffix = Path(filename).suffix.lower()\n            logger.debug(\"Detected file suffix: %s\", suffix)\n\n            handler = registry.get_handler(suffix)\n            handler_name = handler.__class__.__name__\n\n            logger.info(\n                \"Using handler %s for file %s (size: %s MB)\",\n                handler_name,\n                filename,\n                file_info[\"size_mb\"],\n            )\n\n            loop = asyncio.get_running_loop()\n            try:\n                # Offload sync handler to thread pool for I/O-bound tasks\n                result = await loop.run_in_executor(\n                    self._executor,\n                    handler.extract,\n                    temp_path,\n                    config or self.config.__dict__,\n                )\n            except Exception as e:\n                from textxtract.core.exceptions import (\n                    ExtractionError,\n                    InvalidFileError,\n                )\n\n                logger.error(\n                    \"Extraction failed for file %s (handler: %s): %s\",\n                    filename,\n                    handler_name,\n                    e,\n                )\n\n                # If it's already a custom extraction error, re-raise\n                if isinstance(e, ExtractionError):\n                    raise\n                # If it's a known invalid file error, wrap it\n                if isinstance(e, (ValueError, OSError)):\n                    raise InvalidFileError(\n                        f\"Invalid file: {filename} (handler: {handler_name}, error: {e})\"\n                    ) from e\n                # Otherwise, wrap as general extraction error\n                raise ExtractionError(\n                    f\"Extraction failed for file {filename} using {handler_name}: {e}\"\n                ) from e\n\n            logger.info(\n                \"Extraction successful for file %s (extracted %d characters)\",\n                filename,\n                len(result),\n            )\n            return result\n        finally:\n            safe_unlink(temp_path)\n            logger.debug(\"Temporary file %s deleted\", temp_path)\n\n    def close(self):\n        \"\"\"Close the extractor and clean up resources.\"\"\"\n        if not self._closed:\n            self._cleanup()\n            self._closed = True\n\n    def _cleanup(self):\n        \"\"\"Internal cleanup method.\"\"\"\n        if hasattr(self, \"_executor\") and self._executor:\n            try:\n                self._executor.shutdown(wait=True, cancel_futures=True)\n                logger.debug(\"ThreadPoolExecutor shut down successfully\")\n            except Exception as e:\n                logger.warning(\"Error shutting down ThreadPoolExecutor: %s\", e)\n\n    def __enter__(self):\n        \"\"\"Context manager entry.\"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit.\"\"\"\n        self.close()\n\n    async def __aenter__(self):\n        \"\"\"Async context manager entry.\"\"\"\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Async context manager exit.\"\"\"\n        self.close()\n\n    def __del__(self):\n        \"\"\"Destructor to ensure cleanup.\"\"\"\n        if not self._closed:\n            self._cleanup()\n</code></pre>"},{"location":"reference/aio/extractor/#textxtract.aio.extractor.AsyncTextExtractor-attributes","title":"Attributes","text":""},{"location":"reference/aio/extractor/#textxtract.aio.extractor.AsyncTextExtractor.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = config or ExtractorConfig()\n</code></pre>"},{"location":"reference/aio/extractor/#textxtract.aio.extractor.AsyncTextExtractor-functions","title":"Functions","text":""},{"location":"reference/aio/extractor/#textxtract.aio.extractor.AsyncTextExtractor.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__()\n</code></pre> <p>Async context manager entry.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def __aenter__(self):\n    \"\"\"Async context manager entry.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/aio/extractor/#textxtract.aio.extractor.AsyncTextExtractor.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Async context manager exit.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Async context manager exit.\"\"\"\n    self.close()\n</code></pre>"},{"location":"reference/aio/extractor/#textxtract.aio.extractor.AsyncTextExtractor.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Destructor to ensure cleanup.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __del__(self):\n    \"\"\"Destructor to ensure cleanup.\"\"\"\n    if not self._closed:\n        self._cleanup()\n</code></pre>"},{"location":"reference/aio/extractor/#textxtract.aio.extractor.AsyncTextExtractor.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>Context manager entry.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/aio/extractor/#textxtract.aio.extractor.AsyncTextExtractor.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Context manager exit.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    self.close()\n</code></pre>"},{"location":"reference/aio/extractor/#textxtract.aio.extractor.AsyncTextExtractor.__init__","title":"__init__","text":"<pre><code>__init__(config=None, max_workers=None)\n</code></pre> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def __init__(\n    self,\n    config: Optional[ExtractorConfig] = None,\n    max_workers: Optional[int] = None,\n):\n    self.config = config or ExtractorConfig()\n    self._executor = ThreadPoolExecutor(max_workers=max_workers)\n    self._closed = False\n\n    # Register cleanup on exit\n    atexit.register(self._cleanup)\n\n    logger.debug(\n        \"AsyncTextExtractor initialized with config: %s, max_workers: %s\",\n        self.config.__dict__,\n        max_workers,\n    )\n</code></pre>"},{"location":"reference/aio/extractor/#textxtract.aio.extractor.AsyncTextExtractor.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Close the extractor and clean up resources.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def close(self):\n    \"\"\"Close the extractor and clean up resources.\"\"\"\n    if not self._closed:\n        self._cleanup()\n        self._closed = True\n</code></pre>"},{"location":"reference/aio/extractor/#textxtract.aio.extractor.AsyncTextExtractor.extract","title":"extract","text":"<pre><code>extract(file_bytes, filename, config=None)\n</code></pre> <p>Sync interface for compatibility; delegates to async extract.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always, as async extractor requires async usage.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>def extract(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"\n    Sync interface for compatibility; delegates to async extract.\n\n    Raises:\n        NotImplementedError: Always, as async extractor requires async usage.\n    \"\"\"\n    raise NotImplementedError(\n        \"Use extract_async() for asynchronous extraction or use SyncTextExtractor\"\n    )\n</code></pre>"},{"location":"reference/aio/extractor/#textxtract.aio.extractor.AsyncTextExtractor.extract_async","title":"extract_async  <code>async</code>","text":"<pre><code>extract_async(file_bytes, filename, config=None)\n</code></pre> <p>Extract text asynchronously from file bytes using a thread pool.</p> <p>Parameters:</p> Name Type Description Default <code>bytes</code> <p>The file content as bytes.</p> required <code>str</code> <p>The name of the file (used for extension).</p> required <code>Optional[dict]</code> <p>Optional configuration overrides.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted text.</p> <p>Raises:</p> Type Description <code>FileTypeNotSupportedError</code> <p>If the file extension is not supported.</p> <code>ExtractionError</code> <p>If extraction fails.</p> <code>RuntimeError</code> <p>If extractor is closed.</p> Source code in <code>textxtract/aio/extractor.py</code> <pre><code>async def extract_async(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"\n    Extract text asynchronously from file bytes using a thread pool.\n\n    Args:\n        file_bytes (bytes): The file content as bytes.\n        filename (str): The name of the file (used for extension).\n        config (Optional[dict]): Optional configuration overrides.\n\n    Returns:\n        str: Extracted text.\n\n    Raises:\n        FileTypeNotSupportedError: If the file extension is not supported.\n        ExtractionError: If extraction fails.\n        RuntimeError: If extractor is closed.\n    \"\"\"\n    if self._closed:\n        raise RuntimeError(\"Extractor has been closed\")\n\n    file_info = get_file_info(file_bytes, filename)\n    temp_path = create_temp_file(\n        file_bytes, filename, config and config.get(\"max_file_size\")\n    )\n\n    logger.debug(\n        \"Temporary file created at %s for file info: %s\", temp_path, file_info\n    )\n\n    try:\n        suffix = Path(filename).suffix.lower()\n        logger.debug(\"Detected file suffix: %s\", suffix)\n\n        handler = registry.get_handler(suffix)\n        handler_name = handler.__class__.__name__\n\n        logger.info(\n            \"Using handler %s for file %s (size: %s MB)\",\n            handler_name,\n            filename,\n            file_info[\"size_mb\"],\n        )\n\n        loop = asyncio.get_running_loop()\n        try:\n            # Offload sync handler to thread pool for I/O-bound tasks\n            result = await loop.run_in_executor(\n                self._executor,\n                handler.extract,\n                temp_path,\n                config or self.config.__dict__,\n            )\n        except Exception as e:\n            from textxtract.core.exceptions import (\n                ExtractionError,\n                InvalidFileError,\n            )\n\n            logger.error(\n                \"Extraction failed for file %s (handler: %s): %s\",\n                filename,\n                handler_name,\n                e,\n            )\n\n            # If it's already a custom extraction error, re-raise\n            if isinstance(e, ExtractionError):\n                raise\n            # If it's a known invalid file error, wrap it\n            if isinstance(e, (ValueError, OSError)):\n                raise InvalidFileError(\n                    f\"Invalid file: {filename} (handler: {handler_name}, error: {e})\"\n                ) from e\n            # Otherwise, wrap as general extraction error\n            raise ExtractionError(\n                f\"Extraction failed for file {filename} using {handler_name}: {e}\"\n            ) from e\n\n        logger.info(\n            \"Extraction successful for file %s (extracted %d characters)\",\n            filename,\n            len(result),\n        )\n        return result\n    finally:\n        safe_unlink(temp_path)\n        logger.debug(\"Temporary file %s deleted\", temp_path)\n</code></pre>"},{"location":"reference/aio/extractor/#textxtract.aio.extractor.AsyncTextExtractor.extract_async(file_bytes)","title":"<code>file_bytes</code>","text":""},{"location":"reference/aio/extractor/#textxtract.aio.extractor.AsyncTextExtractor.extract_async(filename)","title":"<code>filename</code>","text":""},{"location":"reference/aio/extractor/#textxtract.aio.extractor.AsyncTextExtractor.extract_async(config)","title":"<code>config</code>","text":""},{"location":"reference/aio/extractor/#textxtract.aio.extractor-functions","title":"Functions","text":""},{"location":"reference/core/","title":"Core Module","text":""},{"location":"reference/core/#overview","title":"Overview","text":"<p>Core components of the text extraction framework.</p> <ul> <li>Base Classes - Abstract base classes</li> <li>Configuration - Configuration management</li> <li>Exceptions - Custom exceptions</li> <li>Registry - Handler registry</li> <li>Utils - Utility functions</li> </ul> <p>Core components for textxtract package.</p> <p>Modules:</p> Name Description <code>base</code> <p>Abstract base classes for text extraction.</p> <code>config</code> <p>Configuration and customization for textxtract package.</p> <code>exceptions</code> <p>Custom exceptions for textxtract package.</p> <code>logging_config</code> <p>Logging configuration for textxtract package.</p> <code>registry</code> <p>Handler registry for centralized handler management.</p> <code>utils</code> <p>Utility functions for textxtract package.</p>"},{"location":"reference/core/#textxtract.core-modules","title":"Modules","text":""},{"location":"reference/core/#textxtract.core.base","title":"base","text":"<p>Abstract base classes for text extraction.</p> <p>Classes:</p> Name Description <code>FileTypeHandler</code> <p>Abstract base class for file type-specific handlers.</p> <code>TextExtractor</code> <p>Abstract base class for text extractors.</p>"},{"location":"reference/core/#textxtract.core.base-classes","title":"Classes","text":""},{"location":"reference/core/#textxtract.core.base.FileTypeHandler","title":"FileTypeHandler","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for file type-specific handlers.</p> <p>Methods:</p> Name Description <code>extract</code> <p>Extract text synchronously from a file.</p> <code>extract_async</code> <p>Extract text asynchronously from a file.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>class FileTypeHandler(ABC):\n    \"\"\"Abstract base class for file type-specific handlers.\"\"\"\n\n    @abstractmethod\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        \"\"\"Extract text synchronously from a file.\"\"\"\n        pass\n\n    @abstractmethod\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"Extract text asynchronously from a file.\"\"\"\n        pass\n</code></pre>"},{"location":"reference/core/#textxtract.core.base.FileTypeHandler-functions","title":"Functions","text":"extract <code>abstractmethod</code> <pre><code>extract(file_path, config=None)\n</code></pre> <p>Extract text synchronously from a file.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>@abstractmethod\ndef extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    \"\"\"Extract text synchronously from a file.\"\"\"\n    pass\n</code></pre> <code></code> extract_async <code>abstractmethod</code> <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> <p>Extract text asynchronously from a file.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>@abstractmethod\nasync def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"Extract text asynchronously from a file.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/#textxtract.core.base.TextExtractor","title":"TextExtractor","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for text extractors.</p> <p>Methods:</p> Name Description <code>extract</code> <p>Extract text synchronously from file bytes.</p> <code>extract_async</code> <p>Extract text asynchronously from file bytes.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>class TextExtractor(ABC):\n    \"\"\"Abstract base class for text extractors.\"\"\"\n\n    @abstractmethod\n    def extract(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"Extract text synchronously from file bytes.\"\"\"\n        pass\n\n    @abstractmethod\n    async def extract_async(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"Extract text asynchronously from file bytes.\"\"\"\n        pass\n</code></pre>"},{"location":"reference/core/#textxtract.core.base.TextExtractor-functions","title":"Functions","text":"extract <code>abstractmethod</code> <pre><code>extract(file_bytes, filename, config=None)\n</code></pre> <p>Extract text synchronously from file bytes.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>@abstractmethod\ndef extract(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"Extract text synchronously from file bytes.\"\"\"\n    pass\n</code></pre> <code></code> extract_async <code>abstractmethod</code> <code>async</code> <pre><code>extract_async(file_bytes, filename, config=None)\n</code></pre> <p>Extract text asynchronously from file bytes.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>@abstractmethod\nasync def extract_async(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"Extract text asynchronously from file bytes.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/#textxtract.core.config","title":"config","text":"<p>Configuration and customization for textxtract package.</p> <p>Classes:</p> Name Description <code>ExtractorConfig</code> <p>Enhanced configuration options for text extraction with validation.</p>"},{"location":"reference/core/#textxtract.core.config-classes","title":"Classes","text":""},{"location":"reference/core/#textxtract.core.config.ExtractorConfig","title":"ExtractorConfig","text":"<p>Enhanced configuration options for text extraction with validation.</p> <p>Methods:</p> Name Description <code>__init__</code> <code>__repr__</code> <code>from_file</code> <p>Load configuration from a file (JSON, YAML, or TOML).</p> <code>get_handler</code> <p>Retrieve a handler for a given file extension.</p> <code>get_handler_config</code> <p>Get configuration specific to a handler.</p> <code>register_handler</code> <p>Register a custom file type handler.</p> <code>to_dict</code> <p>Convert configuration to dictionary.</p> <p>Attributes:</p> Name Type Description <code>custom_handlers</code> <code>encoding</code> <code>extra_config</code> <code>logging_format</code> <code>logging_level</code> <code>max_file_size</code> <code>max_memory_usage</code> <code>timeout</code> Source code in <code>textxtract/core/config.py</code> <pre><code>class ExtractorConfig:\n    \"\"\"Enhanced configuration options for text extraction with validation.\"\"\"\n\n    def __init__(\n        self,\n        encoding: str = \"utf-8\",\n        logging_level: str = \"INFO\",\n        logging_format: Optional[str] = None,\n        timeout: Optional[float] = None,\n        max_file_size: Optional[int] = None,\n        max_memory_usage: Optional[int] = None,\n        custom_handlers: Optional[Dict[str, Callable]] = None,\n        **kwargs,\n    ):\n        # Validate and set basic options\n        self.encoding = self._validate_encoding(encoding)\n        self.logging_level = self._validate_logging_level(logging_level)\n        self.logging_format = (\n            logging_format or \"%(asctime)s %(levelname)s %(name)s: %(message)s\"\n        )\n        self.timeout = self._validate_timeout(timeout)\n        self.max_file_size = self._validate_max_file_size(max_file_size)\n        self.max_memory_usage = max_memory_usage\n        self.custom_handlers = custom_handlers or {}\n\n        # Load from environment variables\n        self._load_from_env()\n\n        # Store additional kwargs for handler-specific config\n        self.extra_config = kwargs\n\n    def _validate_encoding(self, encoding: str) -&gt; str:\n        \"\"\"Validate encoding parameter.\"\"\"\n        if not isinstance(encoding, str):\n            raise ValueError(\"Encoding must be a string\")\n\n        # Test if encoding is valid\n        try:\n            \"test\".encode(encoding)\n        except LookupError:\n            raise ValueError(f\"Invalid encoding: {encoding}\")\n\n        return encoding\n\n    def _validate_logging_level(self, level: str) -&gt; str:\n        \"\"\"Validate logging level parameter.\"\"\"\n        valid_levels = {\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"}\n        if level.upper() not in valid_levels:\n            raise ValueError(\n                f\"Invalid logging level: {level}. Must be one of {valid_levels}\"\n            )\n        return level.upper()\n\n    def _validate_timeout(self, timeout: Optional[float]) -&gt; Optional[float]:\n        \"\"\"Validate timeout parameter.\"\"\"\n        if timeout is not None:\n            if not isinstance(timeout, (int, float)) or timeout &lt;= 0:\n                raise ValueError(\"Timeout must be a positive number\")\n        return timeout\n\n    def _validate_max_file_size(self, size: Optional[int]) -&gt; Optional[int]:\n        \"\"\"Validate max file size parameter.\"\"\"\n        if size is not None:\n            if not isinstance(size, int) or size &lt;= 0:\n                raise ValueError(\"Max file size must be a positive integer\")\n        return size\n\n    def _load_from_env(self):\n        \"\"\"Load configuration from environment variables.\"\"\"\n        # Override with environment variables if present\n        env_encoding = os.getenv(\"TEXT_EXTRACTOR_ENCODING\")\n        if env_encoding:\n            self.encoding = self._validate_encoding(env_encoding)\n\n        env_logging = os.getenv(\"TEXT_EXTRACTOR_LOG_LEVEL\")\n        if env_logging:\n            self.logging_level = self._validate_logging_level(env_logging)\n\n        env_timeout = os.getenv(\"TEXT_EXTRACTOR_TIMEOUT\")\n        if env_timeout:\n            try:\n                self.timeout = float(env_timeout)\n            except ValueError:\n                pass  # Ignore invalid values\n\n        env_max_size = os.getenv(\"TEXT_EXTRACTOR_MAX_FILE_SIZE\")\n        if env_max_size:\n            try:\n                self.max_file_size = int(env_max_size)\n            except ValueError:\n                pass  # Ignore invalid values\n\n    def register_handler(self, extension: str, handler: Callable):\n        \"\"\"Register a custom file type handler.\"\"\"\n        if not extension.startswith(\".\"):\n            extension = f\".{extension}\"\n        self.custom_handlers[extension.lower()] = handler\n\n    def get_handler(self, extension: str) -&gt; Optional[Callable]:\n        \"\"\"Retrieve a handler for a given file extension.\"\"\"\n        return self.custom_handlers.get(extension.lower())\n\n    def get_handler_config(self, handler_name: str) -&gt; Dict[str, Any]:\n        \"\"\"Get configuration specific to a handler.\"\"\"\n        base_config = {\n            \"encoding\": self.encoding,\n            \"timeout\": self.timeout,\n            \"max_file_size\": self.max_file_size,\n            \"max_memory_usage\": self.max_memory_usage,\n        }\n\n        # Add handler-specific config\n        handler_config_key = f\"{handler_name.lower()}_config\"\n        if handler_config_key in self.extra_config:\n            base_config.update(self.extra_config[handler_config_key])\n\n        return base_config\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert configuration to dictionary.\"\"\"\n        return {\n            \"encoding\": self.encoding,\n            \"logging_level\": self.logging_level,\n            \"logging_format\": self.logging_format,\n            \"timeout\": self.timeout,\n            \"max_file_size\": self.max_file_size,\n            \"max_memory_usage\": self.max_memory_usage,\n            \"custom_handlers\": {k: str(v) for k, v in self.custom_handlers.items()},\n            **self.extra_config,\n        }\n\n    @classmethod\n    def from_file(cls, config_path: Union[str, Path]) -&gt; \"ExtractorConfig\":\n        \"\"\"Load configuration from a file (JSON, YAML, or TOML).\"\"\"\n        config_path = Path(config_path)\n\n        if not config_path.exists():\n            raise FileNotFoundError(f\"Configuration file not found: {config_path}\")\n\n        content = config_path.read_text()\n\n        if config_path.suffix.lower() == \".json\":\n            import json\n\n            config_data = json.loads(content)\n        elif config_path.suffix.lower() in (\".yaml\", \".yml\"):\n            try:\n                import yaml\n\n                config_data = yaml.safe_load(content)\n            except ImportError:\n                raise ImportError(\"PyYAML is required to load YAML configuration files\")\n        elif config_path.suffix.lower() == \".toml\":\n            try:\n                import tomli\n\n                config_data = tomli.loads(content)\n            except ImportError:\n                raise ImportError(\"tomli is required to load TOML configuration files\")\n        else:\n            raise ValueError(\n                f\"Unsupported configuration file format: {config_path.suffix}\"\n            )\n\n        return cls(**config_data)\n\n    def __repr__(self) -&gt; str:\n        return f\"ExtractorConfig(encoding='{self.encoding}', logging_level='{self.logging_level}', timeout={self.timeout})\"\n</code></pre>"},{"location":"reference/core/#textxtract.core.config.ExtractorConfig-attributes","title":"Attributes","text":"custom_handlers <code>instance-attribute</code> <pre><code>custom_handlers = custom_handlers or {}\n</code></pre> <code></code> encoding <code>instance-attribute</code> <pre><code>encoding = _validate_encoding(encoding)\n</code></pre> <code></code> extra_config <code>instance-attribute</code> <pre><code>extra_config = kwargs\n</code></pre> <code></code> logging_format <code>instance-attribute</code> <pre><code>logging_format = logging_format or '%(asctime)s %(levelname)s %(name)s: %(message)s'\n</code></pre> <code></code> logging_level <code>instance-attribute</code> <pre><code>logging_level = _validate_logging_level(logging_level)\n</code></pre> <code></code> max_file_size <code>instance-attribute</code> <pre><code>max_file_size = _validate_max_file_size(max_file_size)\n</code></pre> <code></code> max_memory_usage <code>instance-attribute</code> <pre><code>max_memory_usage = max_memory_usage\n</code></pre> <code></code> timeout <code>instance-attribute</code> <pre><code>timeout = _validate_timeout(timeout)\n</code></pre>"},{"location":"reference/core/#textxtract.core.config.ExtractorConfig-functions","title":"Functions","text":"__init__ <pre><code>__init__(encoding='utf-8', logging_level='INFO', logging_format=None, timeout=None, max_file_size=None, max_memory_usage=None, custom_handlers=None, **kwargs)\n</code></pre> Source code in <code>textxtract/core/config.py</code> <pre><code>def __init__(\n    self,\n    encoding: str = \"utf-8\",\n    logging_level: str = \"INFO\",\n    logging_format: Optional[str] = None,\n    timeout: Optional[float] = None,\n    max_file_size: Optional[int] = None,\n    max_memory_usage: Optional[int] = None,\n    custom_handlers: Optional[Dict[str, Callable]] = None,\n    **kwargs,\n):\n    # Validate and set basic options\n    self.encoding = self._validate_encoding(encoding)\n    self.logging_level = self._validate_logging_level(logging_level)\n    self.logging_format = (\n        logging_format or \"%(asctime)s %(levelname)s %(name)s: %(message)s\"\n    )\n    self.timeout = self._validate_timeout(timeout)\n    self.max_file_size = self._validate_max_file_size(max_file_size)\n    self.max_memory_usage = max_memory_usage\n    self.custom_handlers = custom_handlers or {}\n\n    # Load from environment variables\n    self._load_from_env()\n\n    # Store additional kwargs for handler-specific config\n    self.extra_config = kwargs\n</code></pre> <code></code> __repr__ <pre><code>__repr__()\n</code></pre> Source code in <code>textxtract/core/config.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f\"ExtractorConfig(encoding='{self.encoding}', logging_level='{self.logging_level}', timeout={self.timeout})\"\n</code></pre> <code></code> from_file <code>classmethod</code> <pre><code>from_file(config_path)\n</code></pre> <p>Load configuration from a file (JSON, YAML, or TOML).</p> Source code in <code>textxtract/core/config.py</code> <pre><code>@classmethod\ndef from_file(cls, config_path: Union[str, Path]) -&gt; \"ExtractorConfig\":\n    \"\"\"Load configuration from a file (JSON, YAML, or TOML).\"\"\"\n    config_path = Path(config_path)\n\n    if not config_path.exists():\n        raise FileNotFoundError(f\"Configuration file not found: {config_path}\")\n\n    content = config_path.read_text()\n\n    if config_path.suffix.lower() == \".json\":\n        import json\n\n        config_data = json.loads(content)\n    elif config_path.suffix.lower() in (\".yaml\", \".yml\"):\n        try:\n            import yaml\n\n            config_data = yaml.safe_load(content)\n        except ImportError:\n            raise ImportError(\"PyYAML is required to load YAML configuration files\")\n    elif config_path.suffix.lower() == \".toml\":\n        try:\n            import tomli\n\n            config_data = tomli.loads(content)\n        except ImportError:\n            raise ImportError(\"tomli is required to load TOML configuration files\")\n    else:\n        raise ValueError(\n            f\"Unsupported configuration file format: {config_path.suffix}\"\n        )\n\n    return cls(**config_data)\n</code></pre> <code></code> get_handler <pre><code>get_handler(extension)\n</code></pre> <p>Retrieve a handler for a given file extension.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def get_handler(self, extension: str) -&gt; Optional[Callable]:\n    \"\"\"Retrieve a handler for a given file extension.\"\"\"\n    return self.custom_handlers.get(extension.lower())\n</code></pre> <code></code> get_handler_config <pre><code>get_handler_config(handler_name)\n</code></pre> <p>Get configuration specific to a handler.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def get_handler_config(self, handler_name: str) -&gt; Dict[str, Any]:\n    \"\"\"Get configuration specific to a handler.\"\"\"\n    base_config = {\n        \"encoding\": self.encoding,\n        \"timeout\": self.timeout,\n        \"max_file_size\": self.max_file_size,\n        \"max_memory_usage\": self.max_memory_usage,\n    }\n\n    # Add handler-specific config\n    handler_config_key = f\"{handler_name.lower()}_config\"\n    if handler_config_key in self.extra_config:\n        base_config.update(self.extra_config[handler_config_key])\n\n    return base_config\n</code></pre> <code></code> register_handler <pre><code>register_handler(extension, handler)\n</code></pre> <p>Register a custom file type handler.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def register_handler(self, extension: str, handler: Callable):\n    \"\"\"Register a custom file type handler.\"\"\"\n    if not extension.startswith(\".\"):\n        extension = f\".{extension}\"\n    self.custom_handlers[extension.lower()] = handler\n</code></pre> <code></code> to_dict <pre><code>to_dict()\n</code></pre> <p>Convert configuration to dictionary.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert configuration to dictionary.\"\"\"\n    return {\n        \"encoding\": self.encoding,\n        \"logging_level\": self.logging_level,\n        \"logging_format\": self.logging_format,\n        \"timeout\": self.timeout,\n        \"max_file_size\": self.max_file_size,\n        \"max_memory_usage\": self.max_memory_usage,\n        \"custom_handlers\": {k: str(v) for k, v in self.custom_handlers.items()},\n        **self.extra_config,\n    }\n</code></pre>"},{"location":"reference/core/#textxtract.core.exceptions","title":"exceptions","text":"<p>Custom exceptions for textxtract package.</p> <p>Classes:</p> Name Description <code>ExtractionError</code> <p>Raised when a general extraction error occurs.</p> <code>ExtractionTimeoutError</code> <p>Raised when extraction exceeds the allowed timeout.</p> <code>FileTypeNotSupportedError</code> <p>Raised when the file type is not supported.</p> <code>InvalidFileError</code> <p>Raised when the file is invalid or unsupported.</p>"},{"location":"reference/core/#textxtract.core.exceptions-classes","title":"Classes","text":""},{"location":"reference/core/#textxtract.core.exceptions.ExtractionError","title":"ExtractionError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when a general extraction error occurs.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class ExtractionError(Exception):\n    \"\"\"Raised when a general extraction error occurs.\"\"\"\n</code></pre>"},{"location":"reference/core/#textxtract.core.exceptions.ExtractionTimeoutError","title":"ExtractionTimeoutError","text":"<p>               Bases: <code>ExtractionError</code></p> <p>Raised when extraction exceeds the allowed timeout.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class ExtractionTimeoutError(ExtractionError):\n    \"\"\"Raised when extraction exceeds the allowed timeout.\"\"\"\n</code></pre>"},{"location":"reference/core/#textxtract.core.exceptions.FileTypeNotSupportedError","title":"FileTypeNotSupportedError","text":"<p>               Bases: <code>ExtractionError</code></p> <p>Raised when the file type is not supported.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class FileTypeNotSupportedError(ExtractionError):\n    \"\"\"Raised when the file type is not supported.\"\"\"\n</code></pre>"},{"location":"reference/core/#textxtract.core.exceptions.InvalidFileError","title":"InvalidFileError","text":"<p>               Bases: <code>ExtractionError</code></p> <p>Raised when the file is invalid or unsupported.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class InvalidFileError(ExtractionError):\n    \"\"\"Raised when the file is invalid or unsupported.\"\"\"\n</code></pre>"},{"location":"reference/core/#textxtract.core.logging_config","title":"logging_config","text":"<p>Logging configuration for textxtract package.</p> <p>Functions:</p> Name Description <code>setup_logging</code> <p>Configure logging for the package.</p>"},{"location":"reference/core/#textxtract.core.logging_config-functions","title":"Functions","text":""},{"location":"reference/core/#textxtract.core.logging_config.setup_logging","title":"setup_logging","text":"<pre><code>setup_logging(level='INFO', fmt='%(asctime)s %(levelname)s %(name)s: %(message)s')\n</code></pre> <p>Configure logging for the package.</p> Source code in <code>textxtract/core/logging_config.py</code> <pre><code>def setup_logging(\n    level: str = \"INFO\", fmt: str = \"%(asctime)s %(levelname)s %(name)s: %(message)s\"\n):\n    \"\"\"Configure logging for the package.\"\"\"\n    logging.basicConfig(level=getattr(logging, level.upper(), logging.INFO), format=fmt)\n</code></pre>"},{"location":"reference/core/#textxtract.core.registry","title":"registry","text":"<p>Handler registry for centralized handler management.</p> <p>Classes:</p> Name Description <code>HandlerRegistry</code> <p>Central registry for file type handlers with caching and lazy loading.</p> <p>Attributes:</p> Name Type Description <code>logger</code> <code>registry</code>"},{"location":"reference/core/#textxtract.core.registry-attributes","title":"Attributes","text":""},{"location":"reference/core/#textxtract.core.registry.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger('textxtract.registry')\n</code></pre>"},{"location":"reference/core/#textxtract.core.registry.registry","title":"registry  <code>module-attribute</code>","text":"<pre><code>registry = HandlerRegistry()\n</code></pre>"},{"location":"reference/core/#textxtract.core.registry-classes","title":"Classes","text":""},{"location":"reference/core/#textxtract.core.registry.HandlerRegistry","title":"HandlerRegistry","text":"<p>Central registry for file type handlers with caching and lazy loading.</p> <p>Methods:</p> Name Description <code>__init__</code> <code>__new__</code> <code>get_handler</code> <p>Get handler instance for file extension with caching.</p> <code>get_supported_extensions</code> <p>Get list of all supported file extensions.</p> <code>is_supported</code> <p>Check if a file extension is supported.</p> <code>register_handler</code> <p>Register a custom handler for a file extension.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>class HandlerRegistry:\n    \"\"\"Central registry for file type handlers with caching and lazy loading.\"\"\"\n\n    _instance: Optional[\"HandlerRegistry\"] = None\n    _handlers: Dict[str, Type[FileTypeHandler]] = {}\n    _initialized = False\n\n    def __new__(cls) -&gt; \"HandlerRegistry\":\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n    def __init__(self):\n        if not self._initialized:\n            self._load_default_handlers()\n            self._initialized = True\n\n    def _load_default_handlers(self):\n        \"\"\"Load default handlers with lazy imports.\"\"\"\n        # Import handlers at runtime to support optional dependencies\n        try:\n            from textxtract.handlers.pdf import PDFHandler\n\n            self._handlers[\".pdf\"] = PDFHandler\n        except ImportError:\n            logger.debug(\"PDF handler not available - pymupdf not installed\")\n\n        try:\n            from textxtract.handlers.docx import DOCXHandler\n\n            self._handlers[\".docx\"] = DOCXHandler\n        except ImportError:\n            logger.debug(\"DOCX handler not available - python-docx not installed\")\n\n        try:\n            from textxtract.handlers.doc import DOCHandler\n\n            self._handlers[\".doc\"] = DOCHandler\n        except ImportError:\n            logger.debug(\"DOC handler not available - antiword not installed\")\n\n        # Always available handlers\n        from textxtract.handlers.txt import TXTHandler\n        from textxtract.handlers.zip import ZIPHandler\n\n        self._handlers[\".txt\"] = TXTHandler\n        self._handlers[\".text\"] = TXTHandler\n        self._handlers[\".zip\"] = ZIPHandler\n\n        # Optional handlers with graceful fallback\n        try:\n            from textxtract.handlers.md import MDHandler\n\n            self._handlers[\".md\"] = MDHandler\n        except ImportError:\n            logger.debug(\"MD handler not available - markdown not installed\")\n\n        try:\n            from textxtract.handlers.rtf import RTFHandler\n\n            self._handlers[\".rtf\"] = RTFHandler\n        except ImportError:\n            logger.debug(\"RTF handler not available - pyrtf-ng not installed\")\n\n        try:\n            from textxtract.handlers.html import HTMLHandler\n\n            self._handlers[\".html\"] = HTMLHandler\n            self._handlers[\".htm\"] = HTMLHandler\n        except ImportError:\n            logger.debug(\"HTML handler not available - beautifulsoup4 not installed\")\n\n        # Standard library handlers\n        from textxtract.handlers.csv import CSVHandler\n        from textxtract.handlers.json import JSONHandler\n\n        self._handlers[\".csv\"] = CSVHandler\n        self._handlers[\".json\"] = JSONHandler\n\n        try:\n            from textxtract.handlers.xml import XMLHandler\n\n            self._handlers[\".xml\"] = XMLHandler\n        except ImportError:\n            logger.debug(\"XML handler not available - lxml not installed\")\n\n    @lru_cache(maxsize=128)\n    def get_handler(self, extension: str) -&gt; FileTypeHandler:\n        \"\"\"Get handler instance for file extension with caching.\"\"\"\n        ext = extension.lower()\n        handler_cls = self._handlers.get(ext)\n\n        if not handler_cls:\n            available = list(self._handlers.keys())\n            raise FileTypeNotSupportedError(\n                f\"Unsupported file extension: {ext}. \"\n                f\"Supported extensions: {', '.join(available)}\"\n            )\n\n        # Create handler instance (handlers are lightweight and stateless)\n        return handler_cls()\n\n    def register_handler(self, extension: str, handler_cls: Type[FileTypeHandler]):\n        \"\"\"Register a custom handler for a file extension.\"\"\"\n        ext = extension.lower()\n        if not ext.startswith(\".\"):\n            ext = f\".{ext}\"\n\n        self._handlers[ext] = handler_cls\n        # Clear cache when new handlers are registered\n        self.get_handler.cache_clear()\n        logger.info(\n            \"Registered custom handler %s for extension %s\", handler_cls.__name__, ext\n        )\n\n    def get_supported_extensions(self) -&gt; List[str]:\n        \"\"\"Get list of all supported file extensions.\"\"\"\n        return list(self._handlers.keys())\n\n    def is_supported(self, extension: str) -&gt; bool:\n        \"\"\"Check if a file extension is supported.\"\"\"\n        return extension.lower() in self._handlers\n</code></pre>"},{"location":"reference/core/#textxtract.core.registry.HandlerRegistry-functions","title":"Functions","text":"__init__ <pre><code>__init__()\n</code></pre> Source code in <code>textxtract/core/registry.py</code> <pre><code>def __init__(self):\n    if not self._initialized:\n        self._load_default_handlers()\n        self._initialized = True\n</code></pre> <code></code> __new__ <pre><code>__new__()\n</code></pre> Source code in <code>textxtract/core/registry.py</code> <pre><code>def __new__(cls) -&gt; \"HandlerRegistry\":\n    if cls._instance is None:\n        cls._instance = super().__new__(cls)\n    return cls._instance\n</code></pre> <code></code> get_handler <code>cached</code> <pre><code>get_handler(extension)\n</code></pre> <p>Get handler instance for file extension with caching.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>@lru_cache(maxsize=128)\ndef get_handler(self, extension: str) -&gt; FileTypeHandler:\n    \"\"\"Get handler instance for file extension with caching.\"\"\"\n    ext = extension.lower()\n    handler_cls = self._handlers.get(ext)\n\n    if not handler_cls:\n        available = list(self._handlers.keys())\n        raise FileTypeNotSupportedError(\n            f\"Unsupported file extension: {ext}. \"\n            f\"Supported extensions: {', '.join(available)}\"\n        )\n\n    # Create handler instance (handlers are lightweight and stateless)\n    return handler_cls()\n</code></pre> <code></code> get_supported_extensions <pre><code>get_supported_extensions()\n</code></pre> <p>Get list of all supported file extensions.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>def get_supported_extensions(self) -&gt; List[str]:\n    \"\"\"Get list of all supported file extensions.\"\"\"\n    return list(self._handlers.keys())\n</code></pre> <code></code> is_supported <pre><code>is_supported(extension)\n</code></pre> <p>Check if a file extension is supported.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>def is_supported(self, extension: str) -&gt; bool:\n    \"\"\"Check if a file extension is supported.\"\"\"\n    return extension.lower() in self._handlers\n</code></pre> <code></code> register_handler <pre><code>register_handler(extension, handler_cls)\n</code></pre> <p>Register a custom handler for a file extension.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>def register_handler(self, extension: str, handler_cls: Type[FileTypeHandler]):\n    \"\"\"Register a custom handler for a file extension.\"\"\"\n    ext = extension.lower()\n    if not ext.startswith(\".\"):\n        ext = f\".{ext}\"\n\n    self._handlers[ext] = handler_cls\n    # Clear cache when new handlers are registered\n    self.get_handler.cache_clear()\n    logger.info(\n        \"Registered custom handler %s for extension %s\", handler_cls.__name__, ext\n    )\n</code></pre>"},{"location":"reference/core/#textxtract.core.utils","title":"utils","text":"<p>Utility functions for textxtract package.</p> <p>Functions:</p> Name Description <code>create_temp_file</code> <p>Create a temporary file from bytes and return its path with security validation.</p> <code>get_file_info</code> <p>Get basic file information for logging and debugging.</p> <code>safe_unlink</code> <p>Safely delete a file if it exists, optionally logging errors.</p> <code>validate_file_extension</code> <p>Check if the file has an allowed extension.</p> <code>validate_file_size</code> <p>Validate file size doesn't exceed limits.</p> <code>validate_filename</code> <p>Validate filename for security issues.</p> <p>Attributes:</p> Name Type Description <code>DEFAULT_MAX_FILE_SIZE</code> <code>DEFAULT_MAX_TEMP_FILES</code>"},{"location":"reference/core/#textxtract.core.utils-attributes","title":"Attributes","text":""},{"location":"reference/core/#textxtract.core.utils.DEFAULT_MAX_FILE_SIZE","title":"DEFAULT_MAX_FILE_SIZE  <code>module-attribute</code>","text":"<pre><code>DEFAULT_MAX_FILE_SIZE = 100 * 1024 * 1024\n</code></pre>"},{"location":"reference/core/#textxtract.core.utils.DEFAULT_MAX_TEMP_FILES","title":"DEFAULT_MAX_TEMP_FILES  <code>module-attribute</code>","text":"<pre><code>DEFAULT_MAX_TEMP_FILES = 1000\n</code></pre>"},{"location":"reference/core/#textxtract.core.utils-functions","title":"Functions","text":""},{"location":"reference/core/#textxtract.core.utils.create_temp_file","title":"create_temp_file","text":"<pre><code>create_temp_file(file_bytes, filename, max_size=None)\n</code></pre> <p>Create a temporary file from bytes and return its path with security validation.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def create_temp_file(\n    file_bytes: bytes, filename: str, max_size: Optional[int] = None\n) -&gt; Path:\n    \"\"\"Create a temporary file from bytes and return its path with security validation.\"\"\"\n    validate_filename(filename)\n    validate_file_size(file_bytes, max_size)\n\n    file_ext = Path(filename).suffix\n    with tempfile.NamedTemporaryFile(delete=False, suffix=file_ext) as temp_file:\n        temp_file.write(file_bytes)\n        temp_path = Path(temp_file.name)\n\n    # Ensure file was created successfully\n    if not temp_path.exists():\n        raise RuntimeError(\"Failed to create temporary file\")\n\n    return temp_path\n</code></pre>"},{"location":"reference/core/#textxtract.core.utils.get_file_info","title":"get_file_info","text":"<pre><code>get_file_info(file_bytes, filename)\n</code></pre> <p>Get basic file information for logging and debugging.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def get_file_info(file_bytes: bytes, filename: str) -&gt; dict:\n    \"\"\"Get basic file information for logging and debugging.\"\"\"\n    return {\n        \"filename\": filename,\n        \"size_bytes\": len(file_bytes),\n        \"size_mb\": round(len(file_bytes) / (1024 * 1024), 2),\n        \"extension\": Path(filename).suffix.lower(),\n    }\n</code></pre>"},{"location":"reference/core/#textxtract.core.utils.safe_unlink","title":"safe_unlink","text":"<pre><code>safe_unlink(path, log_errors=True)\n</code></pre> <p>Safely delete a file if it exists, optionally logging errors.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def safe_unlink(path: Path, log_errors: bool = True) -&gt; bool:\n    \"\"\"Safely delete a file if it exists, optionally logging errors.\"\"\"\n    try:\n        if path.exists():\n            path.unlink()\n            return True\n        return False\n    except Exception as e:\n        if log_errors:\n            import logging\n\n            logger = logging.getLogger(\"textxtract.utils\")\n            logger.warning(\"Failed to delete temporary file %s: %s\", path, e)\n        return False\n</code></pre>"},{"location":"reference/core/#textxtract.core.utils.validate_file_extension","title":"validate_file_extension","text":"<pre><code>validate_file_extension(filename, allowed_extensions)\n</code></pre> <p>Check if the file has an allowed extension.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def validate_file_extension(filename: str, allowed_extensions: list[str]) -&gt; bool:\n    \"\"\"Check if the file has an allowed extension.\"\"\"\n    return Path(filename).suffix.lower() in allowed_extensions\n</code></pre>"},{"location":"reference/core/#textxtract.core.utils.validate_file_size","title":"validate_file_size","text":"<pre><code>validate_file_size(file_bytes, max_size=None)\n</code></pre> <p>Validate file size doesn't exceed limits.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def validate_file_size(file_bytes: bytes, max_size: Optional[int] = None) -&gt; None:\n    \"\"\"Validate file size doesn't exceed limits.\"\"\"\n    max_size = max_size or DEFAULT_MAX_FILE_SIZE\n    if len(file_bytes) == 0:\n        raise ValueError(\"File is empty (0 bytes)\")\n    if len(file_bytes) &gt; max_size:\n        raise ValueError(\n            f\"File size ({len(file_bytes):,} bytes) exceeds maximum \"\n            f\"allowed size ({max_size:,} bytes)\"\n        )\n</code></pre>"},{"location":"reference/core/#textxtract.core.utils.validate_filename","title":"validate_filename","text":"<pre><code>validate_filename(filename)\n</code></pre> <p>Validate filename for security issues.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def validate_filename(filename: str) -&gt; None:\n    \"\"\"Validate filename for security issues.\"\"\"\n    if not filename:\n        raise ValueError(\"Filename cannot be empty\")\n\n    # Check for null bytes\n    if \"\\x00\" in filename:\n        raise ValueError(f\"Invalid filename: contains null byte\")\n\n    # Check for path traversal attempts\n    if \"..\" in filename:\n        raise ValueError(f\"Invalid filename: path traversal detected\")\n\n    # Check for absolute paths (both Unix and Windows)\n    if filename.startswith(\"/\") or (len(filename) &gt; 1 and filename[1] == \":\"):\n        raise ValueError(f\"Invalid filename: absolute path not allowed\")\n\n    # Check for Windows path separators in suspicious contexts\n    if \"\\\\\" in filename and (\"..\" in filename or filename.count(\"\\\\\") &gt; 2):\n        raise ValueError(f\"Invalid filename: suspicious path structure\")\n\n    # Check filename length\n    if len(filename) &gt; 255:\n        raise ValueError(\"Filename too long\")\n</code></pre>"},{"location":"reference/core/__init__/","title":"Core Module","text":"<p>Core components for textxtract package.</p> <p>Modules:</p> Name Description <code>base</code> <p>Abstract base classes for text extraction.</p> <code>config</code> <p>Configuration and customization for textxtract package.</p> <code>exceptions</code> <p>Custom exceptions for textxtract package.</p> <code>logging_config</code> <p>Logging configuration for textxtract package.</p> <code>registry</code> <p>Handler registry for centralized handler management.</p> <code>utils</code> <p>Utility functions for textxtract package.</p>"},{"location":"reference/core/__init__/#textxtract.core-modules","title":"Modules","text":""},{"location":"reference/core/__init__/#textxtract.core.base","title":"base","text":"<p>Abstract base classes for text extraction.</p> <p>Classes:</p> Name Description <code>FileTypeHandler</code> <p>Abstract base class for file type-specific handlers.</p> <code>TextExtractor</code> <p>Abstract base class for text extractors.</p>"},{"location":"reference/core/__init__/#textxtract.core.base-classes","title":"Classes","text":""},{"location":"reference/core/__init__/#textxtract.core.base.FileTypeHandler","title":"FileTypeHandler","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for file type-specific handlers.</p> <p>Methods:</p> Name Description <code>extract</code> <p>Extract text synchronously from a file.</p> <code>extract_async</code> <p>Extract text asynchronously from a file.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>class FileTypeHandler(ABC):\n    \"\"\"Abstract base class for file type-specific handlers.\"\"\"\n\n    @abstractmethod\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        \"\"\"Extract text synchronously from a file.\"\"\"\n        pass\n\n    @abstractmethod\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"Extract text asynchronously from a file.\"\"\"\n        pass\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.base.FileTypeHandler-functions","title":"Functions","text":"extract <code>abstractmethod</code> <pre><code>extract(file_path, config=None)\n</code></pre> <p>Extract text synchronously from a file.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>@abstractmethod\ndef extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    \"\"\"Extract text synchronously from a file.\"\"\"\n    pass\n</code></pre> <code></code> extract_async <code>abstractmethod</code> <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> <p>Extract text asynchronously from a file.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>@abstractmethod\nasync def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"Extract text asynchronously from a file.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.base.TextExtractor","title":"TextExtractor","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for text extractors.</p> <p>Methods:</p> Name Description <code>extract</code> <p>Extract text synchronously from file bytes.</p> <code>extract_async</code> <p>Extract text asynchronously from file bytes.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>class TextExtractor(ABC):\n    \"\"\"Abstract base class for text extractors.\"\"\"\n\n    @abstractmethod\n    def extract(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"Extract text synchronously from file bytes.\"\"\"\n        pass\n\n    @abstractmethod\n    async def extract_async(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"Extract text asynchronously from file bytes.\"\"\"\n        pass\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.base.TextExtractor-functions","title":"Functions","text":"extract <code>abstractmethod</code> <pre><code>extract(file_bytes, filename, config=None)\n</code></pre> <p>Extract text synchronously from file bytes.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>@abstractmethod\ndef extract(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"Extract text synchronously from file bytes.\"\"\"\n    pass\n</code></pre> <code></code> extract_async <code>abstractmethod</code> <code>async</code> <pre><code>extract_async(file_bytes, filename, config=None)\n</code></pre> <p>Extract text asynchronously from file bytes.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>@abstractmethod\nasync def extract_async(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"Extract text asynchronously from file bytes.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.config","title":"config","text":"<p>Configuration and customization for textxtract package.</p> <p>Classes:</p> Name Description <code>ExtractorConfig</code> <p>Enhanced configuration options for text extraction with validation.</p>"},{"location":"reference/core/__init__/#textxtract.core.config-classes","title":"Classes","text":""},{"location":"reference/core/__init__/#textxtract.core.config.ExtractorConfig","title":"ExtractorConfig","text":"<p>Enhanced configuration options for text extraction with validation.</p> <p>Methods:</p> Name Description <code>__init__</code> <code>__repr__</code> <code>from_file</code> <p>Load configuration from a file (JSON, YAML, or TOML).</p> <code>get_handler</code> <p>Retrieve a handler for a given file extension.</p> <code>get_handler_config</code> <p>Get configuration specific to a handler.</p> <code>register_handler</code> <p>Register a custom file type handler.</p> <code>to_dict</code> <p>Convert configuration to dictionary.</p> <p>Attributes:</p> Name Type Description <code>custom_handlers</code> <code>encoding</code> <code>extra_config</code> <code>logging_format</code> <code>logging_level</code> <code>max_file_size</code> <code>max_memory_usage</code> <code>timeout</code> Source code in <code>textxtract/core/config.py</code> <pre><code>class ExtractorConfig:\n    \"\"\"Enhanced configuration options for text extraction with validation.\"\"\"\n\n    def __init__(\n        self,\n        encoding: str = \"utf-8\",\n        logging_level: str = \"INFO\",\n        logging_format: Optional[str] = None,\n        timeout: Optional[float] = None,\n        max_file_size: Optional[int] = None,\n        max_memory_usage: Optional[int] = None,\n        custom_handlers: Optional[Dict[str, Callable]] = None,\n        **kwargs,\n    ):\n        # Validate and set basic options\n        self.encoding = self._validate_encoding(encoding)\n        self.logging_level = self._validate_logging_level(logging_level)\n        self.logging_format = (\n            logging_format or \"%(asctime)s %(levelname)s %(name)s: %(message)s\"\n        )\n        self.timeout = self._validate_timeout(timeout)\n        self.max_file_size = self._validate_max_file_size(max_file_size)\n        self.max_memory_usage = max_memory_usage\n        self.custom_handlers = custom_handlers or {}\n\n        # Load from environment variables\n        self._load_from_env()\n\n        # Store additional kwargs for handler-specific config\n        self.extra_config = kwargs\n\n    def _validate_encoding(self, encoding: str) -&gt; str:\n        \"\"\"Validate encoding parameter.\"\"\"\n        if not isinstance(encoding, str):\n            raise ValueError(\"Encoding must be a string\")\n\n        # Test if encoding is valid\n        try:\n            \"test\".encode(encoding)\n        except LookupError:\n            raise ValueError(f\"Invalid encoding: {encoding}\")\n\n        return encoding\n\n    def _validate_logging_level(self, level: str) -&gt; str:\n        \"\"\"Validate logging level parameter.\"\"\"\n        valid_levels = {\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"}\n        if level.upper() not in valid_levels:\n            raise ValueError(\n                f\"Invalid logging level: {level}. Must be one of {valid_levels}\"\n            )\n        return level.upper()\n\n    def _validate_timeout(self, timeout: Optional[float]) -&gt; Optional[float]:\n        \"\"\"Validate timeout parameter.\"\"\"\n        if timeout is not None:\n            if not isinstance(timeout, (int, float)) or timeout &lt;= 0:\n                raise ValueError(\"Timeout must be a positive number\")\n        return timeout\n\n    def _validate_max_file_size(self, size: Optional[int]) -&gt; Optional[int]:\n        \"\"\"Validate max file size parameter.\"\"\"\n        if size is not None:\n            if not isinstance(size, int) or size &lt;= 0:\n                raise ValueError(\"Max file size must be a positive integer\")\n        return size\n\n    def _load_from_env(self):\n        \"\"\"Load configuration from environment variables.\"\"\"\n        # Override with environment variables if present\n        env_encoding = os.getenv(\"TEXT_EXTRACTOR_ENCODING\")\n        if env_encoding:\n            self.encoding = self._validate_encoding(env_encoding)\n\n        env_logging = os.getenv(\"TEXT_EXTRACTOR_LOG_LEVEL\")\n        if env_logging:\n            self.logging_level = self._validate_logging_level(env_logging)\n\n        env_timeout = os.getenv(\"TEXT_EXTRACTOR_TIMEOUT\")\n        if env_timeout:\n            try:\n                self.timeout = float(env_timeout)\n            except ValueError:\n                pass  # Ignore invalid values\n\n        env_max_size = os.getenv(\"TEXT_EXTRACTOR_MAX_FILE_SIZE\")\n        if env_max_size:\n            try:\n                self.max_file_size = int(env_max_size)\n            except ValueError:\n                pass  # Ignore invalid values\n\n    def register_handler(self, extension: str, handler: Callable):\n        \"\"\"Register a custom file type handler.\"\"\"\n        if not extension.startswith(\".\"):\n            extension = f\".{extension}\"\n        self.custom_handlers[extension.lower()] = handler\n\n    def get_handler(self, extension: str) -&gt; Optional[Callable]:\n        \"\"\"Retrieve a handler for a given file extension.\"\"\"\n        return self.custom_handlers.get(extension.lower())\n\n    def get_handler_config(self, handler_name: str) -&gt; Dict[str, Any]:\n        \"\"\"Get configuration specific to a handler.\"\"\"\n        base_config = {\n            \"encoding\": self.encoding,\n            \"timeout\": self.timeout,\n            \"max_file_size\": self.max_file_size,\n            \"max_memory_usage\": self.max_memory_usage,\n        }\n\n        # Add handler-specific config\n        handler_config_key = f\"{handler_name.lower()}_config\"\n        if handler_config_key in self.extra_config:\n            base_config.update(self.extra_config[handler_config_key])\n\n        return base_config\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert configuration to dictionary.\"\"\"\n        return {\n            \"encoding\": self.encoding,\n            \"logging_level\": self.logging_level,\n            \"logging_format\": self.logging_format,\n            \"timeout\": self.timeout,\n            \"max_file_size\": self.max_file_size,\n            \"max_memory_usage\": self.max_memory_usage,\n            \"custom_handlers\": {k: str(v) for k, v in self.custom_handlers.items()},\n            **self.extra_config,\n        }\n\n    @classmethod\n    def from_file(cls, config_path: Union[str, Path]) -&gt; \"ExtractorConfig\":\n        \"\"\"Load configuration from a file (JSON, YAML, or TOML).\"\"\"\n        config_path = Path(config_path)\n\n        if not config_path.exists():\n            raise FileNotFoundError(f\"Configuration file not found: {config_path}\")\n\n        content = config_path.read_text()\n\n        if config_path.suffix.lower() == \".json\":\n            import json\n\n            config_data = json.loads(content)\n        elif config_path.suffix.lower() in (\".yaml\", \".yml\"):\n            try:\n                import yaml\n\n                config_data = yaml.safe_load(content)\n            except ImportError:\n                raise ImportError(\"PyYAML is required to load YAML configuration files\")\n        elif config_path.suffix.lower() == \".toml\":\n            try:\n                import tomli\n\n                config_data = tomli.loads(content)\n            except ImportError:\n                raise ImportError(\"tomli is required to load TOML configuration files\")\n        else:\n            raise ValueError(\n                f\"Unsupported configuration file format: {config_path.suffix}\"\n            )\n\n        return cls(**config_data)\n\n    def __repr__(self) -&gt; str:\n        return f\"ExtractorConfig(encoding='{self.encoding}', logging_level='{self.logging_level}', timeout={self.timeout})\"\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.config.ExtractorConfig-attributes","title":"Attributes","text":"custom_handlers <code>instance-attribute</code> <pre><code>custom_handlers = custom_handlers or {}\n</code></pre> <code></code> encoding <code>instance-attribute</code> <pre><code>encoding = _validate_encoding(encoding)\n</code></pre> <code></code> extra_config <code>instance-attribute</code> <pre><code>extra_config = kwargs\n</code></pre> <code></code> logging_format <code>instance-attribute</code> <pre><code>logging_format = logging_format or '%(asctime)s %(levelname)s %(name)s: %(message)s'\n</code></pre> <code></code> logging_level <code>instance-attribute</code> <pre><code>logging_level = _validate_logging_level(logging_level)\n</code></pre> <code></code> max_file_size <code>instance-attribute</code> <pre><code>max_file_size = _validate_max_file_size(max_file_size)\n</code></pre> <code></code> max_memory_usage <code>instance-attribute</code> <pre><code>max_memory_usage = max_memory_usage\n</code></pre> <code></code> timeout <code>instance-attribute</code> <pre><code>timeout = _validate_timeout(timeout)\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.config.ExtractorConfig-functions","title":"Functions","text":"__init__ <pre><code>__init__(encoding='utf-8', logging_level='INFO', logging_format=None, timeout=None, max_file_size=None, max_memory_usage=None, custom_handlers=None, **kwargs)\n</code></pre> Source code in <code>textxtract/core/config.py</code> <pre><code>def __init__(\n    self,\n    encoding: str = \"utf-8\",\n    logging_level: str = \"INFO\",\n    logging_format: Optional[str] = None,\n    timeout: Optional[float] = None,\n    max_file_size: Optional[int] = None,\n    max_memory_usage: Optional[int] = None,\n    custom_handlers: Optional[Dict[str, Callable]] = None,\n    **kwargs,\n):\n    # Validate and set basic options\n    self.encoding = self._validate_encoding(encoding)\n    self.logging_level = self._validate_logging_level(logging_level)\n    self.logging_format = (\n        logging_format or \"%(asctime)s %(levelname)s %(name)s: %(message)s\"\n    )\n    self.timeout = self._validate_timeout(timeout)\n    self.max_file_size = self._validate_max_file_size(max_file_size)\n    self.max_memory_usage = max_memory_usage\n    self.custom_handlers = custom_handlers or {}\n\n    # Load from environment variables\n    self._load_from_env()\n\n    # Store additional kwargs for handler-specific config\n    self.extra_config = kwargs\n</code></pre> <code></code> __repr__ <pre><code>__repr__()\n</code></pre> Source code in <code>textxtract/core/config.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f\"ExtractorConfig(encoding='{self.encoding}', logging_level='{self.logging_level}', timeout={self.timeout})\"\n</code></pre> <code></code> from_file <code>classmethod</code> <pre><code>from_file(config_path)\n</code></pre> <p>Load configuration from a file (JSON, YAML, or TOML).</p> Source code in <code>textxtract/core/config.py</code> <pre><code>@classmethod\ndef from_file(cls, config_path: Union[str, Path]) -&gt; \"ExtractorConfig\":\n    \"\"\"Load configuration from a file (JSON, YAML, or TOML).\"\"\"\n    config_path = Path(config_path)\n\n    if not config_path.exists():\n        raise FileNotFoundError(f\"Configuration file not found: {config_path}\")\n\n    content = config_path.read_text()\n\n    if config_path.suffix.lower() == \".json\":\n        import json\n\n        config_data = json.loads(content)\n    elif config_path.suffix.lower() in (\".yaml\", \".yml\"):\n        try:\n            import yaml\n\n            config_data = yaml.safe_load(content)\n        except ImportError:\n            raise ImportError(\"PyYAML is required to load YAML configuration files\")\n    elif config_path.suffix.lower() == \".toml\":\n        try:\n            import tomli\n\n            config_data = tomli.loads(content)\n        except ImportError:\n            raise ImportError(\"tomli is required to load TOML configuration files\")\n    else:\n        raise ValueError(\n            f\"Unsupported configuration file format: {config_path.suffix}\"\n        )\n\n    return cls(**config_data)\n</code></pre> <code></code> get_handler <pre><code>get_handler(extension)\n</code></pre> <p>Retrieve a handler for a given file extension.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def get_handler(self, extension: str) -&gt; Optional[Callable]:\n    \"\"\"Retrieve a handler for a given file extension.\"\"\"\n    return self.custom_handlers.get(extension.lower())\n</code></pre> <code></code> get_handler_config <pre><code>get_handler_config(handler_name)\n</code></pre> <p>Get configuration specific to a handler.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def get_handler_config(self, handler_name: str) -&gt; Dict[str, Any]:\n    \"\"\"Get configuration specific to a handler.\"\"\"\n    base_config = {\n        \"encoding\": self.encoding,\n        \"timeout\": self.timeout,\n        \"max_file_size\": self.max_file_size,\n        \"max_memory_usage\": self.max_memory_usage,\n    }\n\n    # Add handler-specific config\n    handler_config_key = f\"{handler_name.lower()}_config\"\n    if handler_config_key in self.extra_config:\n        base_config.update(self.extra_config[handler_config_key])\n\n    return base_config\n</code></pre> <code></code> register_handler <pre><code>register_handler(extension, handler)\n</code></pre> <p>Register a custom file type handler.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def register_handler(self, extension: str, handler: Callable):\n    \"\"\"Register a custom file type handler.\"\"\"\n    if not extension.startswith(\".\"):\n        extension = f\".{extension}\"\n    self.custom_handlers[extension.lower()] = handler\n</code></pre> <code></code> to_dict <pre><code>to_dict()\n</code></pre> <p>Convert configuration to dictionary.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert configuration to dictionary.\"\"\"\n    return {\n        \"encoding\": self.encoding,\n        \"logging_level\": self.logging_level,\n        \"logging_format\": self.logging_format,\n        \"timeout\": self.timeout,\n        \"max_file_size\": self.max_file_size,\n        \"max_memory_usage\": self.max_memory_usage,\n        \"custom_handlers\": {k: str(v) for k, v in self.custom_handlers.items()},\n        **self.extra_config,\n    }\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.exceptions","title":"exceptions","text":"<p>Custom exceptions for textxtract package.</p> <p>Classes:</p> Name Description <code>ExtractionError</code> <p>Raised when a general extraction error occurs.</p> <code>ExtractionTimeoutError</code> <p>Raised when extraction exceeds the allowed timeout.</p> <code>FileTypeNotSupportedError</code> <p>Raised when the file type is not supported.</p> <code>InvalidFileError</code> <p>Raised when the file is invalid or unsupported.</p>"},{"location":"reference/core/__init__/#textxtract.core.exceptions-classes","title":"Classes","text":""},{"location":"reference/core/__init__/#textxtract.core.exceptions.ExtractionError","title":"ExtractionError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when a general extraction error occurs.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class ExtractionError(Exception):\n    \"\"\"Raised when a general extraction error occurs.\"\"\"\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.exceptions.ExtractionTimeoutError","title":"ExtractionTimeoutError","text":"<p>               Bases: <code>ExtractionError</code></p> <p>Raised when extraction exceeds the allowed timeout.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class ExtractionTimeoutError(ExtractionError):\n    \"\"\"Raised when extraction exceeds the allowed timeout.\"\"\"\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.exceptions.FileTypeNotSupportedError","title":"FileTypeNotSupportedError","text":"<p>               Bases: <code>ExtractionError</code></p> <p>Raised when the file type is not supported.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class FileTypeNotSupportedError(ExtractionError):\n    \"\"\"Raised when the file type is not supported.\"\"\"\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.exceptions.InvalidFileError","title":"InvalidFileError","text":"<p>               Bases: <code>ExtractionError</code></p> <p>Raised when the file is invalid or unsupported.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class InvalidFileError(ExtractionError):\n    \"\"\"Raised when the file is invalid or unsupported.\"\"\"\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.logging_config","title":"logging_config","text":"<p>Logging configuration for textxtract package.</p> <p>Functions:</p> Name Description <code>setup_logging</code> <p>Configure logging for the package.</p>"},{"location":"reference/core/__init__/#textxtract.core.logging_config-functions","title":"Functions","text":""},{"location":"reference/core/__init__/#textxtract.core.logging_config.setup_logging","title":"setup_logging","text":"<pre><code>setup_logging(level='INFO', fmt='%(asctime)s %(levelname)s %(name)s: %(message)s')\n</code></pre> <p>Configure logging for the package.</p> Source code in <code>textxtract/core/logging_config.py</code> <pre><code>def setup_logging(\n    level: str = \"INFO\", fmt: str = \"%(asctime)s %(levelname)s %(name)s: %(message)s\"\n):\n    \"\"\"Configure logging for the package.\"\"\"\n    logging.basicConfig(level=getattr(logging, level.upper(), logging.INFO), format=fmt)\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.registry","title":"registry","text":"<p>Handler registry for centralized handler management.</p> <p>Classes:</p> Name Description <code>HandlerRegistry</code> <p>Central registry for file type handlers with caching and lazy loading.</p> <p>Attributes:</p> Name Type Description <code>logger</code> <code>registry</code>"},{"location":"reference/core/__init__/#textxtract.core.registry-attributes","title":"Attributes","text":""},{"location":"reference/core/__init__/#textxtract.core.registry.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger('textxtract.registry')\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.registry.registry","title":"registry  <code>module-attribute</code>","text":"<pre><code>registry = HandlerRegistry()\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.registry-classes","title":"Classes","text":""},{"location":"reference/core/__init__/#textxtract.core.registry.HandlerRegistry","title":"HandlerRegistry","text":"<p>Central registry for file type handlers with caching and lazy loading.</p> <p>Methods:</p> Name Description <code>__init__</code> <code>__new__</code> <code>get_handler</code> <p>Get handler instance for file extension with caching.</p> <code>get_supported_extensions</code> <p>Get list of all supported file extensions.</p> <code>is_supported</code> <p>Check if a file extension is supported.</p> <code>register_handler</code> <p>Register a custom handler for a file extension.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>class HandlerRegistry:\n    \"\"\"Central registry for file type handlers with caching and lazy loading.\"\"\"\n\n    _instance: Optional[\"HandlerRegistry\"] = None\n    _handlers: Dict[str, Type[FileTypeHandler]] = {}\n    _initialized = False\n\n    def __new__(cls) -&gt; \"HandlerRegistry\":\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n    def __init__(self):\n        if not self._initialized:\n            self._load_default_handlers()\n            self._initialized = True\n\n    def _load_default_handlers(self):\n        \"\"\"Load default handlers with lazy imports.\"\"\"\n        # Import handlers at runtime to support optional dependencies\n        try:\n            from textxtract.handlers.pdf import PDFHandler\n\n            self._handlers[\".pdf\"] = PDFHandler\n        except ImportError:\n            logger.debug(\"PDF handler not available - pymupdf not installed\")\n\n        try:\n            from textxtract.handlers.docx import DOCXHandler\n\n            self._handlers[\".docx\"] = DOCXHandler\n        except ImportError:\n            logger.debug(\"DOCX handler not available - python-docx not installed\")\n\n        try:\n            from textxtract.handlers.doc import DOCHandler\n\n            self._handlers[\".doc\"] = DOCHandler\n        except ImportError:\n            logger.debug(\"DOC handler not available - antiword not installed\")\n\n        # Always available handlers\n        from textxtract.handlers.txt import TXTHandler\n        from textxtract.handlers.zip import ZIPHandler\n\n        self._handlers[\".txt\"] = TXTHandler\n        self._handlers[\".text\"] = TXTHandler\n        self._handlers[\".zip\"] = ZIPHandler\n\n        # Optional handlers with graceful fallback\n        try:\n            from textxtract.handlers.md import MDHandler\n\n            self._handlers[\".md\"] = MDHandler\n        except ImportError:\n            logger.debug(\"MD handler not available - markdown not installed\")\n\n        try:\n            from textxtract.handlers.rtf import RTFHandler\n\n            self._handlers[\".rtf\"] = RTFHandler\n        except ImportError:\n            logger.debug(\"RTF handler not available - pyrtf-ng not installed\")\n\n        try:\n            from textxtract.handlers.html import HTMLHandler\n\n            self._handlers[\".html\"] = HTMLHandler\n            self._handlers[\".htm\"] = HTMLHandler\n        except ImportError:\n            logger.debug(\"HTML handler not available - beautifulsoup4 not installed\")\n\n        # Standard library handlers\n        from textxtract.handlers.csv import CSVHandler\n        from textxtract.handlers.json import JSONHandler\n\n        self._handlers[\".csv\"] = CSVHandler\n        self._handlers[\".json\"] = JSONHandler\n\n        try:\n            from textxtract.handlers.xml import XMLHandler\n\n            self._handlers[\".xml\"] = XMLHandler\n        except ImportError:\n            logger.debug(\"XML handler not available - lxml not installed\")\n\n    @lru_cache(maxsize=128)\n    def get_handler(self, extension: str) -&gt; FileTypeHandler:\n        \"\"\"Get handler instance for file extension with caching.\"\"\"\n        ext = extension.lower()\n        handler_cls = self._handlers.get(ext)\n\n        if not handler_cls:\n            available = list(self._handlers.keys())\n            raise FileTypeNotSupportedError(\n                f\"Unsupported file extension: {ext}. \"\n                f\"Supported extensions: {', '.join(available)}\"\n            )\n\n        # Create handler instance (handlers are lightweight and stateless)\n        return handler_cls()\n\n    def register_handler(self, extension: str, handler_cls: Type[FileTypeHandler]):\n        \"\"\"Register a custom handler for a file extension.\"\"\"\n        ext = extension.lower()\n        if not ext.startswith(\".\"):\n            ext = f\".{ext}\"\n\n        self._handlers[ext] = handler_cls\n        # Clear cache when new handlers are registered\n        self.get_handler.cache_clear()\n        logger.info(\n            \"Registered custom handler %s for extension %s\", handler_cls.__name__, ext\n        )\n\n    def get_supported_extensions(self) -&gt; List[str]:\n        \"\"\"Get list of all supported file extensions.\"\"\"\n        return list(self._handlers.keys())\n\n    def is_supported(self, extension: str) -&gt; bool:\n        \"\"\"Check if a file extension is supported.\"\"\"\n        return extension.lower() in self._handlers\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.registry.HandlerRegistry-functions","title":"Functions","text":"__init__ <pre><code>__init__()\n</code></pre> Source code in <code>textxtract/core/registry.py</code> <pre><code>def __init__(self):\n    if not self._initialized:\n        self._load_default_handlers()\n        self._initialized = True\n</code></pre> <code></code> __new__ <pre><code>__new__()\n</code></pre> Source code in <code>textxtract/core/registry.py</code> <pre><code>def __new__(cls) -&gt; \"HandlerRegistry\":\n    if cls._instance is None:\n        cls._instance = super().__new__(cls)\n    return cls._instance\n</code></pre> <code></code> get_handler <code>cached</code> <pre><code>get_handler(extension)\n</code></pre> <p>Get handler instance for file extension with caching.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>@lru_cache(maxsize=128)\ndef get_handler(self, extension: str) -&gt; FileTypeHandler:\n    \"\"\"Get handler instance for file extension with caching.\"\"\"\n    ext = extension.lower()\n    handler_cls = self._handlers.get(ext)\n\n    if not handler_cls:\n        available = list(self._handlers.keys())\n        raise FileTypeNotSupportedError(\n            f\"Unsupported file extension: {ext}. \"\n            f\"Supported extensions: {', '.join(available)}\"\n        )\n\n    # Create handler instance (handlers are lightweight and stateless)\n    return handler_cls()\n</code></pre> <code></code> get_supported_extensions <pre><code>get_supported_extensions()\n</code></pre> <p>Get list of all supported file extensions.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>def get_supported_extensions(self) -&gt; List[str]:\n    \"\"\"Get list of all supported file extensions.\"\"\"\n    return list(self._handlers.keys())\n</code></pre> <code></code> is_supported <pre><code>is_supported(extension)\n</code></pre> <p>Check if a file extension is supported.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>def is_supported(self, extension: str) -&gt; bool:\n    \"\"\"Check if a file extension is supported.\"\"\"\n    return extension.lower() in self._handlers\n</code></pre> <code></code> register_handler <pre><code>register_handler(extension, handler_cls)\n</code></pre> <p>Register a custom handler for a file extension.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>def register_handler(self, extension: str, handler_cls: Type[FileTypeHandler]):\n    \"\"\"Register a custom handler for a file extension.\"\"\"\n    ext = extension.lower()\n    if not ext.startswith(\".\"):\n        ext = f\".{ext}\"\n\n    self._handlers[ext] = handler_cls\n    # Clear cache when new handlers are registered\n    self.get_handler.cache_clear()\n    logger.info(\n        \"Registered custom handler %s for extension %s\", handler_cls.__name__, ext\n    )\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.utils","title":"utils","text":"<p>Utility functions for textxtract package.</p> <p>Functions:</p> Name Description <code>create_temp_file</code> <p>Create a temporary file from bytes and return its path with security validation.</p> <code>get_file_info</code> <p>Get basic file information for logging and debugging.</p> <code>safe_unlink</code> <p>Safely delete a file if it exists, optionally logging errors.</p> <code>validate_file_extension</code> <p>Check if the file has an allowed extension.</p> <code>validate_file_size</code> <p>Validate file size doesn't exceed limits.</p> <code>validate_filename</code> <p>Validate filename for security issues.</p> <p>Attributes:</p> Name Type Description <code>DEFAULT_MAX_FILE_SIZE</code> <code>DEFAULT_MAX_TEMP_FILES</code>"},{"location":"reference/core/__init__/#textxtract.core.utils-attributes","title":"Attributes","text":""},{"location":"reference/core/__init__/#textxtract.core.utils.DEFAULT_MAX_FILE_SIZE","title":"DEFAULT_MAX_FILE_SIZE  <code>module-attribute</code>","text":"<pre><code>DEFAULT_MAX_FILE_SIZE = 100 * 1024 * 1024\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.utils.DEFAULT_MAX_TEMP_FILES","title":"DEFAULT_MAX_TEMP_FILES  <code>module-attribute</code>","text":"<pre><code>DEFAULT_MAX_TEMP_FILES = 1000\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.utils-functions","title":"Functions","text":""},{"location":"reference/core/__init__/#textxtract.core.utils.create_temp_file","title":"create_temp_file","text":"<pre><code>create_temp_file(file_bytes, filename, max_size=None)\n</code></pre> <p>Create a temporary file from bytes and return its path with security validation.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def create_temp_file(\n    file_bytes: bytes, filename: str, max_size: Optional[int] = None\n) -&gt; Path:\n    \"\"\"Create a temporary file from bytes and return its path with security validation.\"\"\"\n    validate_filename(filename)\n    validate_file_size(file_bytes, max_size)\n\n    file_ext = Path(filename).suffix\n    with tempfile.NamedTemporaryFile(delete=False, suffix=file_ext) as temp_file:\n        temp_file.write(file_bytes)\n        temp_path = Path(temp_file.name)\n\n    # Ensure file was created successfully\n    if not temp_path.exists():\n        raise RuntimeError(\"Failed to create temporary file\")\n\n    return temp_path\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.utils.get_file_info","title":"get_file_info","text":"<pre><code>get_file_info(file_bytes, filename)\n</code></pre> <p>Get basic file information for logging and debugging.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def get_file_info(file_bytes: bytes, filename: str) -&gt; dict:\n    \"\"\"Get basic file information for logging and debugging.\"\"\"\n    return {\n        \"filename\": filename,\n        \"size_bytes\": len(file_bytes),\n        \"size_mb\": round(len(file_bytes) / (1024 * 1024), 2),\n        \"extension\": Path(filename).suffix.lower(),\n    }\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.utils.safe_unlink","title":"safe_unlink","text":"<pre><code>safe_unlink(path, log_errors=True)\n</code></pre> <p>Safely delete a file if it exists, optionally logging errors.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def safe_unlink(path: Path, log_errors: bool = True) -&gt; bool:\n    \"\"\"Safely delete a file if it exists, optionally logging errors.\"\"\"\n    try:\n        if path.exists():\n            path.unlink()\n            return True\n        return False\n    except Exception as e:\n        if log_errors:\n            import logging\n\n            logger = logging.getLogger(\"textxtract.utils\")\n            logger.warning(\"Failed to delete temporary file %s: %s\", path, e)\n        return False\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.utils.validate_file_extension","title":"validate_file_extension","text":"<pre><code>validate_file_extension(filename, allowed_extensions)\n</code></pre> <p>Check if the file has an allowed extension.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def validate_file_extension(filename: str, allowed_extensions: list[str]) -&gt; bool:\n    \"\"\"Check if the file has an allowed extension.\"\"\"\n    return Path(filename).suffix.lower() in allowed_extensions\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.utils.validate_file_size","title":"validate_file_size","text":"<pre><code>validate_file_size(file_bytes, max_size=None)\n</code></pre> <p>Validate file size doesn't exceed limits.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def validate_file_size(file_bytes: bytes, max_size: Optional[int] = None) -&gt; None:\n    \"\"\"Validate file size doesn't exceed limits.\"\"\"\n    max_size = max_size or DEFAULT_MAX_FILE_SIZE\n    if len(file_bytes) == 0:\n        raise ValueError(\"File is empty (0 bytes)\")\n    if len(file_bytes) &gt; max_size:\n        raise ValueError(\n            f\"File size ({len(file_bytes):,} bytes) exceeds maximum \"\n            f\"allowed size ({max_size:,} bytes)\"\n        )\n</code></pre>"},{"location":"reference/core/__init__/#textxtract.core.utils.validate_filename","title":"validate_filename","text":"<pre><code>validate_filename(filename)\n</code></pre> <p>Validate filename for security issues.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def validate_filename(filename: str) -&gt; None:\n    \"\"\"Validate filename for security issues.\"\"\"\n    if not filename:\n        raise ValueError(\"Filename cannot be empty\")\n\n    # Check for null bytes\n    if \"\\x00\" in filename:\n        raise ValueError(f\"Invalid filename: contains null byte\")\n\n    # Check for path traversal attempts\n    if \"..\" in filename:\n        raise ValueError(f\"Invalid filename: path traversal detected\")\n\n    # Check for absolute paths (both Unix and Windows)\n    if filename.startswith(\"/\") or (len(filename) &gt; 1 and filename[1] == \":\"):\n        raise ValueError(f\"Invalid filename: absolute path not allowed\")\n\n    # Check for Windows path separators in suspicious contexts\n    if \"\\\\\" in filename and (\"..\" in filename or filename.count(\"\\\\\") &gt; 2):\n        raise ValueError(f\"Invalid filename: suspicious path structure\")\n\n    # Check filename length\n    if len(filename) &gt; 255:\n        raise ValueError(\"Filename too long\")\n</code></pre>"},{"location":"reference/core/base/","title":"Base Module","text":"<p>Abstract base classes for text extraction.</p> <p>Classes:</p> Name Description <code>FileTypeHandler</code> <p>Abstract base class for file type-specific handlers.</p> <code>TextExtractor</code> <p>Abstract base class for text extractors.</p>"},{"location":"reference/core/base/#textxtract.core.base-classes","title":"Classes","text":""},{"location":"reference/core/base/#textxtract.core.base.FileTypeHandler","title":"FileTypeHandler","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for file type-specific handlers.</p> <p>Methods:</p> Name Description <code>extract</code> <p>Extract text synchronously from a file.</p> <code>extract_async</code> <p>Extract text asynchronously from a file.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>class FileTypeHandler(ABC):\n    \"\"\"Abstract base class for file type-specific handlers.\"\"\"\n\n    @abstractmethod\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        \"\"\"Extract text synchronously from a file.\"\"\"\n        pass\n\n    @abstractmethod\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"Extract text asynchronously from a file.\"\"\"\n        pass\n</code></pre>"},{"location":"reference/core/base/#textxtract.core.base.FileTypeHandler-functions","title":"Functions","text":""},{"location":"reference/core/base/#textxtract.core.base.FileTypeHandler.extract","title":"extract  <code>abstractmethod</code>","text":"<pre><code>extract(file_path, config=None)\n</code></pre> <p>Extract text synchronously from a file.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>@abstractmethod\ndef extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    \"\"\"Extract text synchronously from a file.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/base/#textxtract.core.base.FileTypeHandler.extract_async","title":"extract_async  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>extract_async(file_path, config=None)\n</code></pre> <p>Extract text asynchronously from a file.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>@abstractmethod\nasync def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"Extract text asynchronously from a file.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/base/#textxtract.core.base.TextExtractor","title":"TextExtractor","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for text extractors.</p> <p>Methods:</p> Name Description <code>extract</code> <p>Extract text synchronously from file bytes.</p> <code>extract_async</code> <p>Extract text asynchronously from file bytes.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>class TextExtractor(ABC):\n    \"\"\"Abstract base class for text extractors.\"\"\"\n\n    @abstractmethod\n    def extract(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"Extract text synchronously from file bytes.\"\"\"\n        pass\n\n    @abstractmethod\n    async def extract_async(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"Extract text asynchronously from file bytes.\"\"\"\n        pass\n</code></pre>"},{"location":"reference/core/base/#textxtract.core.base.TextExtractor-functions","title":"Functions","text":""},{"location":"reference/core/base/#textxtract.core.base.TextExtractor.extract","title":"extract  <code>abstractmethod</code>","text":"<pre><code>extract(file_bytes, filename, config=None)\n</code></pre> <p>Extract text synchronously from file bytes.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>@abstractmethod\ndef extract(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"Extract text synchronously from file bytes.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/base/#textxtract.core.base.TextExtractor.extract_async","title":"extract_async  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>extract_async(file_bytes, filename, config=None)\n</code></pre> <p>Extract text asynchronously from file bytes.</p> Source code in <code>textxtract/core/base.py</code> <pre><code>@abstractmethod\nasync def extract_async(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"Extract text asynchronously from file bytes.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/config/","title":"Config Module","text":"<p>Configuration and customization for textxtract package.</p> <p>Classes:</p> Name Description <code>ExtractorConfig</code> <p>Enhanced configuration options for text extraction with validation.</p>"},{"location":"reference/core/config/#textxtract.core.config-classes","title":"Classes","text":""},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig","title":"ExtractorConfig","text":"<p>Enhanced configuration options for text extraction with validation.</p> <p>Methods:</p> Name Description <code>__init__</code> <code>__repr__</code> <code>from_file</code> <p>Load configuration from a file (JSON, YAML, or TOML).</p> <code>get_handler</code> <p>Retrieve a handler for a given file extension.</p> <code>get_handler_config</code> <p>Get configuration specific to a handler.</p> <code>register_handler</code> <p>Register a custom file type handler.</p> <code>to_dict</code> <p>Convert configuration to dictionary.</p> <p>Attributes:</p> Name Type Description <code>custom_handlers</code> <code>encoding</code> <code>extra_config</code> <code>logging_format</code> <code>logging_level</code> <code>max_file_size</code> <code>max_memory_usage</code> <code>timeout</code> Source code in <code>textxtract/core/config.py</code> <pre><code>class ExtractorConfig:\n    \"\"\"Enhanced configuration options for text extraction with validation.\"\"\"\n\n    def __init__(\n        self,\n        encoding: str = \"utf-8\",\n        logging_level: str = \"INFO\",\n        logging_format: Optional[str] = None,\n        timeout: Optional[float] = None,\n        max_file_size: Optional[int] = None,\n        max_memory_usage: Optional[int] = None,\n        custom_handlers: Optional[Dict[str, Callable]] = None,\n        **kwargs,\n    ):\n        # Validate and set basic options\n        self.encoding = self._validate_encoding(encoding)\n        self.logging_level = self._validate_logging_level(logging_level)\n        self.logging_format = (\n            logging_format or \"%(asctime)s %(levelname)s %(name)s: %(message)s\"\n        )\n        self.timeout = self._validate_timeout(timeout)\n        self.max_file_size = self._validate_max_file_size(max_file_size)\n        self.max_memory_usage = max_memory_usage\n        self.custom_handlers = custom_handlers or {}\n\n        # Load from environment variables\n        self._load_from_env()\n\n        # Store additional kwargs for handler-specific config\n        self.extra_config = kwargs\n\n    def _validate_encoding(self, encoding: str) -&gt; str:\n        \"\"\"Validate encoding parameter.\"\"\"\n        if not isinstance(encoding, str):\n            raise ValueError(\"Encoding must be a string\")\n\n        # Test if encoding is valid\n        try:\n            \"test\".encode(encoding)\n        except LookupError:\n            raise ValueError(f\"Invalid encoding: {encoding}\")\n\n        return encoding\n\n    def _validate_logging_level(self, level: str) -&gt; str:\n        \"\"\"Validate logging level parameter.\"\"\"\n        valid_levels = {\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"}\n        if level.upper() not in valid_levels:\n            raise ValueError(\n                f\"Invalid logging level: {level}. Must be one of {valid_levels}\"\n            )\n        return level.upper()\n\n    def _validate_timeout(self, timeout: Optional[float]) -&gt; Optional[float]:\n        \"\"\"Validate timeout parameter.\"\"\"\n        if timeout is not None:\n            if not isinstance(timeout, (int, float)) or timeout &lt;= 0:\n                raise ValueError(\"Timeout must be a positive number\")\n        return timeout\n\n    def _validate_max_file_size(self, size: Optional[int]) -&gt; Optional[int]:\n        \"\"\"Validate max file size parameter.\"\"\"\n        if size is not None:\n            if not isinstance(size, int) or size &lt;= 0:\n                raise ValueError(\"Max file size must be a positive integer\")\n        return size\n\n    def _load_from_env(self):\n        \"\"\"Load configuration from environment variables.\"\"\"\n        # Override with environment variables if present\n        env_encoding = os.getenv(\"TEXT_EXTRACTOR_ENCODING\")\n        if env_encoding:\n            self.encoding = self._validate_encoding(env_encoding)\n\n        env_logging = os.getenv(\"TEXT_EXTRACTOR_LOG_LEVEL\")\n        if env_logging:\n            self.logging_level = self._validate_logging_level(env_logging)\n\n        env_timeout = os.getenv(\"TEXT_EXTRACTOR_TIMEOUT\")\n        if env_timeout:\n            try:\n                self.timeout = float(env_timeout)\n            except ValueError:\n                pass  # Ignore invalid values\n\n        env_max_size = os.getenv(\"TEXT_EXTRACTOR_MAX_FILE_SIZE\")\n        if env_max_size:\n            try:\n                self.max_file_size = int(env_max_size)\n            except ValueError:\n                pass  # Ignore invalid values\n\n    def register_handler(self, extension: str, handler: Callable):\n        \"\"\"Register a custom file type handler.\"\"\"\n        if not extension.startswith(\".\"):\n            extension = f\".{extension}\"\n        self.custom_handlers[extension.lower()] = handler\n\n    def get_handler(self, extension: str) -&gt; Optional[Callable]:\n        \"\"\"Retrieve a handler for a given file extension.\"\"\"\n        return self.custom_handlers.get(extension.lower())\n\n    def get_handler_config(self, handler_name: str) -&gt; Dict[str, Any]:\n        \"\"\"Get configuration specific to a handler.\"\"\"\n        base_config = {\n            \"encoding\": self.encoding,\n            \"timeout\": self.timeout,\n            \"max_file_size\": self.max_file_size,\n            \"max_memory_usage\": self.max_memory_usage,\n        }\n\n        # Add handler-specific config\n        handler_config_key = f\"{handler_name.lower()}_config\"\n        if handler_config_key in self.extra_config:\n            base_config.update(self.extra_config[handler_config_key])\n\n        return base_config\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert configuration to dictionary.\"\"\"\n        return {\n            \"encoding\": self.encoding,\n            \"logging_level\": self.logging_level,\n            \"logging_format\": self.logging_format,\n            \"timeout\": self.timeout,\n            \"max_file_size\": self.max_file_size,\n            \"max_memory_usage\": self.max_memory_usage,\n            \"custom_handlers\": {k: str(v) for k, v in self.custom_handlers.items()},\n            **self.extra_config,\n        }\n\n    @classmethod\n    def from_file(cls, config_path: Union[str, Path]) -&gt; \"ExtractorConfig\":\n        \"\"\"Load configuration from a file (JSON, YAML, or TOML).\"\"\"\n        config_path = Path(config_path)\n\n        if not config_path.exists():\n            raise FileNotFoundError(f\"Configuration file not found: {config_path}\")\n\n        content = config_path.read_text()\n\n        if config_path.suffix.lower() == \".json\":\n            import json\n\n            config_data = json.loads(content)\n        elif config_path.suffix.lower() in (\".yaml\", \".yml\"):\n            try:\n                import yaml\n\n                config_data = yaml.safe_load(content)\n            except ImportError:\n                raise ImportError(\"PyYAML is required to load YAML configuration files\")\n        elif config_path.suffix.lower() == \".toml\":\n            try:\n                import tomli\n\n                config_data = tomli.loads(content)\n            except ImportError:\n                raise ImportError(\"tomli is required to load TOML configuration files\")\n        else:\n            raise ValueError(\n                f\"Unsupported configuration file format: {config_path.suffix}\"\n            )\n\n        return cls(**config_data)\n\n    def __repr__(self) -&gt; str:\n        return f\"ExtractorConfig(encoding='{self.encoding}', logging_level='{self.logging_level}', timeout={self.timeout})\"\n</code></pre>"},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig-attributes","title":"Attributes","text":""},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig.custom_handlers","title":"custom_handlers  <code>instance-attribute</code>","text":"<pre><code>custom_handlers = custom_handlers or {}\n</code></pre>"},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig.encoding","title":"encoding  <code>instance-attribute</code>","text":"<pre><code>encoding = _validate_encoding(encoding)\n</code></pre>"},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig.extra_config","title":"extra_config  <code>instance-attribute</code>","text":"<pre><code>extra_config = kwargs\n</code></pre>"},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig.logging_format","title":"logging_format  <code>instance-attribute</code>","text":"<pre><code>logging_format = logging_format or '%(asctime)s %(levelname)s %(name)s: %(message)s'\n</code></pre>"},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig.logging_level","title":"logging_level  <code>instance-attribute</code>","text":"<pre><code>logging_level = _validate_logging_level(logging_level)\n</code></pre>"},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig.max_file_size","title":"max_file_size  <code>instance-attribute</code>","text":"<pre><code>max_file_size = _validate_max_file_size(max_file_size)\n</code></pre>"},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig.max_memory_usage","title":"max_memory_usage  <code>instance-attribute</code>","text":"<pre><code>max_memory_usage = max_memory_usage\n</code></pre>"},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig.timeout","title":"timeout  <code>instance-attribute</code>","text":"<pre><code>timeout = _validate_timeout(timeout)\n</code></pre>"},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig-functions","title":"Functions","text":""},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig.__init__","title":"__init__","text":"<pre><code>__init__(encoding='utf-8', logging_level='INFO', logging_format=None, timeout=None, max_file_size=None, max_memory_usage=None, custom_handlers=None, **kwargs)\n</code></pre> Source code in <code>textxtract/core/config.py</code> <pre><code>def __init__(\n    self,\n    encoding: str = \"utf-8\",\n    logging_level: str = \"INFO\",\n    logging_format: Optional[str] = None,\n    timeout: Optional[float] = None,\n    max_file_size: Optional[int] = None,\n    max_memory_usage: Optional[int] = None,\n    custom_handlers: Optional[Dict[str, Callable]] = None,\n    **kwargs,\n):\n    # Validate and set basic options\n    self.encoding = self._validate_encoding(encoding)\n    self.logging_level = self._validate_logging_level(logging_level)\n    self.logging_format = (\n        logging_format or \"%(asctime)s %(levelname)s %(name)s: %(message)s\"\n    )\n    self.timeout = self._validate_timeout(timeout)\n    self.max_file_size = self._validate_max_file_size(max_file_size)\n    self.max_memory_usage = max_memory_usage\n    self.custom_handlers = custom_handlers or {}\n\n    # Load from environment variables\n    self._load_from_env()\n\n    # Store additional kwargs for handler-specific config\n    self.extra_config = kwargs\n</code></pre>"},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> Source code in <code>textxtract/core/config.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f\"ExtractorConfig(encoding='{self.encoding}', logging_level='{self.logging_level}', timeout={self.timeout})\"\n</code></pre>"},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(config_path)\n</code></pre> <p>Load configuration from a file (JSON, YAML, or TOML).</p> Source code in <code>textxtract/core/config.py</code> <pre><code>@classmethod\ndef from_file(cls, config_path: Union[str, Path]) -&gt; \"ExtractorConfig\":\n    \"\"\"Load configuration from a file (JSON, YAML, or TOML).\"\"\"\n    config_path = Path(config_path)\n\n    if not config_path.exists():\n        raise FileNotFoundError(f\"Configuration file not found: {config_path}\")\n\n    content = config_path.read_text()\n\n    if config_path.suffix.lower() == \".json\":\n        import json\n\n        config_data = json.loads(content)\n    elif config_path.suffix.lower() in (\".yaml\", \".yml\"):\n        try:\n            import yaml\n\n            config_data = yaml.safe_load(content)\n        except ImportError:\n            raise ImportError(\"PyYAML is required to load YAML configuration files\")\n    elif config_path.suffix.lower() == \".toml\":\n        try:\n            import tomli\n\n            config_data = tomli.loads(content)\n        except ImportError:\n            raise ImportError(\"tomli is required to load TOML configuration files\")\n    else:\n        raise ValueError(\n            f\"Unsupported configuration file format: {config_path.suffix}\"\n        )\n\n    return cls(**config_data)\n</code></pre>"},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig.get_handler","title":"get_handler","text":"<pre><code>get_handler(extension)\n</code></pre> <p>Retrieve a handler for a given file extension.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def get_handler(self, extension: str) -&gt; Optional[Callable]:\n    \"\"\"Retrieve a handler for a given file extension.\"\"\"\n    return self.custom_handlers.get(extension.lower())\n</code></pre>"},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig.get_handler_config","title":"get_handler_config","text":"<pre><code>get_handler_config(handler_name)\n</code></pre> <p>Get configuration specific to a handler.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def get_handler_config(self, handler_name: str) -&gt; Dict[str, Any]:\n    \"\"\"Get configuration specific to a handler.\"\"\"\n    base_config = {\n        \"encoding\": self.encoding,\n        \"timeout\": self.timeout,\n        \"max_file_size\": self.max_file_size,\n        \"max_memory_usage\": self.max_memory_usage,\n    }\n\n    # Add handler-specific config\n    handler_config_key = f\"{handler_name.lower()}_config\"\n    if handler_config_key in self.extra_config:\n        base_config.update(self.extra_config[handler_config_key])\n\n    return base_config\n</code></pre>"},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig.register_handler","title":"register_handler","text":"<pre><code>register_handler(extension, handler)\n</code></pre> <p>Register a custom file type handler.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def register_handler(self, extension: str, handler: Callable):\n    \"\"\"Register a custom file type handler.\"\"\"\n    if not extension.startswith(\".\"):\n        extension = f\".{extension}\"\n    self.custom_handlers[extension.lower()] = handler\n</code></pre>"},{"location":"reference/core/config/#textxtract.core.config.ExtractorConfig.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert configuration to dictionary.</p> Source code in <code>textxtract/core/config.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert configuration to dictionary.\"\"\"\n    return {\n        \"encoding\": self.encoding,\n        \"logging_level\": self.logging_level,\n        \"logging_format\": self.logging_format,\n        \"timeout\": self.timeout,\n        \"max_file_size\": self.max_file_size,\n        \"max_memory_usage\": self.max_memory_usage,\n        \"custom_handlers\": {k: str(v) for k, v in self.custom_handlers.items()},\n        **self.extra_config,\n    }\n</code></pre>"},{"location":"reference/core/exceptions/","title":"Exceptions Module","text":"<p>Custom exceptions for textxtract package.</p> <p>Classes:</p> Name Description <code>ExtractionError</code> <p>Raised when a general extraction error occurs.</p> <code>ExtractionTimeoutError</code> <p>Raised when extraction exceeds the allowed timeout.</p> <code>FileTypeNotSupportedError</code> <p>Raised when the file type is not supported.</p> <code>InvalidFileError</code> <p>Raised when the file is invalid or unsupported.</p>"},{"location":"reference/core/exceptions/#textxtract.core.exceptions-classes","title":"Classes","text":""},{"location":"reference/core/exceptions/#textxtract.core.exceptions.ExtractionError","title":"ExtractionError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when a general extraction error occurs.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class ExtractionError(Exception):\n    \"\"\"Raised when a general extraction error occurs.\"\"\"\n</code></pre>"},{"location":"reference/core/exceptions/#textxtract.core.exceptions.ExtractionTimeoutError","title":"ExtractionTimeoutError","text":"<p>               Bases: <code>ExtractionError</code></p> <p>Raised when extraction exceeds the allowed timeout.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class ExtractionTimeoutError(ExtractionError):\n    \"\"\"Raised when extraction exceeds the allowed timeout.\"\"\"\n</code></pre>"},{"location":"reference/core/exceptions/#textxtract.core.exceptions.FileTypeNotSupportedError","title":"FileTypeNotSupportedError","text":"<p>               Bases: <code>ExtractionError</code></p> <p>Raised when the file type is not supported.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class FileTypeNotSupportedError(ExtractionError):\n    \"\"\"Raised when the file type is not supported.\"\"\"\n</code></pre>"},{"location":"reference/core/exceptions/#textxtract.core.exceptions.InvalidFileError","title":"InvalidFileError","text":"<p>               Bases: <code>ExtractionError</code></p> <p>Raised when the file is invalid or unsupported.</p> Source code in <code>textxtract/core/exceptions.py</code> <pre><code>class InvalidFileError(ExtractionError):\n    \"\"\"Raised when the file is invalid or unsupported.\"\"\"\n</code></pre>"},{"location":"reference/core/logging_config/","title":"Logging_Config Module","text":"<p>Logging configuration for textxtract package.</p> <p>Functions:</p> Name Description <code>setup_logging</code> <p>Configure logging for the package.</p>"},{"location":"reference/core/logging_config/#textxtract.core.logging_config-functions","title":"Functions","text":""},{"location":"reference/core/logging_config/#textxtract.core.logging_config.setup_logging","title":"setup_logging","text":"<pre><code>setup_logging(level='INFO', fmt='%(asctime)s %(levelname)s %(name)s: %(message)s')\n</code></pre> <p>Configure logging for the package.</p> Source code in <code>textxtract/core/logging_config.py</code> <pre><code>def setup_logging(\n    level: str = \"INFO\", fmt: str = \"%(asctime)s %(levelname)s %(name)s: %(message)s\"\n):\n    \"\"\"Configure logging for the package.\"\"\"\n    logging.basicConfig(level=getattr(logging, level.upper(), logging.INFO), format=fmt)\n</code></pre>"},{"location":"reference/core/registry/","title":"Registry Module","text":"<p>Handler registry for centralized handler management.</p> <p>Classes:</p> Name Description <code>HandlerRegistry</code> <p>Central registry for file type handlers with caching and lazy loading.</p> <p>Attributes:</p> Name Type Description <code>logger</code> <code>registry</code>"},{"location":"reference/core/registry/#textxtract.core.registry-attributes","title":"Attributes","text":""},{"location":"reference/core/registry/#textxtract.core.registry.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger('textxtract.registry')\n</code></pre>"},{"location":"reference/core/registry/#textxtract.core.registry.registry","title":"registry  <code>module-attribute</code>","text":"<pre><code>registry = HandlerRegistry()\n</code></pre>"},{"location":"reference/core/registry/#textxtract.core.registry-classes","title":"Classes","text":""},{"location":"reference/core/registry/#textxtract.core.registry.HandlerRegistry","title":"HandlerRegistry","text":"<p>Central registry for file type handlers with caching and lazy loading.</p> <p>Methods:</p> Name Description <code>__init__</code> <code>__new__</code> <code>get_handler</code> <p>Get handler instance for file extension with caching.</p> <code>get_supported_extensions</code> <p>Get list of all supported file extensions.</p> <code>is_supported</code> <p>Check if a file extension is supported.</p> <code>register_handler</code> <p>Register a custom handler for a file extension.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>class HandlerRegistry:\n    \"\"\"Central registry for file type handlers with caching and lazy loading.\"\"\"\n\n    _instance: Optional[\"HandlerRegistry\"] = None\n    _handlers: Dict[str, Type[FileTypeHandler]] = {}\n    _initialized = False\n\n    def __new__(cls) -&gt; \"HandlerRegistry\":\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n    def __init__(self):\n        if not self._initialized:\n            self._load_default_handlers()\n            self._initialized = True\n\n    def _load_default_handlers(self):\n        \"\"\"Load default handlers with lazy imports.\"\"\"\n        # Import handlers at runtime to support optional dependencies\n        try:\n            from textxtract.handlers.pdf import PDFHandler\n\n            self._handlers[\".pdf\"] = PDFHandler\n        except ImportError:\n            logger.debug(\"PDF handler not available - pymupdf not installed\")\n\n        try:\n            from textxtract.handlers.docx import DOCXHandler\n\n            self._handlers[\".docx\"] = DOCXHandler\n        except ImportError:\n            logger.debug(\"DOCX handler not available - python-docx not installed\")\n\n        try:\n            from textxtract.handlers.doc import DOCHandler\n\n            self._handlers[\".doc\"] = DOCHandler\n        except ImportError:\n            logger.debug(\"DOC handler not available - antiword not installed\")\n\n        # Always available handlers\n        from textxtract.handlers.txt import TXTHandler\n        from textxtract.handlers.zip import ZIPHandler\n\n        self._handlers[\".txt\"] = TXTHandler\n        self._handlers[\".text\"] = TXTHandler\n        self._handlers[\".zip\"] = ZIPHandler\n\n        # Optional handlers with graceful fallback\n        try:\n            from textxtract.handlers.md import MDHandler\n\n            self._handlers[\".md\"] = MDHandler\n        except ImportError:\n            logger.debug(\"MD handler not available - markdown not installed\")\n\n        try:\n            from textxtract.handlers.rtf import RTFHandler\n\n            self._handlers[\".rtf\"] = RTFHandler\n        except ImportError:\n            logger.debug(\"RTF handler not available - pyrtf-ng not installed\")\n\n        try:\n            from textxtract.handlers.html import HTMLHandler\n\n            self._handlers[\".html\"] = HTMLHandler\n            self._handlers[\".htm\"] = HTMLHandler\n        except ImportError:\n            logger.debug(\"HTML handler not available - beautifulsoup4 not installed\")\n\n        # Standard library handlers\n        from textxtract.handlers.csv import CSVHandler\n        from textxtract.handlers.json import JSONHandler\n\n        self._handlers[\".csv\"] = CSVHandler\n        self._handlers[\".json\"] = JSONHandler\n\n        try:\n            from textxtract.handlers.xml import XMLHandler\n\n            self._handlers[\".xml\"] = XMLHandler\n        except ImportError:\n            logger.debug(\"XML handler not available - lxml not installed\")\n\n    @lru_cache(maxsize=128)\n    def get_handler(self, extension: str) -&gt; FileTypeHandler:\n        \"\"\"Get handler instance for file extension with caching.\"\"\"\n        ext = extension.lower()\n        handler_cls = self._handlers.get(ext)\n\n        if not handler_cls:\n            available = list(self._handlers.keys())\n            raise FileTypeNotSupportedError(\n                f\"Unsupported file extension: {ext}. \"\n                f\"Supported extensions: {', '.join(available)}\"\n            )\n\n        # Create handler instance (handlers are lightweight and stateless)\n        return handler_cls()\n\n    def register_handler(self, extension: str, handler_cls: Type[FileTypeHandler]):\n        \"\"\"Register a custom handler for a file extension.\"\"\"\n        ext = extension.lower()\n        if not ext.startswith(\".\"):\n            ext = f\".{ext}\"\n\n        self._handlers[ext] = handler_cls\n        # Clear cache when new handlers are registered\n        self.get_handler.cache_clear()\n        logger.info(\n            \"Registered custom handler %s for extension %s\", handler_cls.__name__, ext\n        )\n\n    def get_supported_extensions(self) -&gt; List[str]:\n        \"\"\"Get list of all supported file extensions.\"\"\"\n        return list(self._handlers.keys())\n\n    def is_supported(self, extension: str) -&gt; bool:\n        \"\"\"Check if a file extension is supported.\"\"\"\n        return extension.lower() in self._handlers\n</code></pre>"},{"location":"reference/core/registry/#textxtract.core.registry.HandlerRegistry-functions","title":"Functions","text":""},{"location":"reference/core/registry/#textxtract.core.registry.HandlerRegistry.__init__","title":"__init__","text":"<pre><code>__init__()\n</code></pre> Source code in <code>textxtract/core/registry.py</code> <pre><code>def __init__(self):\n    if not self._initialized:\n        self._load_default_handlers()\n        self._initialized = True\n</code></pre>"},{"location":"reference/core/registry/#textxtract.core.registry.HandlerRegistry.__new__","title":"__new__","text":"<pre><code>__new__()\n</code></pre> Source code in <code>textxtract/core/registry.py</code> <pre><code>def __new__(cls) -&gt; \"HandlerRegistry\":\n    if cls._instance is None:\n        cls._instance = super().__new__(cls)\n    return cls._instance\n</code></pre>"},{"location":"reference/core/registry/#textxtract.core.registry.HandlerRegistry.get_handler","title":"get_handler  <code>cached</code>","text":"<pre><code>get_handler(extension)\n</code></pre> <p>Get handler instance for file extension with caching.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>@lru_cache(maxsize=128)\ndef get_handler(self, extension: str) -&gt; FileTypeHandler:\n    \"\"\"Get handler instance for file extension with caching.\"\"\"\n    ext = extension.lower()\n    handler_cls = self._handlers.get(ext)\n\n    if not handler_cls:\n        available = list(self._handlers.keys())\n        raise FileTypeNotSupportedError(\n            f\"Unsupported file extension: {ext}. \"\n            f\"Supported extensions: {', '.join(available)}\"\n        )\n\n    # Create handler instance (handlers are lightweight and stateless)\n    return handler_cls()\n</code></pre>"},{"location":"reference/core/registry/#textxtract.core.registry.HandlerRegistry.get_supported_extensions","title":"get_supported_extensions","text":"<pre><code>get_supported_extensions()\n</code></pre> <p>Get list of all supported file extensions.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>def get_supported_extensions(self) -&gt; List[str]:\n    \"\"\"Get list of all supported file extensions.\"\"\"\n    return list(self._handlers.keys())\n</code></pre>"},{"location":"reference/core/registry/#textxtract.core.registry.HandlerRegistry.is_supported","title":"is_supported","text":"<pre><code>is_supported(extension)\n</code></pre> <p>Check if a file extension is supported.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>def is_supported(self, extension: str) -&gt; bool:\n    \"\"\"Check if a file extension is supported.\"\"\"\n    return extension.lower() in self._handlers\n</code></pre>"},{"location":"reference/core/registry/#textxtract.core.registry.HandlerRegistry.register_handler","title":"register_handler","text":"<pre><code>register_handler(extension, handler_cls)\n</code></pre> <p>Register a custom handler for a file extension.</p> Source code in <code>textxtract/core/registry.py</code> <pre><code>def register_handler(self, extension: str, handler_cls: Type[FileTypeHandler]):\n    \"\"\"Register a custom handler for a file extension.\"\"\"\n    ext = extension.lower()\n    if not ext.startswith(\".\"):\n        ext = f\".{ext}\"\n\n    self._handlers[ext] = handler_cls\n    # Clear cache when new handlers are registered\n    self.get_handler.cache_clear()\n    logger.info(\n        \"Registered custom handler %s for extension %s\", handler_cls.__name__, ext\n    )\n</code></pre>"},{"location":"reference/core/utils/","title":"Utils Module","text":"<p>Utility functions for textxtract package.</p> <p>Functions:</p> Name Description <code>create_temp_file</code> <p>Create a temporary file from bytes and return its path with security validation.</p> <code>get_file_info</code> <p>Get basic file information for logging and debugging.</p> <code>safe_unlink</code> <p>Safely delete a file if it exists, optionally logging errors.</p> <code>validate_file_extension</code> <p>Check if the file has an allowed extension.</p> <code>validate_file_size</code> <p>Validate file size doesn't exceed limits.</p> <code>validate_filename</code> <p>Validate filename for security issues.</p> <p>Attributes:</p> Name Type Description <code>DEFAULT_MAX_FILE_SIZE</code> <code>DEFAULT_MAX_TEMP_FILES</code>"},{"location":"reference/core/utils/#textxtract.core.utils-attributes","title":"Attributes","text":""},{"location":"reference/core/utils/#textxtract.core.utils.DEFAULT_MAX_FILE_SIZE","title":"DEFAULT_MAX_FILE_SIZE  <code>module-attribute</code>","text":"<pre><code>DEFAULT_MAX_FILE_SIZE = 100 * 1024 * 1024\n</code></pre>"},{"location":"reference/core/utils/#textxtract.core.utils.DEFAULT_MAX_TEMP_FILES","title":"DEFAULT_MAX_TEMP_FILES  <code>module-attribute</code>","text":"<pre><code>DEFAULT_MAX_TEMP_FILES = 1000\n</code></pre>"},{"location":"reference/core/utils/#textxtract.core.utils-functions","title":"Functions","text":""},{"location":"reference/core/utils/#textxtract.core.utils.create_temp_file","title":"create_temp_file","text":"<pre><code>create_temp_file(file_bytes, filename, max_size=None)\n</code></pre> <p>Create a temporary file from bytes and return its path with security validation.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def create_temp_file(\n    file_bytes: bytes, filename: str, max_size: Optional[int] = None\n) -&gt; Path:\n    \"\"\"Create a temporary file from bytes and return its path with security validation.\"\"\"\n    validate_filename(filename)\n    validate_file_size(file_bytes, max_size)\n\n    file_ext = Path(filename).suffix\n    with tempfile.NamedTemporaryFile(delete=False, suffix=file_ext) as temp_file:\n        temp_file.write(file_bytes)\n        temp_path = Path(temp_file.name)\n\n    # Ensure file was created successfully\n    if not temp_path.exists():\n        raise RuntimeError(\"Failed to create temporary file\")\n\n    return temp_path\n</code></pre>"},{"location":"reference/core/utils/#textxtract.core.utils.get_file_info","title":"get_file_info","text":"<pre><code>get_file_info(file_bytes, filename)\n</code></pre> <p>Get basic file information for logging and debugging.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def get_file_info(file_bytes: bytes, filename: str) -&gt; dict:\n    \"\"\"Get basic file information for logging and debugging.\"\"\"\n    return {\n        \"filename\": filename,\n        \"size_bytes\": len(file_bytes),\n        \"size_mb\": round(len(file_bytes) / (1024 * 1024), 2),\n        \"extension\": Path(filename).suffix.lower(),\n    }\n</code></pre>"},{"location":"reference/core/utils/#textxtract.core.utils.safe_unlink","title":"safe_unlink","text":"<pre><code>safe_unlink(path, log_errors=True)\n</code></pre> <p>Safely delete a file if it exists, optionally logging errors.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def safe_unlink(path: Path, log_errors: bool = True) -&gt; bool:\n    \"\"\"Safely delete a file if it exists, optionally logging errors.\"\"\"\n    try:\n        if path.exists():\n            path.unlink()\n            return True\n        return False\n    except Exception as e:\n        if log_errors:\n            import logging\n\n            logger = logging.getLogger(\"textxtract.utils\")\n            logger.warning(\"Failed to delete temporary file %s: %s\", path, e)\n        return False\n</code></pre>"},{"location":"reference/core/utils/#textxtract.core.utils.validate_file_extension","title":"validate_file_extension","text":"<pre><code>validate_file_extension(filename, allowed_extensions)\n</code></pre> <p>Check if the file has an allowed extension.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def validate_file_extension(filename: str, allowed_extensions: list[str]) -&gt; bool:\n    \"\"\"Check if the file has an allowed extension.\"\"\"\n    return Path(filename).suffix.lower() in allowed_extensions\n</code></pre>"},{"location":"reference/core/utils/#textxtract.core.utils.validate_file_size","title":"validate_file_size","text":"<pre><code>validate_file_size(file_bytes, max_size=None)\n</code></pre> <p>Validate file size doesn't exceed limits.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def validate_file_size(file_bytes: bytes, max_size: Optional[int] = None) -&gt; None:\n    \"\"\"Validate file size doesn't exceed limits.\"\"\"\n    max_size = max_size or DEFAULT_MAX_FILE_SIZE\n    if len(file_bytes) == 0:\n        raise ValueError(\"File is empty (0 bytes)\")\n    if len(file_bytes) &gt; max_size:\n        raise ValueError(\n            f\"File size ({len(file_bytes):,} bytes) exceeds maximum \"\n            f\"allowed size ({max_size:,} bytes)\"\n        )\n</code></pre>"},{"location":"reference/core/utils/#textxtract.core.utils.validate_filename","title":"validate_filename","text":"<pre><code>validate_filename(filename)\n</code></pre> <p>Validate filename for security issues.</p> Source code in <code>textxtract/core/utils.py</code> <pre><code>def validate_filename(filename: str) -&gt; None:\n    \"\"\"Validate filename for security issues.\"\"\"\n    if not filename:\n        raise ValueError(\"Filename cannot be empty\")\n\n    # Check for null bytes\n    if \"\\x00\" in filename:\n        raise ValueError(f\"Invalid filename: contains null byte\")\n\n    # Check for path traversal attempts\n    if \"..\" in filename:\n        raise ValueError(f\"Invalid filename: path traversal detected\")\n\n    # Check for absolute paths (both Unix and Windows)\n    if filename.startswith(\"/\") or (len(filename) &gt; 1 and filename[1] == \":\"):\n        raise ValueError(f\"Invalid filename: absolute path not allowed\")\n\n    # Check for Windows path separators in suspicious contexts\n    if \"\\\\\" in filename and (\"..\" in filename or filename.count(\"\\\\\") &gt; 2):\n        raise ValueError(f\"Invalid filename: suspicious path structure\")\n\n    # Check filename length\n    if len(filename) &gt; 255:\n        raise ValueError(\"Filename too long\")\n</code></pre>"},{"location":"reference/handlers/","title":"Handlers Module","text":""},{"location":"reference/handlers/#overview","title":"Overview","text":"<p>File format handlers for different document types.</p> <ul> <li>CSV Handler - CSV file format handler</li> <li>DOC Handler - DOC file format handler</li> <li>DOCX Handler - DOCX file format handler</li> <li>HTML Handler - HTML file format handler</li> <li>JSON Handler - JSON file format handler</li> <li>MD Handler - MD file format handler</li> <li>PDF Handler - PDF file format handler</li> <li>RTF Handler - RTF file format handler</li> <li>TXT Handler - TXT file format handler</li> <li>XML Handler - XML file format handler</li> <li>ZIP Handler - ZIP file format handler</li> </ul> <p>File type-specific handlers package.</p> <p>Modules:</p> Name Description <code>csv</code> <p>CSV file handler for text extraction.</p> <code>doc</code> <p>DOC file handler for text extraction.</p> <code>docx</code> <p>DOCX file handler for text extraction.</p> <code>html</code> <p>HTML file handler for text extraction.</p> <code>json</code> <p>JSON file handler for text extraction.</p> <code>md</code> <p>Markdown (.md) file handler for text extraction.</p> <code>pdf</code> <p>PDF file handler for text extraction.</p> <code>rtf</code> <p>RTF file handler for text extraction.</p> <code>txt</code> <p>TXT file handler for text extraction.</p> <code>xml</code> <p>XML file handler for text extraction.</p> <code>zip</code> <p>ZIP file handler for text extraction.</p>"},{"location":"reference/handlers/#textxtract.handlers-modules","title":"Modules","text":""},{"location":"reference/handlers/#textxtract.handlers.csv","title":"csv","text":"<p>CSV file handler for text extraction.</p> <p>Classes:</p> Name Description <code>CSVHandler</code> <p>Handler for extracting text from CSV files.</p>"},{"location":"reference/handlers/#textxtract.handlers.csv-classes","title":"Classes","text":""},{"location":"reference/handlers/#textxtract.handlers.csv.CSVHandler","title":"CSVHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from CSV files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/csv.py</code> <pre><code>class CSVHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from CSV files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            encoding = (config or {}).get(\"encoding\", \"utf-8\")\n            with open(file_path, \"r\", encoding=encoding, newline=\"\") as f:\n                reader = csv.reader(f)\n                return \"\\n\".join([\", \".join(row) for row in reader])\n        except Exception as e:\n            raise ExtractionError(f\"CSV extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.csv.CSVHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/csv.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        with open(file_path, \"r\", encoding=encoding, newline=\"\") as f:\n            reader = csv.reader(f)\n            return \"\\n\".join([\", \".join(row) for row in reader])\n    except Exception as e:\n        raise ExtractionError(f\"CSV extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/csv.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.doc","title":"doc","text":"<p>DOC file handler for text extraction.</p> <p>Classes:</p> Name Description <code>DOCHandler</code> <p>Handler for extracting text from DOC files with fallback options.</p>"},{"location":"reference/handlers/#textxtract.handlers.doc-classes","title":"Classes","text":""},{"location":"reference/handlers/#textxtract.handlers.doc.DOCHandler","title":"DOCHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from DOC files with fallback options.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/doc.py</code> <pre><code>class DOCHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from DOC files with fallback options.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        # Try antiword first\n        try:\n            return self._extract_with_antiword(file_path)\n        except FileNotFoundError:\n            # Try alternative methods if antiword is not available\n            return self._extract_with_fallback(file_path, config)\n        except Exception as e:\n            if isinstance(e, ExtractionError):\n                raise\n            raise ExtractionError(f\"DOC extraction failed: {e}\")\n\n    def _extract_with_antiword(self, file_path: Path) -&gt; str:\n        \"\"\"Extract text using antiword command.\"\"\"\n        import subprocess\n\n        try:\n            result = subprocess.run(\n                [\"antiword\", str(file_path)],\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n                check=True,\n                timeout=30,  # Add timeout\n            )\n            content = result.stdout.decode(\"utf-8\").strip()\n            if not content:\n                raise ExtractionError(\"antiword returned empty content\")\n            return content\n        except subprocess.TimeoutExpired:\n            raise ExtractionError(\"antiword extraction timed out\")\n        except subprocess.CalledProcessError as e:\n            error_msg = e.stderr.decode() if e.stderr else str(e)\n            raise ExtractionError(f\"antiword extraction failed: {error_msg}\")\n\n    def _extract_with_fallback(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"Fallback extraction methods when antiword is not available.\"\"\"\n\n        # Try python-docx (works for some DOC files)\n        try:\n            from docx import Document\n\n            doc = Document(file_path)\n            text = \"\\n\".join(paragraph.text for paragraph in doc.paragraphs)\n            if text.strip():\n                return text\n        except Exception:\n            pass  # Silent fail, try next method\n\n        # Try reading as binary and looking for text patterns\n        try:\n            with open(file_path, \"rb\") as f:\n                content = f.read()\n\n            # Simple heuristic: look for readable text in the binary\n            text_content = []\n            current_text = []\n\n            for byte in content:\n                if 32 &lt;= byte &lt;= 126:  # Printable ASCII\n                    current_text.append(chr(byte))\n                else:\n                    if len(current_text) &gt; 3:  # Minimum word length\n                        text_content.append(\"\".join(current_text))\n                    current_text = []\n\n            if current_text and len(current_text) &gt; 3:\n                text_content.append(\"\".join(current_text))\n\n            result = \" \".join(text_content)\n            if result.strip():\n                return f\"[Extracted using fallback method - may contain formatting artifacts]\\n{result}\"\n\n        except Exception:\n            pass\n\n        # If all methods fail\n        raise ExtractionError(\n            \"DOC extraction failed. Please install 'antiword' command for better DOC support: \"\n            \"sudo apt-get install antiword (Ubuntu/Debian) or brew install antiword (macOS)\"\n        )\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.doc.DOCHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/doc.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    # Try antiword first\n    try:\n        return self._extract_with_antiword(file_path)\n    except FileNotFoundError:\n        # Try alternative methods if antiword is not available\n        return self._extract_with_fallback(file_path, config)\n    except Exception as e:\n        if isinstance(e, ExtractionError):\n            raise\n        raise ExtractionError(f\"DOC extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/doc.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.docx","title":"docx","text":"<p>DOCX file handler for text extraction.</p> <p>Classes:</p> Name Description <code>DOCXHandler</code> <p>Handler for extracting text from DOCX files.</p>"},{"location":"reference/handlers/#textxtract.handlers.docx-classes","title":"Classes","text":""},{"location":"reference/handlers/#textxtract.handlers.docx.DOCXHandler","title":"DOCXHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from DOCX files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/docx.py</code> <pre><code>class DOCXHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from DOCX files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            from docx import Document\n\n            doc = Document(file_path)\n            return \"\\n\".join(paragraph.text for paragraph in doc.paragraphs)\n        except Exception as e:\n            raise ExtractionError(f\"DOCX extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.docx.DOCXHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/docx.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        from docx import Document\n\n        doc = Document(file_path)\n        return \"\\n\".join(paragraph.text for paragraph in doc.paragraphs)\n    except Exception as e:\n        raise ExtractionError(f\"DOCX extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/docx.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.html","title":"html","text":"<p>HTML file handler for text extraction.</p> <p>Classes:</p> Name Description <code>HTMLHandler</code> <p>Handler for extracting text from HTML files.</p>"},{"location":"reference/handlers/#textxtract.handlers.html-classes","title":"Classes","text":""},{"location":"reference/handlers/#textxtract.handlers.html.HTMLHandler","title":"HTMLHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from HTML files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/html.py</code> <pre><code>class HTMLHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from HTML files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                from bs4 import BeautifulSoup\n            except ImportError:\n                raise ExtractionError(\n                    \"beautifulsoup4 package is not installed. Install with 'pip install text-extractor[html]'\"\n                )\n            text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n            soup = BeautifulSoup(text, \"html.parser\")\n            return soup.get_text()\n        except Exception as e:\n            raise ExtractionError(f\"HTML extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.html.HTMLHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/html.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            from bs4 import BeautifulSoup\n        except ImportError:\n            raise ExtractionError(\n                \"beautifulsoup4 package is not installed. Install with 'pip install text-extractor[html]'\"\n            )\n        text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n        soup = BeautifulSoup(text, \"html.parser\")\n        return soup.get_text()\n    except Exception as e:\n        raise ExtractionError(f\"HTML extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/html.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.json","title":"json","text":"<p>JSON file handler for text extraction.</p> <p>Classes:</p> Name Description <code>JSONHandler</code> <p>Handler for extracting text from JSON files.</p>"},{"location":"reference/handlers/#textxtract.handlers.json-classes","title":"Classes","text":""},{"location":"reference/handlers/#textxtract.handlers.json.JSONHandler","title":"JSONHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from JSON files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/json.py</code> <pre><code>class JSONHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from JSON files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            encoding = (config or {}).get(\"encoding\", \"utf-8\")\n            with open(file_path, \"r\", encoding=encoding) as f:\n                data = json.load(f)\n                # Pretty print JSON as text\n                return json.dumps(data, indent=2, ensure_ascii=False)\n        except Exception as e:\n            raise ExtractionError(f\"JSON extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.json.JSONHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/json.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        with open(file_path, \"r\", encoding=encoding) as f:\n            data = json.load(f)\n            # Pretty print JSON as text\n            return json.dumps(data, indent=2, ensure_ascii=False)\n    except Exception as e:\n        raise ExtractionError(f\"JSON extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/json.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.md","title":"md","text":"<p>Markdown (.md) file handler for text extraction.</p> <p>Classes:</p> Name Description <code>MDHandler</code> <p>Handler for extracting text from Markdown files.</p>"},{"location":"reference/handlers/#textxtract.handlers.md-classes","title":"Classes","text":""},{"location":"reference/handlers/#textxtract.handlers.md.MDHandler","title":"MDHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from Markdown files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/md.py</code> <pre><code>class MDHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from Markdown files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                import markdown\n            except ImportError:\n                raise ExtractionError(\n                    \"markdown package is not installed. Install with 'pip install text-extractor[md]'\"\n                )\n            text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n            # Optionally, convert markdown to plain text (strip HTML)\n            html = markdown.markdown(text)\n            # Remove HTML tags (best effort, fallback to raw text)\n            try:\n                from bs4 import BeautifulSoup\n\n                soup = BeautifulSoup(html, \"html.parser\")\n                return soup.get_text()\n            except ImportError:\n                return text\n        except Exception as e:\n            raise ExtractionError(f\"MD extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.md.MDHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/md.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            import markdown\n        except ImportError:\n            raise ExtractionError(\n                \"markdown package is not installed. Install with 'pip install text-extractor[md]'\"\n            )\n        text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n        # Optionally, convert markdown to plain text (strip HTML)\n        html = markdown.markdown(text)\n        # Remove HTML tags (best effort, fallback to raw text)\n        try:\n            from bs4 import BeautifulSoup\n\n            soup = BeautifulSoup(html, \"html.parser\")\n            return soup.get_text()\n        except ImportError:\n            return text\n    except Exception as e:\n        raise ExtractionError(f\"MD extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/md.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.pdf","title":"pdf","text":"<p>PDF file handler for text extraction.</p> <p>Classes:</p> Name Description <code>PDFHandler</code> <p>Handler for extracting text from PDF files with improved error handling.</p>"},{"location":"reference/handlers/#textxtract.handlers.pdf-classes","title":"Classes","text":""},{"location":"reference/handlers/#textxtract.handlers.pdf.PDFHandler","title":"PDFHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from PDF files with improved error handling.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/pdf.py</code> <pre><code>class PDFHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from PDF files with improved error handling.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                import fitz  # PyMuPDF\n            except ImportError:\n                raise ExtractionError(\n                    \"PyMuPDF package is not installed. Install with 'pip install text-extractor[pdf]'\"\n                )\n\n            doc = fitz.open(file_path)\n            extracted_text = []\n            empty_pages = 0\n\n            for page_num, page in enumerate(doc):\n                page_text = page.get_text(\"text\").strip()\n                if not page_text:\n                    empty_pages += 1\n                    # Try OCR-like text extraction for images\n                    page_text = page.get_text(\"dict\")  # Get structured text\n                    if page_text and \"blocks\" in page_text:\n                        # Check if page has images but no text\n                        has_images = any(\n                            block.get(\"type\") == 1\n                            for block in page_text.get(\"blocks\", [])\n                        )\n                        if has_images:\n                            extracted_text.append(\n                                f\"[Page {page_num + 1}: Contains images but no extractable text]\"\n                            )\n                        else:\n                            extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n                    else:\n                        extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n                else:\n                    extracted_text.append(page_text)\n\n            doc.close()\n\n            # Only raise error if ALL pages are empty and there's no content at all\n            if not any(\n                text.strip() and not text.startswith(\"[Page\") for text in extracted_text\n            ):\n                if empty_pages == len(extracted_text):\n                    raise InvalidFileError(\n                        f\"PDF contains {empty_pages} empty pages with no extractable text. \"\n                        \"This may be a scanned PDF that requires OCR.\"\n                    )\n\n            result = \"\\n\".join(extracted_text)\n            return result\n\n        except fitz.FileDataError as e:\n            raise InvalidFileError(f\"Invalid or corrupted PDF file: {e}\")\n        except fitz.EmptyFileError:\n            raise InvalidFileError(\"PDF file is empty\")\n        except Exception as e:\n            if isinstance(e, (ExtractionError, InvalidFileError)):\n                raise\n            raise ExtractionError(f\"PDF extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.pdf.PDFHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/pdf.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            import fitz  # PyMuPDF\n        except ImportError:\n            raise ExtractionError(\n                \"PyMuPDF package is not installed. Install with 'pip install text-extractor[pdf]'\"\n            )\n\n        doc = fitz.open(file_path)\n        extracted_text = []\n        empty_pages = 0\n\n        for page_num, page in enumerate(doc):\n            page_text = page.get_text(\"text\").strip()\n            if not page_text:\n                empty_pages += 1\n                # Try OCR-like text extraction for images\n                page_text = page.get_text(\"dict\")  # Get structured text\n                if page_text and \"blocks\" in page_text:\n                    # Check if page has images but no text\n                    has_images = any(\n                        block.get(\"type\") == 1\n                        for block in page_text.get(\"blocks\", [])\n                    )\n                    if has_images:\n                        extracted_text.append(\n                            f\"[Page {page_num + 1}: Contains images but no extractable text]\"\n                        )\n                    else:\n                        extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n                else:\n                    extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n            else:\n                extracted_text.append(page_text)\n\n        doc.close()\n\n        # Only raise error if ALL pages are empty and there's no content at all\n        if not any(\n            text.strip() and not text.startswith(\"[Page\") for text in extracted_text\n        ):\n            if empty_pages == len(extracted_text):\n                raise InvalidFileError(\n                    f\"PDF contains {empty_pages} empty pages with no extractable text. \"\n                    \"This may be a scanned PDF that requires OCR.\"\n                )\n\n        result = \"\\n\".join(extracted_text)\n        return result\n\n    except fitz.FileDataError as e:\n        raise InvalidFileError(f\"Invalid or corrupted PDF file: {e}\")\n    except fitz.EmptyFileError:\n        raise InvalidFileError(\"PDF file is empty\")\n    except Exception as e:\n        if isinstance(e, (ExtractionError, InvalidFileError)):\n            raise\n        raise ExtractionError(f\"PDF extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/pdf.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.rtf","title":"rtf","text":"<p>RTF file handler for text extraction.</p> <p>Classes:</p> Name Description <code>RTFHandler</code> <p>Handler for extracting text from RTF files.</p>"},{"location":"reference/handlers/#textxtract.handlers.rtf-classes","title":"Classes","text":""},{"location":"reference/handlers/#textxtract.handlers.rtf.RTFHandler","title":"RTFHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from RTF files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/rtf.py</code> <pre><code>class RTFHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from RTF files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                from striprtf.striprtf import rtf_to_text\n            except ImportError:\n                raise ExtractionError(\n                    \"striprtf package is not installed. Install with 'pip install text-extractor[rtf]'\"\n                )\n\n            with open(\n                file_path, \"r\", encoding=(config or {}).get(\"encoding\", \"utf-8\")\n            ) as f:\n                rtf_content = f.read()\n                return rtf_to_text(rtf_content)\n        except Exception as e:\n            raise ExtractionError(f\"RTF extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.rtf.RTFHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/rtf.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            from striprtf.striprtf import rtf_to_text\n        except ImportError:\n            raise ExtractionError(\n                \"striprtf package is not installed. Install with 'pip install text-extractor[rtf]'\"\n            )\n\n        with open(\n            file_path, \"r\", encoding=(config or {}).get(\"encoding\", \"utf-8\")\n        ) as f:\n            rtf_content = f.read()\n            return rtf_to_text(rtf_content)\n    except Exception as e:\n        raise ExtractionError(f\"RTF extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/rtf.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.txt","title":"txt","text":"<p>TXT file handler for text extraction.</p> <p>Classes:</p> Name Description <code>TXTHandler</code> <p>Handler for extracting text from TXT files.</p>"},{"location":"reference/handlers/#textxtract.handlers.txt-classes","title":"Classes","text":""},{"location":"reference/handlers/#textxtract.handlers.txt.TXTHandler","title":"TXTHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from TXT files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/txt.py</code> <pre><code>class TXTHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from TXT files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        try:\n            return file_path.read_text(encoding=encoding)\n        except Exception as e:\n            raise ExtractionError(f\"TXT extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.txt.TXTHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/txt.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    encoding = (config or {}).get(\"encoding\", \"utf-8\")\n    try:\n        return file_path.read_text(encoding=encoding)\n    except Exception as e:\n        raise ExtractionError(f\"TXT extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/txt.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.xml","title":"xml","text":"<p>XML file handler for text extraction.</p> <p>Classes:</p> Name Description <code>XMLHandler</code> <p>Handler for extracting text from XML files.</p>"},{"location":"reference/handlers/#textxtract.handlers.xml-classes","title":"Classes","text":""},{"location":"reference/handlers/#textxtract.handlers.xml.XMLHandler","title":"XMLHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from XML files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/xml.py</code> <pre><code>class XMLHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from XML files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                from lxml import etree\n            except ImportError:\n                raise ExtractionError(\n                    \"lxml package is not installed. Install with 'pip install text-extractor[xml]'\"\n                )\n            encoding = (config or {}).get(\"encoding\", \"utf-8\")\n            with open(file_path, \"r\", encoding=encoding) as f:\n                tree = etree.parse(f)\n                return \" \".join(tree.xpath(\"//text()\"))\n        except Exception as e:\n            raise ExtractionError(f\"XML extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.xml.XMLHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/xml.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            from lxml import etree\n        except ImportError:\n            raise ExtractionError(\n                \"lxml package is not installed. Install with 'pip install text-extractor[xml]'\"\n            )\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        with open(file_path, \"r\", encoding=encoding) as f:\n            tree = etree.parse(f)\n            return \" \".join(tree.xpath(\"//text()\"))\n    except Exception as e:\n        raise ExtractionError(f\"XML extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/xml.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.zip","title":"zip","text":"<p>ZIP file handler for text extraction.</p> <p>Classes:</p> Name Description <code>ZIPHandler</code> <p>Handler for extracting text from ZIP archives with security checks.</p> <p>Attributes:</p> Name Type Description <code>logger</code>"},{"location":"reference/handlers/#textxtract.handlers.zip-attributes","title":"Attributes","text":""},{"location":"reference/handlers/#textxtract.handlers.zip.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger('textxtract.handlers.zip')\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.zip-classes","title":"Classes","text":""},{"location":"reference/handlers/#textxtract.handlers.zip.ZIPHandler","title":"ZIPHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from ZIP archives with security checks.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> <p>Attributes:</p> Name Type Description <code>MAX_EXTRACT_SIZE</code> <code>MAX_FILES</code> Source code in <code>textxtract/handlers/zip.py</code> <pre><code>class ZIPHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from ZIP archives with security checks.\"\"\"\n\n    MAX_EXTRACT_SIZE = 1024 * 1024 * 1024  # 1GB total\n    MAX_FILES = 1000  # Maximum files to process\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; List[str]:\n        extracted_texts = []\n        total_size = 0\n        file_count = 0\n\n        try:\n            with zipfile.ZipFile(file_path, \"r\") as zip_file:\n                for file_info in zip_file.infolist():\n                    if file_info.is_dir():\n                        continue\n\n                    # Security checks\n                    if file_count &gt;= self.MAX_FILES:\n                        logger.warning(\"Maximum file limit reached in ZIP archive\")\n                        break\n\n                    # Check for path traversal\n                    if self._is_unsafe_path(file_info.filename):\n                        logger.warning(\"Skipping unsafe path: %s\", file_info.filename)\n                        continue\n\n                    # Check file size\n                    if file_info.file_size &gt; 100 * 1024 * 1024:  # 100MB per file\n                        logger.warning(\n                            \"Skipping large file: %s (%d bytes)\",\n                            file_info.filename,\n                            file_info.file_size,\n                        )\n                        continue\n\n                    total_size += file_info.file_size\n                    if total_size &gt; self.MAX_EXTRACT_SIZE:\n                        logger.warning(\"Total extract size limit reached\")\n                        break\n\n                    file_count += 1\n\n                    try:\n                        with zip_file.open(file_info.filename) as source_file:\n                            file_bytes = source_file.read()\n                            suffix = Path(file_info.filename).suffix.lower()\n\n                            # Use registry to get handler\n                            from textxtract.core.registry import registry\n\n                            if registry.is_supported(suffix):\n                                handler = registry.get_handler(suffix)\n                                with tempfile.NamedTemporaryFile(\n                                    delete=False, suffix=suffix\n                                ) as temp_file:\n                                    temp_file.write(file_bytes)\n                                    temp_path = Path(temp_file.name)\n                                try:\n                                    text = handler.extract(temp_path, config)\n                                    extracted_texts.append(text)\n                                    logger.debug(\n                                        \"Extracted text from %s\", file_info.filename\n                                    )\n                                except Exception as e:\n                                    logger.warning(\n                                        \"Failed to extract text from %s: %s\",\n                                        file_info.filename,\n                                        e,\n                                    )\n                                finally:\n                                    temp_path.unlink(missing_ok=True)\n                            else:\n                                logger.debug(\n                                    \"Unsupported file type: %s\", file_info.filename\n                                )\n\n                    except Exception as e:\n                        logger.warning(\n                            \"Error processing file %s: %s\", file_info.filename, e\n                        )\n                        continue\n\n            logger.info(\n                \"Extracted text from %d files in ZIP archive\", len(extracted_texts)\n            )\n            return extracted_texts\n\n        except Exception as e:\n            raise ExtractionError(f\"ZIP extraction failed: {e}\")\n\n    def _is_unsafe_path(self, path: str) -&gt; bool:\n        \"\"\"Check if a path contains unsafe elements.\"\"\"\n        # Normalize path separators\n        normalized = path.replace(\"\\\\\", \"/\")\n\n        # Check for path traversal attempts\n        if \"..\" in normalized or normalized.startswith(\"/\"):\n            return True\n\n        # Check for absolute paths on Windows\n        if len(normalized) &gt; 1 and normalized[1] == \":\":\n            return True\n\n        return False\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; List[str]:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.zip.ZIPHandler-attributes","title":"Attributes","text":"MAX_EXTRACT_SIZE <code>class-attribute</code> <code>instance-attribute</code> <pre><code>MAX_EXTRACT_SIZE = 1024 * 1024 * 1024\n</code></pre> <code></code> MAX_FILES <code>class-attribute</code> <code>instance-attribute</code> <pre><code>MAX_FILES = 1000\n</code></pre>"},{"location":"reference/handlers/#textxtract.handlers.zip.ZIPHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/zip.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; List[str]:\n    extracted_texts = []\n    total_size = 0\n    file_count = 0\n\n    try:\n        with zipfile.ZipFile(file_path, \"r\") as zip_file:\n            for file_info in zip_file.infolist():\n                if file_info.is_dir():\n                    continue\n\n                # Security checks\n                if file_count &gt;= self.MAX_FILES:\n                    logger.warning(\"Maximum file limit reached in ZIP archive\")\n                    break\n\n                # Check for path traversal\n                if self._is_unsafe_path(file_info.filename):\n                    logger.warning(\"Skipping unsafe path: %s\", file_info.filename)\n                    continue\n\n                # Check file size\n                if file_info.file_size &gt; 100 * 1024 * 1024:  # 100MB per file\n                    logger.warning(\n                        \"Skipping large file: %s (%d bytes)\",\n                        file_info.filename,\n                        file_info.file_size,\n                    )\n                    continue\n\n                total_size += file_info.file_size\n                if total_size &gt; self.MAX_EXTRACT_SIZE:\n                    logger.warning(\"Total extract size limit reached\")\n                    break\n\n                file_count += 1\n\n                try:\n                    with zip_file.open(file_info.filename) as source_file:\n                        file_bytes = source_file.read()\n                        suffix = Path(file_info.filename).suffix.lower()\n\n                        # Use registry to get handler\n                        from textxtract.core.registry import registry\n\n                        if registry.is_supported(suffix):\n                            handler = registry.get_handler(suffix)\n                            with tempfile.NamedTemporaryFile(\n                                delete=False, suffix=suffix\n                            ) as temp_file:\n                                temp_file.write(file_bytes)\n                                temp_path = Path(temp_file.name)\n                            try:\n                                text = handler.extract(temp_path, config)\n                                extracted_texts.append(text)\n                                logger.debug(\n                                    \"Extracted text from %s\", file_info.filename\n                                )\n                            except Exception as e:\n                                logger.warning(\n                                    \"Failed to extract text from %s: %s\",\n                                    file_info.filename,\n                                    e,\n                                )\n                            finally:\n                                temp_path.unlink(missing_ok=True)\n                        else:\n                            logger.debug(\n                                \"Unsupported file type: %s\", file_info.filename\n                            )\n\n                except Exception as e:\n                    logger.warning(\n                        \"Error processing file %s: %s\", file_info.filename, e\n                    )\n                    continue\n\n        logger.info(\n            \"Extracted text from %d files in ZIP archive\", len(extracted_texts)\n        )\n        return extracted_texts\n\n    except Exception as e:\n        raise ExtractionError(f\"ZIP extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/zip.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; List[str]:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/","title":"Handlers Module","text":"<p>File type-specific handlers package.</p> <p>Modules:</p> Name Description <code>csv</code> <p>CSV file handler for text extraction.</p> <code>doc</code> <p>DOC file handler for text extraction.</p> <code>docx</code> <p>DOCX file handler for text extraction.</p> <code>html</code> <p>HTML file handler for text extraction.</p> <code>json</code> <p>JSON file handler for text extraction.</p> <code>md</code> <p>Markdown (.md) file handler for text extraction.</p> <code>pdf</code> <p>PDF file handler for text extraction.</p> <code>rtf</code> <p>RTF file handler for text extraction.</p> <code>txt</code> <p>TXT file handler for text extraction.</p> <code>xml</code> <p>XML file handler for text extraction.</p> <code>zip</code> <p>ZIP file handler for text extraction.</p>"},{"location":"reference/handlers/__init__/#textxtract.handlers-modules","title":"Modules","text":""},{"location":"reference/handlers/__init__/#textxtract.handlers.csv","title":"csv","text":"<p>CSV file handler for text extraction.</p> <p>Classes:</p> Name Description <code>CSVHandler</code> <p>Handler for extracting text from CSV files.</p>"},{"location":"reference/handlers/__init__/#textxtract.handlers.csv-classes","title":"Classes","text":""},{"location":"reference/handlers/__init__/#textxtract.handlers.csv.CSVHandler","title":"CSVHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from CSV files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/csv.py</code> <pre><code>class CSVHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from CSV files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            encoding = (config or {}).get(\"encoding\", \"utf-8\")\n            with open(file_path, \"r\", encoding=encoding, newline=\"\") as f:\n                reader = csv.reader(f)\n                return \"\\n\".join([\", \".join(row) for row in reader])\n        except Exception as e:\n            raise ExtractionError(f\"CSV extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.csv.CSVHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/csv.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        with open(file_path, \"r\", encoding=encoding, newline=\"\") as f:\n            reader = csv.reader(f)\n            return \"\\n\".join([\", \".join(row) for row in reader])\n    except Exception as e:\n        raise ExtractionError(f\"CSV extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/csv.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.doc","title":"doc","text":"<p>DOC file handler for text extraction.</p> <p>Classes:</p> Name Description <code>DOCHandler</code> <p>Handler for extracting text from DOC files with fallback options.</p>"},{"location":"reference/handlers/__init__/#textxtract.handlers.doc-classes","title":"Classes","text":""},{"location":"reference/handlers/__init__/#textxtract.handlers.doc.DOCHandler","title":"DOCHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from DOC files with fallback options.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/doc.py</code> <pre><code>class DOCHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from DOC files with fallback options.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        # Try antiword first\n        try:\n            return self._extract_with_antiword(file_path)\n        except FileNotFoundError:\n            # Try alternative methods if antiword is not available\n            return self._extract_with_fallback(file_path, config)\n        except Exception as e:\n            if isinstance(e, ExtractionError):\n                raise\n            raise ExtractionError(f\"DOC extraction failed: {e}\")\n\n    def _extract_with_antiword(self, file_path: Path) -&gt; str:\n        \"\"\"Extract text using antiword command.\"\"\"\n        import subprocess\n\n        try:\n            result = subprocess.run(\n                [\"antiword\", str(file_path)],\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n                check=True,\n                timeout=30,  # Add timeout\n            )\n            content = result.stdout.decode(\"utf-8\").strip()\n            if not content:\n                raise ExtractionError(\"antiword returned empty content\")\n            return content\n        except subprocess.TimeoutExpired:\n            raise ExtractionError(\"antiword extraction timed out\")\n        except subprocess.CalledProcessError as e:\n            error_msg = e.stderr.decode() if e.stderr else str(e)\n            raise ExtractionError(f\"antiword extraction failed: {error_msg}\")\n\n    def _extract_with_fallback(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"Fallback extraction methods when antiword is not available.\"\"\"\n\n        # Try python-docx (works for some DOC files)\n        try:\n            from docx import Document\n\n            doc = Document(file_path)\n            text = \"\\n\".join(paragraph.text for paragraph in doc.paragraphs)\n            if text.strip():\n                return text\n        except Exception:\n            pass  # Silent fail, try next method\n\n        # Try reading as binary and looking for text patterns\n        try:\n            with open(file_path, \"rb\") as f:\n                content = f.read()\n\n            # Simple heuristic: look for readable text in the binary\n            text_content = []\n            current_text = []\n\n            for byte in content:\n                if 32 &lt;= byte &lt;= 126:  # Printable ASCII\n                    current_text.append(chr(byte))\n                else:\n                    if len(current_text) &gt; 3:  # Minimum word length\n                        text_content.append(\"\".join(current_text))\n                    current_text = []\n\n            if current_text and len(current_text) &gt; 3:\n                text_content.append(\"\".join(current_text))\n\n            result = \" \".join(text_content)\n            if result.strip():\n                return f\"[Extracted using fallback method - may contain formatting artifacts]\\n{result}\"\n\n        except Exception:\n            pass\n\n        # If all methods fail\n        raise ExtractionError(\n            \"DOC extraction failed. Please install 'antiword' command for better DOC support: \"\n            \"sudo apt-get install antiword (Ubuntu/Debian) or brew install antiword (macOS)\"\n        )\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.doc.DOCHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/doc.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    # Try antiword first\n    try:\n        return self._extract_with_antiword(file_path)\n    except FileNotFoundError:\n        # Try alternative methods if antiword is not available\n        return self._extract_with_fallback(file_path, config)\n    except Exception as e:\n        if isinstance(e, ExtractionError):\n            raise\n        raise ExtractionError(f\"DOC extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/doc.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.docx","title":"docx","text":"<p>DOCX file handler for text extraction.</p> <p>Classes:</p> Name Description <code>DOCXHandler</code> <p>Handler for extracting text from DOCX files.</p>"},{"location":"reference/handlers/__init__/#textxtract.handlers.docx-classes","title":"Classes","text":""},{"location":"reference/handlers/__init__/#textxtract.handlers.docx.DOCXHandler","title":"DOCXHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from DOCX files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/docx.py</code> <pre><code>class DOCXHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from DOCX files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            from docx import Document\n\n            doc = Document(file_path)\n            return \"\\n\".join(paragraph.text for paragraph in doc.paragraphs)\n        except Exception as e:\n            raise ExtractionError(f\"DOCX extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.docx.DOCXHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/docx.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        from docx import Document\n\n        doc = Document(file_path)\n        return \"\\n\".join(paragraph.text for paragraph in doc.paragraphs)\n    except Exception as e:\n        raise ExtractionError(f\"DOCX extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/docx.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.html","title":"html","text":"<p>HTML file handler for text extraction.</p> <p>Classes:</p> Name Description <code>HTMLHandler</code> <p>Handler for extracting text from HTML files.</p>"},{"location":"reference/handlers/__init__/#textxtract.handlers.html-classes","title":"Classes","text":""},{"location":"reference/handlers/__init__/#textxtract.handlers.html.HTMLHandler","title":"HTMLHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from HTML files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/html.py</code> <pre><code>class HTMLHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from HTML files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                from bs4 import BeautifulSoup\n            except ImportError:\n                raise ExtractionError(\n                    \"beautifulsoup4 package is not installed. Install with 'pip install text-extractor[html]'\"\n                )\n            text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n            soup = BeautifulSoup(text, \"html.parser\")\n            return soup.get_text()\n        except Exception as e:\n            raise ExtractionError(f\"HTML extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.html.HTMLHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/html.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            from bs4 import BeautifulSoup\n        except ImportError:\n            raise ExtractionError(\n                \"beautifulsoup4 package is not installed. Install with 'pip install text-extractor[html]'\"\n            )\n        text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n        soup = BeautifulSoup(text, \"html.parser\")\n        return soup.get_text()\n    except Exception as e:\n        raise ExtractionError(f\"HTML extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/html.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.json","title":"json","text":"<p>JSON file handler for text extraction.</p> <p>Classes:</p> Name Description <code>JSONHandler</code> <p>Handler for extracting text from JSON files.</p>"},{"location":"reference/handlers/__init__/#textxtract.handlers.json-classes","title":"Classes","text":""},{"location":"reference/handlers/__init__/#textxtract.handlers.json.JSONHandler","title":"JSONHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from JSON files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/json.py</code> <pre><code>class JSONHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from JSON files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            encoding = (config or {}).get(\"encoding\", \"utf-8\")\n            with open(file_path, \"r\", encoding=encoding) as f:\n                data = json.load(f)\n                # Pretty print JSON as text\n                return json.dumps(data, indent=2, ensure_ascii=False)\n        except Exception as e:\n            raise ExtractionError(f\"JSON extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.json.JSONHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/json.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        with open(file_path, \"r\", encoding=encoding) as f:\n            data = json.load(f)\n            # Pretty print JSON as text\n            return json.dumps(data, indent=2, ensure_ascii=False)\n    except Exception as e:\n        raise ExtractionError(f\"JSON extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/json.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.md","title":"md","text":"<p>Markdown (.md) file handler for text extraction.</p> <p>Classes:</p> Name Description <code>MDHandler</code> <p>Handler for extracting text from Markdown files.</p>"},{"location":"reference/handlers/__init__/#textxtract.handlers.md-classes","title":"Classes","text":""},{"location":"reference/handlers/__init__/#textxtract.handlers.md.MDHandler","title":"MDHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from Markdown files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/md.py</code> <pre><code>class MDHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from Markdown files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                import markdown\n            except ImportError:\n                raise ExtractionError(\n                    \"markdown package is not installed. Install with 'pip install text-extractor[md]'\"\n                )\n            text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n            # Optionally, convert markdown to plain text (strip HTML)\n            html = markdown.markdown(text)\n            # Remove HTML tags (best effort, fallback to raw text)\n            try:\n                from bs4 import BeautifulSoup\n\n                soup = BeautifulSoup(html, \"html.parser\")\n                return soup.get_text()\n            except ImportError:\n                return text\n        except Exception as e:\n            raise ExtractionError(f\"MD extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.md.MDHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/md.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            import markdown\n        except ImportError:\n            raise ExtractionError(\n                \"markdown package is not installed. Install with 'pip install text-extractor[md]'\"\n            )\n        text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n        # Optionally, convert markdown to plain text (strip HTML)\n        html = markdown.markdown(text)\n        # Remove HTML tags (best effort, fallback to raw text)\n        try:\n            from bs4 import BeautifulSoup\n\n            soup = BeautifulSoup(html, \"html.parser\")\n            return soup.get_text()\n        except ImportError:\n            return text\n    except Exception as e:\n        raise ExtractionError(f\"MD extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/md.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.pdf","title":"pdf","text":"<p>PDF file handler for text extraction.</p> <p>Classes:</p> Name Description <code>PDFHandler</code> <p>Handler for extracting text from PDF files with improved error handling.</p>"},{"location":"reference/handlers/__init__/#textxtract.handlers.pdf-classes","title":"Classes","text":""},{"location":"reference/handlers/__init__/#textxtract.handlers.pdf.PDFHandler","title":"PDFHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from PDF files with improved error handling.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/pdf.py</code> <pre><code>class PDFHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from PDF files with improved error handling.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                import fitz  # PyMuPDF\n            except ImportError:\n                raise ExtractionError(\n                    \"PyMuPDF package is not installed. Install with 'pip install text-extractor[pdf]'\"\n                )\n\n            doc = fitz.open(file_path)\n            extracted_text = []\n            empty_pages = 0\n\n            for page_num, page in enumerate(doc):\n                page_text = page.get_text(\"text\").strip()\n                if not page_text:\n                    empty_pages += 1\n                    # Try OCR-like text extraction for images\n                    page_text = page.get_text(\"dict\")  # Get structured text\n                    if page_text and \"blocks\" in page_text:\n                        # Check if page has images but no text\n                        has_images = any(\n                            block.get(\"type\") == 1\n                            for block in page_text.get(\"blocks\", [])\n                        )\n                        if has_images:\n                            extracted_text.append(\n                                f\"[Page {page_num + 1}: Contains images but no extractable text]\"\n                            )\n                        else:\n                            extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n                    else:\n                        extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n                else:\n                    extracted_text.append(page_text)\n\n            doc.close()\n\n            # Only raise error if ALL pages are empty and there's no content at all\n            if not any(\n                text.strip() and not text.startswith(\"[Page\") for text in extracted_text\n            ):\n                if empty_pages == len(extracted_text):\n                    raise InvalidFileError(\n                        f\"PDF contains {empty_pages} empty pages with no extractable text. \"\n                        \"This may be a scanned PDF that requires OCR.\"\n                    )\n\n            result = \"\\n\".join(extracted_text)\n            return result\n\n        except fitz.FileDataError as e:\n            raise InvalidFileError(f\"Invalid or corrupted PDF file: {e}\")\n        except fitz.EmptyFileError:\n            raise InvalidFileError(\"PDF file is empty\")\n        except Exception as e:\n            if isinstance(e, (ExtractionError, InvalidFileError)):\n                raise\n            raise ExtractionError(f\"PDF extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.pdf.PDFHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/pdf.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            import fitz  # PyMuPDF\n        except ImportError:\n            raise ExtractionError(\n                \"PyMuPDF package is not installed. Install with 'pip install text-extractor[pdf]'\"\n            )\n\n        doc = fitz.open(file_path)\n        extracted_text = []\n        empty_pages = 0\n\n        for page_num, page in enumerate(doc):\n            page_text = page.get_text(\"text\").strip()\n            if not page_text:\n                empty_pages += 1\n                # Try OCR-like text extraction for images\n                page_text = page.get_text(\"dict\")  # Get structured text\n                if page_text and \"blocks\" in page_text:\n                    # Check if page has images but no text\n                    has_images = any(\n                        block.get(\"type\") == 1\n                        for block in page_text.get(\"blocks\", [])\n                    )\n                    if has_images:\n                        extracted_text.append(\n                            f\"[Page {page_num + 1}: Contains images but no extractable text]\"\n                        )\n                    else:\n                        extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n                else:\n                    extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n            else:\n                extracted_text.append(page_text)\n\n        doc.close()\n\n        # Only raise error if ALL pages are empty and there's no content at all\n        if not any(\n            text.strip() and not text.startswith(\"[Page\") for text in extracted_text\n        ):\n            if empty_pages == len(extracted_text):\n                raise InvalidFileError(\n                    f\"PDF contains {empty_pages} empty pages with no extractable text. \"\n                    \"This may be a scanned PDF that requires OCR.\"\n                )\n\n        result = \"\\n\".join(extracted_text)\n        return result\n\n    except fitz.FileDataError as e:\n        raise InvalidFileError(f\"Invalid or corrupted PDF file: {e}\")\n    except fitz.EmptyFileError:\n        raise InvalidFileError(\"PDF file is empty\")\n    except Exception as e:\n        if isinstance(e, (ExtractionError, InvalidFileError)):\n            raise\n        raise ExtractionError(f\"PDF extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/pdf.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.rtf","title":"rtf","text":"<p>RTF file handler for text extraction.</p> <p>Classes:</p> Name Description <code>RTFHandler</code> <p>Handler for extracting text from RTF files.</p>"},{"location":"reference/handlers/__init__/#textxtract.handlers.rtf-classes","title":"Classes","text":""},{"location":"reference/handlers/__init__/#textxtract.handlers.rtf.RTFHandler","title":"RTFHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from RTF files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/rtf.py</code> <pre><code>class RTFHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from RTF files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                from striprtf.striprtf import rtf_to_text\n            except ImportError:\n                raise ExtractionError(\n                    \"striprtf package is not installed. Install with 'pip install text-extractor[rtf]'\"\n                )\n\n            with open(\n                file_path, \"r\", encoding=(config or {}).get(\"encoding\", \"utf-8\")\n            ) as f:\n                rtf_content = f.read()\n                return rtf_to_text(rtf_content)\n        except Exception as e:\n            raise ExtractionError(f\"RTF extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.rtf.RTFHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/rtf.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            from striprtf.striprtf import rtf_to_text\n        except ImportError:\n            raise ExtractionError(\n                \"striprtf package is not installed. Install with 'pip install text-extractor[rtf]'\"\n            )\n\n        with open(\n            file_path, \"r\", encoding=(config or {}).get(\"encoding\", \"utf-8\")\n        ) as f:\n            rtf_content = f.read()\n            return rtf_to_text(rtf_content)\n    except Exception as e:\n        raise ExtractionError(f\"RTF extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/rtf.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.txt","title":"txt","text":"<p>TXT file handler for text extraction.</p> <p>Classes:</p> Name Description <code>TXTHandler</code> <p>Handler for extracting text from TXT files.</p>"},{"location":"reference/handlers/__init__/#textxtract.handlers.txt-classes","title":"Classes","text":""},{"location":"reference/handlers/__init__/#textxtract.handlers.txt.TXTHandler","title":"TXTHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from TXT files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/txt.py</code> <pre><code>class TXTHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from TXT files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        try:\n            return file_path.read_text(encoding=encoding)\n        except Exception as e:\n            raise ExtractionError(f\"TXT extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.txt.TXTHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/txt.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    encoding = (config or {}).get(\"encoding\", \"utf-8\")\n    try:\n        return file_path.read_text(encoding=encoding)\n    except Exception as e:\n        raise ExtractionError(f\"TXT extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/txt.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.xml","title":"xml","text":"<p>XML file handler for text extraction.</p> <p>Classes:</p> Name Description <code>XMLHandler</code> <p>Handler for extracting text from XML files.</p>"},{"location":"reference/handlers/__init__/#textxtract.handlers.xml-classes","title":"Classes","text":""},{"location":"reference/handlers/__init__/#textxtract.handlers.xml.XMLHandler","title":"XMLHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from XML files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/xml.py</code> <pre><code>class XMLHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from XML files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                from lxml import etree\n            except ImportError:\n                raise ExtractionError(\n                    \"lxml package is not installed. Install with 'pip install text-extractor[xml]'\"\n                )\n            encoding = (config or {}).get(\"encoding\", \"utf-8\")\n            with open(file_path, \"r\", encoding=encoding) as f:\n                tree = etree.parse(f)\n                return \" \".join(tree.xpath(\"//text()\"))\n        except Exception as e:\n            raise ExtractionError(f\"XML extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.xml.XMLHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/xml.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            from lxml import etree\n        except ImportError:\n            raise ExtractionError(\n                \"lxml package is not installed. Install with 'pip install text-extractor[xml]'\"\n            )\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        with open(file_path, \"r\", encoding=encoding) as f:\n            tree = etree.parse(f)\n            return \" \".join(tree.xpath(\"//text()\"))\n    except Exception as e:\n        raise ExtractionError(f\"XML extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/xml.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.zip","title":"zip","text":"<p>ZIP file handler for text extraction.</p> <p>Classes:</p> Name Description <code>ZIPHandler</code> <p>Handler for extracting text from ZIP archives with security checks.</p> <p>Attributes:</p> Name Type Description <code>logger</code>"},{"location":"reference/handlers/__init__/#textxtract.handlers.zip-attributes","title":"Attributes","text":""},{"location":"reference/handlers/__init__/#textxtract.handlers.zip.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger('textxtract.handlers.zip')\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.zip-classes","title":"Classes","text":""},{"location":"reference/handlers/__init__/#textxtract.handlers.zip.ZIPHandler","title":"ZIPHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from ZIP archives with security checks.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> <p>Attributes:</p> Name Type Description <code>MAX_EXTRACT_SIZE</code> <code>MAX_FILES</code> Source code in <code>textxtract/handlers/zip.py</code> <pre><code>class ZIPHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from ZIP archives with security checks.\"\"\"\n\n    MAX_EXTRACT_SIZE = 1024 * 1024 * 1024  # 1GB total\n    MAX_FILES = 1000  # Maximum files to process\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; List[str]:\n        extracted_texts = []\n        total_size = 0\n        file_count = 0\n\n        try:\n            with zipfile.ZipFile(file_path, \"r\") as zip_file:\n                for file_info in zip_file.infolist():\n                    if file_info.is_dir():\n                        continue\n\n                    # Security checks\n                    if file_count &gt;= self.MAX_FILES:\n                        logger.warning(\"Maximum file limit reached in ZIP archive\")\n                        break\n\n                    # Check for path traversal\n                    if self._is_unsafe_path(file_info.filename):\n                        logger.warning(\"Skipping unsafe path: %s\", file_info.filename)\n                        continue\n\n                    # Check file size\n                    if file_info.file_size &gt; 100 * 1024 * 1024:  # 100MB per file\n                        logger.warning(\n                            \"Skipping large file: %s (%d bytes)\",\n                            file_info.filename,\n                            file_info.file_size,\n                        )\n                        continue\n\n                    total_size += file_info.file_size\n                    if total_size &gt; self.MAX_EXTRACT_SIZE:\n                        logger.warning(\"Total extract size limit reached\")\n                        break\n\n                    file_count += 1\n\n                    try:\n                        with zip_file.open(file_info.filename) as source_file:\n                            file_bytes = source_file.read()\n                            suffix = Path(file_info.filename).suffix.lower()\n\n                            # Use registry to get handler\n                            from textxtract.core.registry import registry\n\n                            if registry.is_supported(suffix):\n                                handler = registry.get_handler(suffix)\n                                with tempfile.NamedTemporaryFile(\n                                    delete=False, suffix=suffix\n                                ) as temp_file:\n                                    temp_file.write(file_bytes)\n                                    temp_path = Path(temp_file.name)\n                                try:\n                                    text = handler.extract(temp_path, config)\n                                    extracted_texts.append(text)\n                                    logger.debug(\n                                        \"Extracted text from %s\", file_info.filename\n                                    )\n                                except Exception as e:\n                                    logger.warning(\n                                        \"Failed to extract text from %s: %s\",\n                                        file_info.filename,\n                                        e,\n                                    )\n                                finally:\n                                    temp_path.unlink(missing_ok=True)\n                            else:\n                                logger.debug(\n                                    \"Unsupported file type: %s\", file_info.filename\n                                )\n\n                    except Exception as e:\n                        logger.warning(\n                            \"Error processing file %s: %s\", file_info.filename, e\n                        )\n                        continue\n\n            logger.info(\n                \"Extracted text from %d files in ZIP archive\", len(extracted_texts)\n            )\n            return extracted_texts\n\n        except Exception as e:\n            raise ExtractionError(f\"ZIP extraction failed: {e}\")\n\n    def _is_unsafe_path(self, path: str) -&gt; bool:\n        \"\"\"Check if a path contains unsafe elements.\"\"\"\n        # Normalize path separators\n        normalized = path.replace(\"\\\\\", \"/\")\n\n        # Check for path traversal attempts\n        if \"..\" in normalized or normalized.startswith(\"/\"):\n            return True\n\n        # Check for absolute paths on Windows\n        if len(normalized) &gt; 1 and normalized[1] == \":\":\n            return True\n\n        return False\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; List[str]:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.zip.ZIPHandler-attributes","title":"Attributes","text":"MAX_EXTRACT_SIZE <code>class-attribute</code> <code>instance-attribute</code> <pre><code>MAX_EXTRACT_SIZE = 1024 * 1024 * 1024\n</code></pre> <code></code> MAX_FILES <code>class-attribute</code> <code>instance-attribute</code> <pre><code>MAX_FILES = 1000\n</code></pre>"},{"location":"reference/handlers/__init__/#textxtract.handlers.zip.ZIPHandler-functions","title":"Functions","text":"extract <pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/zip.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; List[str]:\n    extracted_texts = []\n    total_size = 0\n    file_count = 0\n\n    try:\n        with zipfile.ZipFile(file_path, \"r\") as zip_file:\n            for file_info in zip_file.infolist():\n                if file_info.is_dir():\n                    continue\n\n                # Security checks\n                if file_count &gt;= self.MAX_FILES:\n                    logger.warning(\"Maximum file limit reached in ZIP archive\")\n                    break\n\n                # Check for path traversal\n                if self._is_unsafe_path(file_info.filename):\n                    logger.warning(\"Skipping unsafe path: %s\", file_info.filename)\n                    continue\n\n                # Check file size\n                if file_info.file_size &gt; 100 * 1024 * 1024:  # 100MB per file\n                    logger.warning(\n                        \"Skipping large file: %s (%d bytes)\",\n                        file_info.filename,\n                        file_info.file_size,\n                    )\n                    continue\n\n                total_size += file_info.file_size\n                if total_size &gt; self.MAX_EXTRACT_SIZE:\n                    logger.warning(\"Total extract size limit reached\")\n                    break\n\n                file_count += 1\n\n                try:\n                    with zip_file.open(file_info.filename) as source_file:\n                        file_bytes = source_file.read()\n                        suffix = Path(file_info.filename).suffix.lower()\n\n                        # Use registry to get handler\n                        from textxtract.core.registry import registry\n\n                        if registry.is_supported(suffix):\n                            handler = registry.get_handler(suffix)\n                            with tempfile.NamedTemporaryFile(\n                                delete=False, suffix=suffix\n                            ) as temp_file:\n                                temp_file.write(file_bytes)\n                                temp_path = Path(temp_file.name)\n                            try:\n                                text = handler.extract(temp_path, config)\n                                extracted_texts.append(text)\n                                logger.debug(\n                                    \"Extracted text from %s\", file_info.filename\n                                )\n                            except Exception as e:\n                                logger.warning(\n                                    \"Failed to extract text from %s: %s\",\n                                    file_info.filename,\n                                    e,\n                                )\n                            finally:\n                                temp_path.unlink(missing_ok=True)\n                        else:\n                            logger.debug(\n                                \"Unsupported file type: %s\", file_info.filename\n                            )\n\n                except Exception as e:\n                    logger.warning(\n                        \"Error processing file %s: %s\", file_info.filename, e\n                    )\n                    continue\n\n        logger.info(\n            \"Extracted text from %d files in ZIP archive\", len(extracted_texts)\n        )\n        return extracted_texts\n\n    except Exception as e:\n        raise ExtractionError(f\"ZIP extraction failed: {e}\")\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/zip.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; List[str]:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/csv/","title":"Csv Module","text":"<p>CSV file handler for text extraction.</p> <p>Classes:</p> Name Description <code>CSVHandler</code> <p>Handler for extracting text from CSV files.</p>"},{"location":"reference/handlers/csv/#textxtract.handlers.csv-classes","title":"Classes","text":""},{"location":"reference/handlers/csv/#textxtract.handlers.csv.CSVHandler","title":"CSVHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from CSV files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/csv.py</code> <pre><code>class CSVHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from CSV files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            encoding = (config or {}).get(\"encoding\", \"utf-8\")\n            with open(file_path, \"r\", encoding=encoding, newline=\"\") as f:\n                reader = csv.reader(f)\n                return \"\\n\".join([\", \".join(row) for row in reader])\n        except Exception as e:\n            raise ExtractionError(f\"CSV extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/csv/#textxtract.handlers.csv.CSVHandler-functions","title":"Functions","text":""},{"location":"reference/handlers/csv/#textxtract.handlers.csv.CSVHandler.extract","title":"extract","text":"<pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/csv.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        with open(file_path, \"r\", encoding=encoding, newline=\"\") as f:\n            reader = csv.reader(f)\n            return \"\\n\".join([\", \".join(row) for row in reader])\n    except Exception as e:\n        raise ExtractionError(f\"CSV extraction failed: {e}\")\n</code></pre>"},{"location":"reference/handlers/csv/#textxtract.handlers.csv.CSVHandler.extract_async","title":"extract_async  <code>async</code>","text":"<pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/csv.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/doc/","title":"Doc Module","text":"<p>DOC file handler for text extraction.</p> <p>Classes:</p> Name Description <code>DOCHandler</code> <p>Handler for extracting text from DOC files with fallback options.</p>"},{"location":"reference/handlers/doc/#textxtract.handlers.doc-classes","title":"Classes","text":""},{"location":"reference/handlers/doc/#textxtract.handlers.doc.DOCHandler","title":"DOCHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from DOC files with fallback options.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/doc.py</code> <pre><code>class DOCHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from DOC files with fallback options.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        # Try antiword first\n        try:\n            return self._extract_with_antiword(file_path)\n        except FileNotFoundError:\n            # Try alternative methods if antiword is not available\n            return self._extract_with_fallback(file_path, config)\n        except Exception as e:\n            if isinstance(e, ExtractionError):\n                raise\n            raise ExtractionError(f\"DOC extraction failed: {e}\")\n\n    def _extract_with_antiword(self, file_path: Path) -&gt; str:\n        \"\"\"Extract text using antiword command.\"\"\"\n        import subprocess\n\n        try:\n            result = subprocess.run(\n                [\"antiword\", str(file_path)],\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n                check=True,\n                timeout=30,  # Add timeout\n            )\n            content = result.stdout.decode(\"utf-8\").strip()\n            if not content:\n                raise ExtractionError(\"antiword returned empty content\")\n            return content\n        except subprocess.TimeoutExpired:\n            raise ExtractionError(\"antiword extraction timed out\")\n        except subprocess.CalledProcessError as e:\n            error_msg = e.stderr.decode() if e.stderr else str(e)\n            raise ExtractionError(f\"antiword extraction failed: {error_msg}\")\n\n    def _extract_with_fallback(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"Fallback extraction methods when antiword is not available.\"\"\"\n\n        # Try python-docx (works for some DOC files)\n        try:\n            from docx import Document\n\n            doc = Document(file_path)\n            text = \"\\n\".join(paragraph.text for paragraph in doc.paragraphs)\n            if text.strip():\n                return text\n        except Exception:\n            pass  # Silent fail, try next method\n\n        # Try reading as binary and looking for text patterns\n        try:\n            with open(file_path, \"rb\") as f:\n                content = f.read()\n\n            # Simple heuristic: look for readable text in the binary\n            text_content = []\n            current_text = []\n\n            for byte in content:\n                if 32 &lt;= byte &lt;= 126:  # Printable ASCII\n                    current_text.append(chr(byte))\n                else:\n                    if len(current_text) &gt; 3:  # Minimum word length\n                        text_content.append(\"\".join(current_text))\n                    current_text = []\n\n            if current_text and len(current_text) &gt; 3:\n                text_content.append(\"\".join(current_text))\n\n            result = \" \".join(text_content)\n            if result.strip():\n                return f\"[Extracted using fallback method - may contain formatting artifacts]\\n{result}\"\n\n        except Exception:\n            pass\n\n        # If all methods fail\n        raise ExtractionError(\n            \"DOC extraction failed. Please install 'antiword' command for better DOC support: \"\n            \"sudo apt-get install antiword (Ubuntu/Debian) or brew install antiword (macOS)\"\n        )\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/doc/#textxtract.handlers.doc.DOCHandler-functions","title":"Functions","text":""},{"location":"reference/handlers/doc/#textxtract.handlers.doc.DOCHandler.extract","title":"extract","text":"<pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/doc.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    # Try antiword first\n    try:\n        return self._extract_with_antiword(file_path)\n    except FileNotFoundError:\n        # Try alternative methods if antiword is not available\n        return self._extract_with_fallback(file_path, config)\n    except Exception as e:\n        if isinstance(e, ExtractionError):\n            raise\n        raise ExtractionError(f\"DOC extraction failed: {e}\")\n</code></pre>"},{"location":"reference/handlers/doc/#textxtract.handlers.doc.DOCHandler.extract_async","title":"extract_async  <code>async</code>","text":"<pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/doc.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/docx/","title":"Docx Module","text":"<p>DOCX file handler for text extraction.</p> <p>Classes:</p> Name Description <code>DOCXHandler</code> <p>Handler for extracting text from DOCX files.</p>"},{"location":"reference/handlers/docx/#textxtract.handlers.docx-classes","title":"Classes","text":""},{"location":"reference/handlers/docx/#textxtract.handlers.docx.DOCXHandler","title":"DOCXHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from DOCX files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/docx.py</code> <pre><code>class DOCXHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from DOCX files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            from docx import Document\n\n            doc = Document(file_path)\n            return \"\\n\".join(paragraph.text for paragraph in doc.paragraphs)\n        except Exception as e:\n            raise ExtractionError(f\"DOCX extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/docx/#textxtract.handlers.docx.DOCXHandler-functions","title":"Functions","text":""},{"location":"reference/handlers/docx/#textxtract.handlers.docx.DOCXHandler.extract","title":"extract","text":"<pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/docx.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        from docx import Document\n\n        doc = Document(file_path)\n        return \"\\n\".join(paragraph.text for paragraph in doc.paragraphs)\n    except Exception as e:\n        raise ExtractionError(f\"DOCX extraction failed: {e}\")\n</code></pre>"},{"location":"reference/handlers/docx/#textxtract.handlers.docx.DOCXHandler.extract_async","title":"extract_async  <code>async</code>","text":"<pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/docx.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/html/","title":"Html Module","text":"<p>HTML file handler for text extraction.</p> <p>Classes:</p> Name Description <code>HTMLHandler</code> <p>Handler for extracting text from HTML files.</p>"},{"location":"reference/handlers/html/#textxtract.handlers.html-classes","title":"Classes","text":""},{"location":"reference/handlers/html/#textxtract.handlers.html.HTMLHandler","title":"HTMLHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from HTML files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/html.py</code> <pre><code>class HTMLHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from HTML files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                from bs4 import BeautifulSoup\n            except ImportError:\n                raise ExtractionError(\n                    \"beautifulsoup4 package is not installed. Install with 'pip install text-extractor[html]'\"\n                )\n            text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n            soup = BeautifulSoup(text, \"html.parser\")\n            return soup.get_text()\n        except Exception as e:\n            raise ExtractionError(f\"HTML extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/html/#textxtract.handlers.html.HTMLHandler-functions","title":"Functions","text":""},{"location":"reference/handlers/html/#textxtract.handlers.html.HTMLHandler.extract","title":"extract","text":"<pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/html.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            from bs4 import BeautifulSoup\n        except ImportError:\n            raise ExtractionError(\n                \"beautifulsoup4 package is not installed. Install with 'pip install text-extractor[html]'\"\n            )\n        text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n        soup = BeautifulSoup(text, \"html.parser\")\n        return soup.get_text()\n    except Exception as e:\n        raise ExtractionError(f\"HTML extraction failed: {e}\")\n</code></pre>"},{"location":"reference/handlers/html/#textxtract.handlers.html.HTMLHandler.extract_async","title":"extract_async  <code>async</code>","text":"<pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/html.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/json/","title":"Json Module","text":"<p>JSON file handler for text extraction.</p> <p>Classes:</p> Name Description <code>JSONHandler</code> <p>Handler for extracting text from JSON files.</p>"},{"location":"reference/handlers/json/#textxtract.handlers.json-classes","title":"Classes","text":""},{"location":"reference/handlers/json/#textxtract.handlers.json.JSONHandler","title":"JSONHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from JSON files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/json.py</code> <pre><code>class JSONHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from JSON files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            encoding = (config or {}).get(\"encoding\", \"utf-8\")\n            with open(file_path, \"r\", encoding=encoding) as f:\n                data = json.load(f)\n                # Pretty print JSON as text\n                return json.dumps(data, indent=2, ensure_ascii=False)\n        except Exception as e:\n            raise ExtractionError(f\"JSON extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/json/#textxtract.handlers.json.JSONHandler-functions","title":"Functions","text":""},{"location":"reference/handlers/json/#textxtract.handlers.json.JSONHandler.extract","title":"extract","text":"<pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/json.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        with open(file_path, \"r\", encoding=encoding) as f:\n            data = json.load(f)\n            # Pretty print JSON as text\n            return json.dumps(data, indent=2, ensure_ascii=False)\n    except Exception as e:\n        raise ExtractionError(f\"JSON extraction failed: {e}\")\n</code></pre>"},{"location":"reference/handlers/json/#textxtract.handlers.json.JSONHandler.extract_async","title":"extract_async  <code>async</code>","text":"<pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/json.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/md/","title":"Md Module","text":"<p>Markdown (.md) file handler for text extraction.</p> <p>Classes:</p> Name Description <code>MDHandler</code> <p>Handler for extracting text from Markdown files.</p>"},{"location":"reference/handlers/md/#textxtract.handlers.md-classes","title":"Classes","text":""},{"location":"reference/handlers/md/#textxtract.handlers.md.MDHandler","title":"MDHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from Markdown files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/md.py</code> <pre><code>class MDHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from Markdown files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                import markdown\n            except ImportError:\n                raise ExtractionError(\n                    \"markdown package is not installed. Install with 'pip install text-extractor[md]'\"\n                )\n            text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n            # Optionally, convert markdown to plain text (strip HTML)\n            html = markdown.markdown(text)\n            # Remove HTML tags (best effort, fallback to raw text)\n            try:\n                from bs4 import BeautifulSoup\n\n                soup = BeautifulSoup(html, \"html.parser\")\n                return soup.get_text()\n            except ImportError:\n                return text\n        except Exception as e:\n            raise ExtractionError(f\"MD extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/md/#textxtract.handlers.md.MDHandler-functions","title":"Functions","text":""},{"location":"reference/handlers/md/#textxtract.handlers.md.MDHandler.extract","title":"extract","text":"<pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/md.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            import markdown\n        except ImportError:\n            raise ExtractionError(\n                \"markdown package is not installed. Install with 'pip install text-extractor[md]'\"\n            )\n        text = file_path.read_text(encoding=(config or {}).get(\"encoding\", \"utf-8\"))\n        # Optionally, convert markdown to plain text (strip HTML)\n        html = markdown.markdown(text)\n        # Remove HTML tags (best effort, fallback to raw text)\n        try:\n            from bs4 import BeautifulSoup\n\n            soup = BeautifulSoup(html, \"html.parser\")\n            return soup.get_text()\n        except ImportError:\n            return text\n    except Exception as e:\n        raise ExtractionError(f\"MD extraction failed: {e}\")\n</code></pre>"},{"location":"reference/handlers/md/#textxtract.handlers.md.MDHandler.extract_async","title":"extract_async  <code>async</code>","text":"<pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/md.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/pdf/","title":"Pdf Module","text":"<p>PDF file handler for text extraction.</p> <p>Classes:</p> Name Description <code>PDFHandler</code> <p>Handler for extracting text from PDF files with improved error handling.</p>"},{"location":"reference/handlers/pdf/#textxtract.handlers.pdf-classes","title":"Classes","text":""},{"location":"reference/handlers/pdf/#textxtract.handlers.pdf.PDFHandler","title":"PDFHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from PDF files with improved error handling.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/pdf.py</code> <pre><code>class PDFHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from PDF files with improved error handling.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                import fitz  # PyMuPDF\n            except ImportError:\n                raise ExtractionError(\n                    \"PyMuPDF package is not installed. Install with 'pip install text-extractor[pdf]'\"\n                )\n\n            doc = fitz.open(file_path)\n            extracted_text = []\n            empty_pages = 0\n\n            for page_num, page in enumerate(doc):\n                page_text = page.get_text(\"text\").strip()\n                if not page_text:\n                    empty_pages += 1\n                    # Try OCR-like text extraction for images\n                    page_text = page.get_text(\"dict\")  # Get structured text\n                    if page_text and \"blocks\" in page_text:\n                        # Check if page has images but no text\n                        has_images = any(\n                            block.get(\"type\") == 1\n                            for block in page_text.get(\"blocks\", [])\n                        )\n                        if has_images:\n                            extracted_text.append(\n                                f\"[Page {page_num + 1}: Contains images but no extractable text]\"\n                            )\n                        else:\n                            extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n                    else:\n                        extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n                else:\n                    extracted_text.append(page_text)\n\n            doc.close()\n\n            # Only raise error if ALL pages are empty and there's no content at all\n            if not any(\n                text.strip() and not text.startswith(\"[Page\") for text in extracted_text\n            ):\n                if empty_pages == len(extracted_text):\n                    raise InvalidFileError(\n                        f\"PDF contains {empty_pages} empty pages with no extractable text. \"\n                        \"This may be a scanned PDF that requires OCR.\"\n                    )\n\n            result = \"\\n\".join(extracted_text)\n            return result\n\n        except fitz.FileDataError as e:\n            raise InvalidFileError(f\"Invalid or corrupted PDF file: {e}\")\n        except fitz.EmptyFileError:\n            raise InvalidFileError(\"PDF file is empty\")\n        except Exception as e:\n            if isinstance(e, (ExtractionError, InvalidFileError)):\n                raise\n            raise ExtractionError(f\"PDF extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/pdf/#textxtract.handlers.pdf.PDFHandler-functions","title":"Functions","text":""},{"location":"reference/handlers/pdf/#textxtract.handlers.pdf.PDFHandler.extract","title":"extract","text":"<pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/pdf.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            import fitz  # PyMuPDF\n        except ImportError:\n            raise ExtractionError(\n                \"PyMuPDF package is not installed. Install with 'pip install text-extractor[pdf]'\"\n            )\n\n        doc = fitz.open(file_path)\n        extracted_text = []\n        empty_pages = 0\n\n        for page_num, page in enumerate(doc):\n            page_text = page.get_text(\"text\").strip()\n            if not page_text:\n                empty_pages += 1\n                # Try OCR-like text extraction for images\n                page_text = page.get_text(\"dict\")  # Get structured text\n                if page_text and \"blocks\" in page_text:\n                    # Check if page has images but no text\n                    has_images = any(\n                        block.get(\"type\") == 1\n                        for block in page_text.get(\"blocks\", [])\n                    )\n                    if has_images:\n                        extracted_text.append(\n                            f\"[Page {page_num + 1}: Contains images but no extractable text]\"\n                        )\n                    else:\n                        extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n                else:\n                    extracted_text.append(f\"[Page {page_num + 1}: Empty page]\")\n            else:\n                extracted_text.append(page_text)\n\n        doc.close()\n\n        # Only raise error if ALL pages are empty and there's no content at all\n        if not any(\n            text.strip() and not text.startswith(\"[Page\") for text in extracted_text\n        ):\n            if empty_pages == len(extracted_text):\n                raise InvalidFileError(\n                    f\"PDF contains {empty_pages} empty pages with no extractable text. \"\n                    \"This may be a scanned PDF that requires OCR.\"\n                )\n\n        result = \"\\n\".join(extracted_text)\n        return result\n\n    except fitz.FileDataError as e:\n        raise InvalidFileError(f\"Invalid or corrupted PDF file: {e}\")\n    except fitz.EmptyFileError:\n        raise InvalidFileError(\"PDF file is empty\")\n    except Exception as e:\n        if isinstance(e, (ExtractionError, InvalidFileError)):\n            raise\n        raise ExtractionError(f\"PDF extraction failed: {e}\")\n</code></pre>"},{"location":"reference/handlers/pdf/#textxtract.handlers.pdf.PDFHandler.extract_async","title":"extract_async  <code>async</code>","text":"<pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/pdf.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/rtf/","title":"Rtf Module","text":"<p>RTF file handler for text extraction.</p> <p>Classes:</p> Name Description <code>RTFHandler</code> <p>Handler for extracting text from RTF files.</p>"},{"location":"reference/handlers/rtf/#textxtract.handlers.rtf-classes","title":"Classes","text":""},{"location":"reference/handlers/rtf/#textxtract.handlers.rtf.RTFHandler","title":"RTFHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from RTF files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/rtf.py</code> <pre><code>class RTFHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from RTF files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                from striprtf.striprtf import rtf_to_text\n            except ImportError:\n                raise ExtractionError(\n                    \"striprtf package is not installed. Install with 'pip install text-extractor[rtf]'\"\n                )\n\n            with open(\n                file_path, \"r\", encoding=(config or {}).get(\"encoding\", \"utf-8\")\n            ) as f:\n                rtf_content = f.read()\n                return rtf_to_text(rtf_content)\n        except Exception as e:\n            raise ExtractionError(f\"RTF extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/rtf/#textxtract.handlers.rtf.RTFHandler-functions","title":"Functions","text":""},{"location":"reference/handlers/rtf/#textxtract.handlers.rtf.RTFHandler.extract","title":"extract","text":"<pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/rtf.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            from striprtf.striprtf import rtf_to_text\n        except ImportError:\n            raise ExtractionError(\n                \"striprtf package is not installed. Install with 'pip install text-extractor[rtf]'\"\n            )\n\n        with open(\n            file_path, \"r\", encoding=(config or {}).get(\"encoding\", \"utf-8\")\n        ) as f:\n            rtf_content = f.read()\n            return rtf_to_text(rtf_content)\n    except Exception as e:\n        raise ExtractionError(f\"RTF extraction failed: {e}\")\n</code></pre>"},{"location":"reference/handlers/rtf/#textxtract.handlers.rtf.RTFHandler.extract_async","title":"extract_async  <code>async</code>","text":"<pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/rtf.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/txt/","title":"Txt Module","text":"<p>TXT file handler for text extraction.</p> <p>Classes:</p> Name Description <code>TXTHandler</code> <p>Handler for extracting text from TXT files.</p>"},{"location":"reference/handlers/txt/#textxtract.handlers.txt-classes","title":"Classes","text":""},{"location":"reference/handlers/txt/#textxtract.handlers.txt.TXTHandler","title":"TXTHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from TXT files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/txt.py</code> <pre><code>class TXTHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from TXT files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        try:\n            return file_path.read_text(encoding=encoding)\n        except Exception as e:\n            raise ExtractionError(f\"TXT extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/txt/#textxtract.handlers.txt.TXTHandler-functions","title":"Functions","text":""},{"location":"reference/handlers/txt/#textxtract.handlers.txt.TXTHandler.extract","title":"extract","text":"<pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/txt.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    encoding = (config or {}).get(\"encoding\", \"utf-8\")\n    try:\n        return file_path.read_text(encoding=encoding)\n    except Exception as e:\n        raise ExtractionError(f\"TXT extraction failed: {e}\")\n</code></pre>"},{"location":"reference/handlers/txt/#textxtract.handlers.txt.TXTHandler.extract_async","title":"extract_async  <code>async</code>","text":"<pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/txt.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/xml/","title":"Xml Module","text":"<p>XML file handler for text extraction.</p> <p>Classes:</p> Name Description <code>XMLHandler</code> <p>Handler for extracting text from XML files.</p>"},{"location":"reference/handlers/xml/#textxtract.handlers.xml-classes","title":"Classes","text":""},{"location":"reference/handlers/xml/#textxtract.handlers.xml.XMLHandler","title":"XMLHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from XML files.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> Source code in <code>textxtract/handlers/xml.py</code> <pre><code>class XMLHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from XML files.\"\"\"\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n        try:\n            try:\n                from lxml import etree\n            except ImportError:\n                raise ExtractionError(\n                    \"lxml package is not installed. Install with 'pip install text-extractor[xml]'\"\n                )\n            encoding = (config or {}).get(\"encoding\", \"utf-8\")\n            with open(file_path, \"r\", encoding=encoding) as f:\n                tree = etree.parse(f)\n                return \" \".join(tree.xpath(\"//text()\"))\n        except Exception as e:\n            raise ExtractionError(f\"XML extraction failed: {e}\")\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; str:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/xml/#textxtract.handlers.xml.XMLHandler-functions","title":"Functions","text":""},{"location":"reference/handlers/xml/#textxtract.handlers.xml.XMLHandler.extract","title":"extract","text":"<pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/xml.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; str:\n    try:\n        try:\n            from lxml import etree\n        except ImportError:\n            raise ExtractionError(\n                \"lxml package is not installed. Install with 'pip install text-extractor[xml]'\"\n            )\n        encoding = (config or {}).get(\"encoding\", \"utf-8\")\n        with open(file_path, \"r\", encoding=encoding) as f:\n            tree = etree.parse(f)\n            return \" \".join(tree.xpath(\"//text()\"))\n    except Exception as e:\n        raise ExtractionError(f\"XML extraction failed: {e}\")\n</code></pre>"},{"location":"reference/handlers/xml/#textxtract.handlers.xml.XMLHandler.extract_async","title":"extract_async  <code>async</code>","text":"<pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/xml.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; str:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/zip/","title":"Zip Module","text":"<p>ZIP file handler for text extraction.</p> <p>Classes:</p> Name Description <code>ZIPHandler</code> <p>Handler for extracting text from ZIP archives with security checks.</p> <p>Attributes:</p> Name Type Description <code>logger</code>"},{"location":"reference/handlers/zip/#textxtract.handlers.zip-attributes","title":"Attributes","text":""},{"location":"reference/handlers/zip/#textxtract.handlers.zip.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger('textxtract.handlers.zip')\n</code></pre>"},{"location":"reference/handlers/zip/#textxtract.handlers.zip-classes","title":"Classes","text":""},{"location":"reference/handlers/zip/#textxtract.handlers.zip.ZIPHandler","title":"ZIPHandler","text":"<p>               Bases: <code>FileTypeHandler</code></p> <p>Handler for extracting text from ZIP archives with security checks.</p> <p>Methods:</p> Name Description <code>extract</code> <code>extract_async</code> <p>Attributes:</p> Name Type Description <code>MAX_EXTRACT_SIZE</code> <code>MAX_FILES</code> Source code in <code>textxtract/handlers/zip.py</code> <pre><code>class ZIPHandler(FileTypeHandler):\n    \"\"\"Handler for extracting text from ZIP archives with security checks.\"\"\"\n\n    MAX_EXTRACT_SIZE = 1024 * 1024 * 1024  # 1GB total\n    MAX_FILES = 1000  # Maximum files to process\n\n    def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; List[str]:\n        extracted_texts = []\n        total_size = 0\n        file_count = 0\n\n        try:\n            with zipfile.ZipFile(file_path, \"r\") as zip_file:\n                for file_info in zip_file.infolist():\n                    if file_info.is_dir():\n                        continue\n\n                    # Security checks\n                    if file_count &gt;= self.MAX_FILES:\n                        logger.warning(\"Maximum file limit reached in ZIP archive\")\n                        break\n\n                    # Check for path traversal\n                    if self._is_unsafe_path(file_info.filename):\n                        logger.warning(\"Skipping unsafe path: %s\", file_info.filename)\n                        continue\n\n                    # Check file size\n                    if file_info.file_size &gt; 100 * 1024 * 1024:  # 100MB per file\n                        logger.warning(\n                            \"Skipping large file: %s (%d bytes)\",\n                            file_info.filename,\n                            file_info.file_size,\n                        )\n                        continue\n\n                    total_size += file_info.file_size\n                    if total_size &gt; self.MAX_EXTRACT_SIZE:\n                        logger.warning(\"Total extract size limit reached\")\n                        break\n\n                    file_count += 1\n\n                    try:\n                        with zip_file.open(file_info.filename) as source_file:\n                            file_bytes = source_file.read()\n                            suffix = Path(file_info.filename).suffix.lower()\n\n                            # Use registry to get handler\n                            from textxtract.core.registry import registry\n\n                            if registry.is_supported(suffix):\n                                handler = registry.get_handler(suffix)\n                                with tempfile.NamedTemporaryFile(\n                                    delete=False, suffix=suffix\n                                ) as temp_file:\n                                    temp_file.write(file_bytes)\n                                    temp_path = Path(temp_file.name)\n                                try:\n                                    text = handler.extract(temp_path, config)\n                                    extracted_texts.append(text)\n                                    logger.debug(\n                                        \"Extracted text from %s\", file_info.filename\n                                    )\n                                except Exception as e:\n                                    logger.warning(\n                                        \"Failed to extract text from %s: %s\",\n                                        file_info.filename,\n                                        e,\n                                    )\n                                finally:\n                                    temp_path.unlink(missing_ok=True)\n                            else:\n                                logger.debug(\n                                    \"Unsupported file type: %s\", file_info.filename\n                                )\n\n                    except Exception as e:\n                        logger.warning(\n                            \"Error processing file %s: %s\", file_info.filename, e\n                        )\n                        continue\n\n            logger.info(\n                \"Extracted text from %d files in ZIP archive\", len(extracted_texts)\n            )\n            return extracted_texts\n\n        except Exception as e:\n            raise ExtractionError(f\"ZIP extraction failed: {e}\")\n\n    def _is_unsafe_path(self, path: str) -&gt; bool:\n        \"\"\"Check if a path contains unsafe elements.\"\"\"\n        # Normalize path separators\n        normalized = path.replace(\"\\\\\", \"/\")\n\n        # Check for path traversal attempts\n        if \"..\" in normalized or normalized.startswith(\"/\"):\n            return True\n\n        # Check for absolute paths on Windows\n        if len(normalized) &gt; 1 and normalized[1] == \":\":\n            return True\n\n        return False\n\n    async def extract_async(\n        self, file_path: Path, config: Optional[dict] = None\n    ) -&gt; List[str]:\n        import asyncio\n\n        return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/handlers/zip/#textxtract.handlers.zip.ZIPHandler-attributes","title":"Attributes","text":""},{"location":"reference/handlers/zip/#textxtract.handlers.zip.ZIPHandler.MAX_EXTRACT_SIZE","title":"MAX_EXTRACT_SIZE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAX_EXTRACT_SIZE = 1024 * 1024 * 1024\n</code></pre>"},{"location":"reference/handlers/zip/#textxtract.handlers.zip.ZIPHandler.MAX_FILES","title":"MAX_FILES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAX_FILES = 1000\n</code></pre>"},{"location":"reference/handlers/zip/#textxtract.handlers.zip.ZIPHandler-functions","title":"Functions","text":""},{"location":"reference/handlers/zip/#textxtract.handlers.zip.ZIPHandler.extract","title":"extract","text":"<pre><code>extract(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/zip.py</code> <pre><code>def extract(self, file_path: Path, config: Optional[dict] = None) -&gt; List[str]:\n    extracted_texts = []\n    total_size = 0\n    file_count = 0\n\n    try:\n        with zipfile.ZipFile(file_path, \"r\") as zip_file:\n            for file_info in zip_file.infolist():\n                if file_info.is_dir():\n                    continue\n\n                # Security checks\n                if file_count &gt;= self.MAX_FILES:\n                    logger.warning(\"Maximum file limit reached in ZIP archive\")\n                    break\n\n                # Check for path traversal\n                if self._is_unsafe_path(file_info.filename):\n                    logger.warning(\"Skipping unsafe path: %s\", file_info.filename)\n                    continue\n\n                # Check file size\n                if file_info.file_size &gt; 100 * 1024 * 1024:  # 100MB per file\n                    logger.warning(\n                        \"Skipping large file: %s (%d bytes)\",\n                        file_info.filename,\n                        file_info.file_size,\n                    )\n                    continue\n\n                total_size += file_info.file_size\n                if total_size &gt; self.MAX_EXTRACT_SIZE:\n                    logger.warning(\"Total extract size limit reached\")\n                    break\n\n                file_count += 1\n\n                try:\n                    with zip_file.open(file_info.filename) as source_file:\n                        file_bytes = source_file.read()\n                        suffix = Path(file_info.filename).suffix.lower()\n\n                        # Use registry to get handler\n                        from textxtract.core.registry import registry\n\n                        if registry.is_supported(suffix):\n                            handler = registry.get_handler(suffix)\n                            with tempfile.NamedTemporaryFile(\n                                delete=False, suffix=suffix\n                            ) as temp_file:\n                                temp_file.write(file_bytes)\n                                temp_path = Path(temp_file.name)\n                            try:\n                                text = handler.extract(temp_path, config)\n                                extracted_texts.append(text)\n                                logger.debug(\n                                    \"Extracted text from %s\", file_info.filename\n                                )\n                            except Exception as e:\n                                logger.warning(\n                                    \"Failed to extract text from %s: %s\",\n                                    file_info.filename,\n                                    e,\n                                )\n                            finally:\n                                temp_path.unlink(missing_ok=True)\n                        else:\n                            logger.debug(\n                                \"Unsupported file type: %s\", file_info.filename\n                            )\n\n                except Exception as e:\n                    logger.warning(\n                        \"Error processing file %s: %s\", file_info.filename, e\n                    )\n                    continue\n\n        logger.info(\n            \"Extracted text from %d files in ZIP archive\", len(extracted_texts)\n        )\n        return extracted_texts\n\n    except Exception as e:\n        raise ExtractionError(f\"ZIP extraction failed: {e}\")\n</code></pre>"},{"location":"reference/handlers/zip/#textxtract.handlers.zip.ZIPHandler.extract_async","title":"extract_async  <code>async</code>","text":"<pre><code>extract_async(file_path, config=None)\n</code></pre> Source code in <code>textxtract/handlers/zip.py</code> <pre><code>async def extract_async(\n    self, file_path: Path, config: Optional[dict] = None\n) -&gt; List[str]:\n    import asyncio\n\n    return await asyncio.to_thread(self.extract, file_path, config)\n</code></pre>"},{"location":"reference/sync/","title":"Sync Module","text":""},{"location":"reference/sync/#overview","title":"Overview","text":"<p>Synchronous text extraction components.</p> <p>Synchronous extraction logic package.</p> <p>Modules:</p> Name Description <code>extractor</code> <p>Synchronous text extraction logic.</p>"},{"location":"reference/sync/#textxtract.sync-modules","title":"Modules","text":""},{"location":"reference/sync/#textxtract.sync.extractor","title":"extractor","text":"<p>Synchronous text extraction logic.</p> <p>Classes:</p> Name Description <code>SyncTextExtractor</code> <p>Synchronous text extractor with improved error handling and resource management.</p> <p>Attributes:</p> Name Type Description <code>logger</code>"},{"location":"reference/sync/#textxtract.sync.extractor-attributes","title":"Attributes","text":""},{"location":"reference/sync/#textxtract.sync.extractor.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger('textxtract.sync')\n</code></pre>"},{"location":"reference/sync/#textxtract.sync.extractor-classes","title":"Classes","text":""},{"location":"reference/sync/#textxtract.sync.extractor.SyncTextExtractor","title":"SyncTextExtractor","text":"<p>               Bases: <code>TextExtractor</code></p> <p>Synchronous text extractor with improved error handling and resource management.</p> <p>Provides synchronous text extraction from various file types. Logs debug and info level messages for tracing and diagnostics. Supports context manager protocol for proper cleanup.</p> <p>Methods:</p> Name Description <code>__enter__</code> <p>Context manager entry.</p> <code>__exit__</code> <p>Context manager exit.</p> <code>__init__</code> <code>extract</code> <p>Extract text synchronously from file bytes.</p> <code>extract_async</code> <p>Async interface for compatibility; delegates to sync extract.</p> <p>Attributes:</p> Name Type Description <code>config</code> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>class SyncTextExtractor(TextExtractor):\n    \"\"\"\n    Synchronous text extractor with improved error handling and resource management.\n\n    Provides synchronous text extraction from various file types.\n    Logs debug and info level messages for tracing and diagnostics.\n    Supports context manager protocol for proper cleanup.\n    \"\"\"\n\n    def __init__(self, config: Optional[ExtractorConfig] = None):\n        self.config = config or ExtractorConfig()\n        logger.debug(\n            \"SyncTextExtractor initialized with config: %s\", self.config.__dict__\n        )\n\n    def extract(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"\n        Extract text synchronously from file bytes.\n\n        Args:\n            file_bytes (bytes): The file content as bytes.\n            filename (str): The name of the file (used for extension).\n            config (Optional[dict]): Optional configuration overrides.\n\n        Returns:\n            str: Extracted text.\n\n        Raises:\n            FileTypeNotSupportedError: If the file extension is not supported.\n            ExtractionError: If extraction fails.\n            InvalidFileError: If the file is invalid or corrupted.\n        \"\"\"\n        file_info = get_file_info(file_bytes, filename)\n        temp_path = create_temp_file(\n            file_bytes, filename, config and config.get(\"max_file_size\")\n        )\n\n        logger.debug(\n            \"Temporary file created at %s for file info: %s\", temp_path, file_info\n        )\n\n        try:\n            suffix = Path(filename).suffix.lower()\n            logger.debug(\"Detected file suffix: %s\", suffix)\n\n            handler = registry.get_handler(suffix)\n            handler_name = handler.__class__.__name__\n\n            logger.info(\n                \"Using handler %s for file %s (size: %s MB)\",\n                handler_name,\n                filename,\n                file_info[\"size_mb\"],\n            )\n\n            try:\n                result = handler.extract(temp_path, config or self.config.__dict__)\n            except Exception as e:\n                from textxtract.core.exceptions import (\n                    ExtractionError,\n                    InvalidFileError,\n                )\n\n                logger.error(\n                    \"Extraction failed for file %s (handler: %s): %s\",\n                    filename,\n                    handler_name,\n                    e,\n                )\n\n                # If it's already a custom extraction error, re-raise\n                if isinstance(e, ExtractionError):\n                    raise\n                # If it's a known invalid file error, wrap it\n                if isinstance(e, (ValueError, OSError)):\n                    raise InvalidFileError(\n                        f\"Invalid file: {filename} (handler: {handler_name}, error: {e})\"\n                    ) from e\n                # Otherwise, wrap as general extraction error\n                raise ExtractionError(\n                    f\"Extraction failed for file {filename} using {handler_name}: {e}\"\n                ) from e\n\n            logger.info(\n                \"Extraction successful for file %s (extracted %d characters)\",\n                filename,\n                len(result),\n            )\n            return result\n        finally:\n            safe_unlink(temp_path)\n            logger.debug(\"Temporary file %s deleted\", temp_path)\n\n    async def extract_async(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"\n        Async interface for compatibility; delegates to sync extract.\n\n        Raises:\n            NotImplementedError: Always, as sync extractor does not support async.\n        \"\"\"\n        raise NotImplementedError(\n            \"Synchronous extractor does not support async extraction. Use AsyncTextExtractor instead.\"\n        )\n\n    def __enter__(self):\n        \"\"\"Context manager entry.\"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit.\"\"\"\n        pass  # No resources to clean up for sync extractor\n</code></pre>"},{"location":"reference/sync/#textxtract.sync.extractor.SyncTextExtractor-attributes","title":"Attributes","text":"config <code>instance-attribute</code> <pre><code>config = config or ExtractorConfig()\n</code></pre>"},{"location":"reference/sync/#textxtract.sync.extractor.SyncTextExtractor-functions","title":"Functions","text":"__enter__ <pre><code>__enter__()\n</code></pre> <p>Context manager entry.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    return self\n</code></pre> <code></code> __exit__ <pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Context manager exit.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    pass  # No resources to clean up for sync extractor\n</code></pre> <code></code> __init__ <pre><code>__init__(config=None)\n</code></pre> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def __init__(self, config: Optional[ExtractorConfig] = None):\n    self.config = config or ExtractorConfig()\n    logger.debug(\n        \"SyncTextExtractor initialized with config: %s\", self.config.__dict__\n    )\n</code></pre> <code></code> extract <pre><code>extract(file_bytes, filename, config=None)\n</code></pre> <p>Extract text synchronously from file bytes.</p> <p>Parameters:</p> Name Type Description Default <code>file_bytes</code> <code>bytes</code> <p>The file content as bytes.</p> required <code>filename</code> <code>str</code> <p>The name of the file (used for extension).</p> required <code>config</code> <code>Optional[dict]</code> <p>Optional configuration overrides.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted text.</p> <p>Raises:</p> Type Description <code>FileTypeNotSupportedError</code> <p>If the file extension is not supported.</p> <code>ExtractionError</code> <p>If extraction fails.</p> <code>InvalidFileError</code> <p>If the file is invalid or corrupted.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def extract(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"\n    Extract text synchronously from file bytes.\n\n    Args:\n        file_bytes (bytes): The file content as bytes.\n        filename (str): The name of the file (used for extension).\n        config (Optional[dict]): Optional configuration overrides.\n\n    Returns:\n        str: Extracted text.\n\n    Raises:\n        FileTypeNotSupportedError: If the file extension is not supported.\n        ExtractionError: If extraction fails.\n        InvalidFileError: If the file is invalid or corrupted.\n    \"\"\"\n    file_info = get_file_info(file_bytes, filename)\n    temp_path = create_temp_file(\n        file_bytes, filename, config and config.get(\"max_file_size\")\n    )\n\n    logger.debug(\n        \"Temporary file created at %s for file info: %s\", temp_path, file_info\n    )\n\n    try:\n        suffix = Path(filename).suffix.lower()\n        logger.debug(\"Detected file suffix: %s\", suffix)\n\n        handler = registry.get_handler(suffix)\n        handler_name = handler.__class__.__name__\n\n        logger.info(\n            \"Using handler %s for file %s (size: %s MB)\",\n            handler_name,\n            filename,\n            file_info[\"size_mb\"],\n        )\n\n        try:\n            result = handler.extract(temp_path, config or self.config.__dict__)\n        except Exception as e:\n            from textxtract.core.exceptions import (\n                ExtractionError,\n                InvalidFileError,\n            )\n\n            logger.error(\n                \"Extraction failed for file %s (handler: %s): %s\",\n                filename,\n                handler_name,\n                e,\n            )\n\n            # If it's already a custom extraction error, re-raise\n            if isinstance(e, ExtractionError):\n                raise\n            # If it's a known invalid file error, wrap it\n            if isinstance(e, (ValueError, OSError)):\n                raise InvalidFileError(\n                    f\"Invalid file: {filename} (handler: {handler_name}, error: {e})\"\n                ) from e\n            # Otherwise, wrap as general extraction error\n            raise ExtractionError(\n                f\"Extraction failed for file {filename} using {handler_name}: {e}\"\n            ) from e\n\n        logger.info(\n            \"Extraction successful for file %s (extracted %d characters)\",\n            filename,\n            len(result),\n        )\n        return result\n    finally:\n        safe_unlink(temp_path)\n        logger.debug(\"Temporary file %s deleted\", temp_path)\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_bytes, filename, config=None)\n</code></pre> <p>Async interface for compatibility; delegates to sync extract.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always, as sync extractor does not support async.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>async def extract_async(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"\n    Async interface for compatibility; delegates to sync extract.\n\n    Raises:\n        NotImplementedError: Always, as sync extractor does not support async.\n    \"\"\"\n    raise NotImplementedError(\n        \"Synchronous extractor does not support async extraction. Use AsyncTextExtractor instead.\"\n    )\n</code></pre>"},{"location":"reference/sync/#textxtract.sync.extractor-functions","title":"Functions","text":""},{"location":"reference/sync/__init__/","title":"Sync Module","text":"<p>Synchronous extraction logic package.</p> <p>Modules:</p> Name Description <code>extractor</code> <p>Synchronous text extraction logic.</p>"},{"location":"reference/sync/__init__/#textxtract.sync-modules","title":"Modules","text":""},{"location":"reference/sync/__init__/#textxtract.sync.extractor","title":"extractor","text":"<p>Synchronous text extraction logic.</p> <p>Classes:</p> Name Description <code>SyncTextExtractor</code> <p>Synchronous text extractor with improved error handling and resource management.</p> <p>Attributes:</p> Name Type Description <code>logger</code>"},{"location":"reference/sync/__init__/#textxtract.sync.extractor-attributes","title":"Attributes","text":""},{"location":"reference/sync/__init__/#textxtract.sync.extractor.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger('textxtract.sync')\n</code></pre>"},{"location":"reference/sync/__init__/#textxtract.sync.extractor-classes","title":"Classes","text":""},{"location":"reference/sync/__init__/#textxtract.sync.extractor.SyncTextExtractor","title":"SyncTextExtractor","text":"<p>               Bases: <code>TextExtractor</code></p> <p>Synchronous text extractor with improved error handling and resource management.</p> <p>Provides synchronous text extraction from various file types. Logs debug and info level messages for tracing and diagnostics. Supports context manager protocol for proper cleanup.</p> <p>Methods:</p> Name Description <code>__enter__</code> <p>Context manager entry.</p> <code>__exit__</code> <p>Context manager exit.</p> <code>__init__</code> <code>extract</code> <p>Extract text synchronously from file bytes.</p> <code>extract_async</code> <p>Async interface for compatibility; delegates to sync extract.</p> <p>Attributes:</p> Name Type Description <code>config</code> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>class SyncTextExtractor(TextExtractor):\n    \"\"\"\n    Synchronous text extractor with improved error handling and resource management.\n\n    Provides synchronous text extraction from various file types.\n    Logs debug and info level messages for tracing and diagnostics.\n    Supports context manager protocol for proper cleanup.\n    \"\"\"\n\n    def __init__(self, config: Optional[ExtractorConfig] = None):\n        self.config = config or ExtractorConfig()\n        logger.debug(\n            \"SyncTextExtractor initialized with config: %s\", self.config.__dict__\n        )\n\n    def extract(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"\n        Extract text synchronously from file bytes.\n\n        Args:\n            file_bytes (bytes): The file content as bytes.\n            filename (str): The name of the file (used for extension).\n            config (Optional[dict]): Optional configuration overrides.\n\n        Returns:\n            str: Extracted text.\n\n        Raises:\n            FileTypeNotSupportedError: If the file extension is not supported.\n            ExtractionError: If extraction fails.\n            InvalidFileError: If the file is invalid or corrupted.\n        \"\"\"\n        file_info = get_file_info(file_bytes, filename)\n        temp_path = create_temp_file(\n            file_bytes, filename, config and config.get(\"max_file_size\")\n        )\n\n        logger.debug(\n            \"Temporary file created at %s for file info: %s\", temp_path, file_info\n        )\n\n        try:\n            suffix = Path(filename).suffix.lower()\n            logger.debug(\"Detected file suffix: %s\", suffix)\n\n            handler = registry.get_handler(suffix)\n            handler_name = handler.__class__.__name__\n\n            logger.info(\n                \"Using handler %s for file %s (size: %s MB)\",\n                handler_name,\n                filename,\n                file_info[\"size_mb\"],\n            )\n\n            try:\n                result = handler.extract(temp_path, config or self.config.__dict__)\n            except Exception as e:\n                from textxtract.core.exceptions import (\n                    ExtractionError,\n                    InvalidFileError,\n                )\n\n                logger.error(\n                    \"Extraction failed for file %s (handler: %s): %s\",\n                    filename,\n                    handler_name,\n                    e,\n                )\n\n                # If it's already a custom extraction error, re-raise\n                if isinstance(e, ExtractionError):\n                    raise\n                # If it's a known invalid file error, wrap it\n                if isinstance(e, (ValueError, OSError)):\n                    raise InvalidFileError(\n                        f\"Invalid file: {filename} (handler: {handler_name}, error: {e})\"\n                    ) from e\n                # Otherwise, wrap as general extraction error\n                raise ExtractionError(\n                    f\"Extraction failed for file {filename} using {handler_name}: {e}\"\n                ) from e\n\n            logger.info(\n                \"Extraction successful for file %s (extracted %d characters)\",\n                filename,\n                len(result),\n            )\n            return result\n        finally:\n            safe_unlink(temp_path)\n            logger.debug(\"Temporary file %s deleted\", temp_path)\n\n    async def extract_async(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"\n        Async interface for compatibility; delegates to sync extract.\n\n        Raises:\n            NotImplementedError: Always, as sync extractor does not support async.\n        \"\"\"\n        raise NotImplementedError(\n            \"Synchronous extractor does not support async extraction. Use AsyncTextExtractor instead.\"\n        )\n\n    def __enter__(self):\n        \"\"\"Context manager entry.\"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit.\"\"\"\n        pass  # No resources to clean up for sync extractor\n</code></pre>"},{"location":"reference/sync/__init__/#textxtract.sync.extractor.SyncTextExtractor-attributes","title":"Attributes","text":"config <code>instance-attribute</code> <pre><code>config = config or ExtractorConfig()\n</code></pre>"},{"location":"reference/sync/__init__/#textxtract.sync.extractor.SyncTextExtractor-functions","title":"Functions","text":"__enter__ <pre><code>__enter__()\n</code></pre> <p>Context manager entry.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    return self\n</code></pre> <code></code> __exit__ <pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Context manager exit.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    pass  # No resources to clean up for sync extractor\n</code></pre> <code></code> __init__ <pre><code>__init__(config=None)\n</code></pre> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def __init__(self, config: Optional[ExtractorConfig] = None):\n    self.config = config or ExtractorConfig()\n    logger.debug(\n        \"SyncTextExtractor initialized with config: %s\", self.config.__dict__\n    )\n</code></pre> <code></code> extract <pre><code>extract(file_bytes, filename, config=None)\n</code></pre> <p>Extract text synchronously from file bytes.</p> <p>Parameters:</p> Name Type Description Default <code>file_bytes</code> <code>bytes</code> <p>The file content as bytes.</p> required <code>filename</code> <code>str</code> <p>The name of the file (used for extension).</p> required <code>config</code> <code>Optional[dict]</code> <p>Optional configuration overrides.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted text.</p> <p>Raises:</p> Type Description <code>FileTypeNotSupportedError</code> <p>If the file extension is not supported.</p> <code>ExtractionError</code> <p>If extraction fails.</p> <code>InvalidFileError</code> <p>If the file is invalid or corrupted.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def extract(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"\n    Extract text synchronously from file bytes.\n\n    Args:\n        file_bytes (bytes): The file content as bytes.\n        filename (str): The name of the file (used for extension).\n        config (Optional[dict]): Optional configuration overrides.\n\n    Returns:\n        str: Extracted text.\n\n    Raises:\n        FileTypeNotSupportedError: If the file extension is not supported.\n        ExtractionError: If extraction fails.\n        InvalidFileError: If the file is invalid or corrupted.\n    \"\"\"\n    file_info = get_file_info(file_bytes, filename)\n    temp_path = create_temp_file(\n        file_bytes, filename, config and config.get(\"max_file_size\")\n    )\n\n    logger.debug(\n        \"Temporary file created at %s for file info: %s\", temp_path, file_info\n    )\n\n    try:\n        suffix = Path(filename).suffix.lower()\n        logger.debug(\"Detected file suffix: %s\", suffix)\n\n        handler = registry.get_handler(suffix)\n        handler_name = handler.__class__.__name__\n\n        logger.info(\n            \"Using handler %s for file %s (size: %s MB)\",\n            handler_name,\n            filename,\n            file_info[\"size_mb\"],\n        )\n\n        try:\n            result = handler.extract(temp_path, config or self.config.__dict__)\n        except Exception as e:\n            from textxtract.core.exceptions import (\n                ExtractionError,\n                InvalidFileError,\n            )\n\n            logger.error(\n                \"Extraction failed for file %s (handler: %s): %s\",\n                filename,\n                handler_name,\n                e,\n            )\n\n            # If it's already a custom extraction error, re-raise\n            if isinstance(e, ExtractionError):\n                raise\n            # If it's a known invalid file error, wrap it\n            if isinstance(e, (ValueError, OSError)):\n                raise InvalidFileError(\n                    f\"Invalid file: {filename} (handler: {handler_name}, error: {e})\"\n                ) from e\n            # Otherwise, wrap as general extraction error\n            raise ExtractionError(\n                f\"Extraction failed for file {filename} using {handler_name}: {e}\"\n            ) from e\n\n        logger.info(\n            \"Extraction successful for file %s (extracted %d characters)\",\n            filename,\n            len(result),\n        )\n        return result\n    finally:\n        safe_unlink(temp_path)\n        logger.debug(\"Temporary file %s deleted\", temp_path)\n</code></pre> <code></code> extract_async <code>async</code> <pre><code>extract_async(file_bytes, filename, config=None)\n</code></pre> <p>Async interface for compatibility; delegates to sync extract.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always, as sync extractor does not support async.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>async def extract_async(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"\n    Async interface for compatibility; delegates to sync extract.\n\n    Raises:\n        NotImplementedError: Always, as sync extractor does not support async.\n    \"\"\"\n    raise NotImplementedError(\n        \"Synchronous extractor does not support async extraction. Use AsyncTextExtractor instead.\"\n    )\n</code></pre>"},{"location":"reference/sync/__init__/#textxtract.sync.extractor-functions","title":"Functions","text":""},{"location":"reference/sync/extractor/","title":"Extractor Module","text":"<p>Synchronous text extraction logic.</p> <p>Classes:</p> Name Description <code>SyncTextExtractor</code> <p>Synchronous text extractor with improved error handling and resource management.</p> <p>Attributes:</p> Name Type Description <code>logger</code>"},{"location":"reference/sync/extractor/#textxtract.sync.extractor-attributes","title":"Attributes","text":""},{"location":"reference/sync/extractor/#textxtract.sync.extractor.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger('textxtract.sync')\n</code></pre>"},{"location":"reference/sync/extractor/#textxtract.sync.extractor-classes","title":"Classes","text":""},{"location":"reference/sync/extractor/#textxtract.sync.extractor.SyncTextExtractor","title":"SyncTextExtractor","text":"<p>               Bases: <code>TextExtractor</code></p> <p>Synchronous text extractor with improved error handling and resource management.</p> <p>Provides synchronous text extraction from various file types. Logs debug and info level messages for tracing and diagnostics. Supports context manager protocol for proper cleanup.</p> <p>Methods:</p> Name Description <code>__enter__</code> <p>Context manager entry.</p> <code>__exit__</code> <p>Context manager exit.</p> <code>__init__</code> <code>extract</code> <p>Extract text synchronously from file bytes.</p> <code>extract_async</code> <p>Async interface for compatibility; delegates to sync extract.</p> <p>Attributes:</p> Name Type Description <code>config</code> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>class SyncTextExtractor(TextExtractor):\n    \"\"\"\n    Synchronous text extractor with improved error handling and resource management.\n\n    Provides synchronous text extraction from various file types.\n    Logs debug and info level messages for tracing and diagnostics.\n    Supports context manager protocol for proper cleanup.\n    \"\"\"\n\n    def __init__(self, config: Optional[ExtractorConfig] = None):\n        self.config = config or ExtractorConfig()\n        logger.debug(\n            \"SyncTextExtractor initialized with config: %s\", self.config.__dict__\n        )\n\n    def extract(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"\n        Extract text synchronously from file bytes.\n\n        Args:\n            file_bytes (bytes): The file content as bytes.\n            filename (str): The name of the file (used for extension).\n            config (Optional[dict]): Optional configuration overrides.\n\n        Returns:\n            str: Extracted text.\n\n        Raises:\n            FileTypeNotSupportedError: If the file extension is not supported.\n            ExtractionError: If extraction fails.\n            InvalidFileError: If the file is invalid or corrupted.\n        \"\"\"\n        file_info = get_file_info(file_bytes, filename)\n        temp_path = create_temp_file(\n            file_bytes, filename, config and config.get(\"max_file_size\")\n        )\n\n        logger.debug(\n            \"Temporary file created at %s for file info: %s\", temp_path, file_info\n        )\n\n        try:\n            suffix = Path(filename).suffix.lower()\n            logger.debug(\"Detected file suffix: %s\", suffix)\n\n            handler = registry.get_handler(suffix)\n            handler_name = handler.__class__.__name__\n\n            logger.info(\n                \"Using handler %s for file %s (size: %s MB)\",\n                handler_name,\n                filename,\n                file_info[\"size_mb\"],\n            )\n\n            try:\n                result = handler.extract(temp_path, config or self.config.__dict__)\n            except Exception as e:\n                from textxtract.core.exceptions import (\n                    ExtractionError,\n                    InvalidFileError,\n                )\n\n                logger.error(\n                    \"Extraction failed for file %s (handler: %s): %s\",\n                    filename,\n                    handler_name,\n                    e,\n                )\n\n                # If it's already a custom extraction error, re-raise\n                if isinstance(e, ExtractionError):\n                    raise\n                # If it's a known invalid file error, wrap it\n                if isinstance(e, (ValueError, OSError)):\n                    raise InvalidFileError(\n                        f\"Invalid file: {filename} (handler: {handler_name}, error: {e})\"\n                    ) from e\n                # Otherwise, wrap as general extraction error\n                raise ExtractionError(\n                    f\"Extraction failed for file {filename} using {handler_name}: {e}\"\n                ) from e\n\n            logger.info(\n                \"Extraction successful for file %s (extracted %d characters)\",\n                filename,\n                len(result),\n            )\n            return result\n        finally:\n            safe_unlink(temp_path)\n            logger.debug(\"Temporary file %s deleted\", temp_path)\n\n    async def extract_async(\n        self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n    ) -&gt; str:\n        \"\"\"\n        Async interface for compatibility; delegates to sync extract.\n\n        Raises:\n            NotImplementedError: Always, as sync extractor does not support async.\n        \"\"\"\n        raise NotImplementedError(\n            \"Synchronous extractor does not support async extraction. Use AsyncTextExtractor instead.\"\n        )\n\n    def __enter__(self):\n        \"\"\"Context manager entry.\"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit.\"\"\"\n        pass  # No resources to clean up for sync extractor\n</code></pre>"},{"location":"reference/sync/extractor/#textxtract.sync.extractor.SyncTextExtractor-attributes","title":"Attributes","text":""},{"location":"reference/sync/extractor/#textxtract.sync.extractor.SyncTextExtractor.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = config or ExtractorConfig()\n</code></pre>"},{"location":"reference/sync/extractor/#textxtract.sync.extractor.SyncTextExtractor-functions","title":"Functions","text":""},{"location":"reference/sync/extractor/#textxtract.sync.extractor.SyncTextExtractor.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>Context manager entry.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/sync/extractor/#textxtract.sync.extractor.SyncTextExtractor.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Context manager exit.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    pass  # No resources to clean up for sync extractor\n</code></pre>"},{"location":"reference/sync/extractor/#textxtract.sync.extractor.SyncTextExtractor.__init__","title":"__init__","text":"<pre><code>__init__(config=None)\n</code></pre> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def __init__(self, config: Optional[ExtractorConfig] = None):\n    self.config = config or ExtractorConfig()\n    logger.debug(\n        \"SyncTextExtractor initialized with config: %s\", self.config.__dict__\n    )\n</code></pre>"},{"location":"reference/sync/extractor/#textxtract.sync.extractor.SyncTextExtractor.extract","title":"extract","text":"<pre><code>extract(file_bytes, filename, config=None)\n</code></pre> <p>Extract text synchronously from file bytes.</p> <p>Parameters:</p> Name Type Description Default <code>bytes</code> <p>The file content as bytes.</p> required <code>str</code> <p>The name of the file (used for extension).</p> required <code>Optional[dict]</code> <p>Optional configuration overrides.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted text.</p> <p>Raises:</p> Type Description <code>FileTypeNotSupportedError</code> <p>If the file extension is not supported.</p> <code>ExtractionError</code> <p>If extraction fails.</p> <code>InvalidFileError</code> <p>If the file is invalid or corrupted.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>def extract(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"\n    Extract text synchronously from file bytes.\n\n    Args:\n        file_bytes (bytes): The file content as bytes.\n        filename (str): The name of the file (used for extension).\n        config (Optional[dict]): Optional configuration overrides.\n\n    Returns:\n        str: Extracted text.\n\n    Raises:\n        FileTypeNotSupportedError: If the file extension is not supported.\n        ExtractionError: If extraction fails.\n        InvalidFileError: If the file is invalid or corrupted.\n    \"\"\"\n    file_info = get_file_info(file_bytes, filename)\n    temp_path = create_temp_file(\n        file_bytes, filename, config and config.get(\"max_file_size\")\n    )\n\n    logger.debug(\n        \"Temporary file created at %s for file info: %s\", temp_path, file_info\n    )\n\n    try:\n        suffix = Path(filename).suffix.lower()\n        logger.debug(\"Detected file suffix: %s\", suffix)\n\n        handler = registry.get_handler(suffix)\n        handler_name = handler.__class__.__name__\n\n        logger.info(\n            \"Using handler %s for file %s (size: %s MB)\",\n            handler_name,\n            filename,\n            file_info[\"size_mb\"],\n        )\n\n        try:\n            result = handler.extract(temp_path, config or self.config.__dict__)\n        except Exception as e:\n            from textxtract.core.exceptions import (\n                ExtractionError,\n                InvalidFileError,\n            )\n\n            logger.error(\n                \"Extraction failed for file %s (handler: %s): %s\",\n                filename,\n                handler_name,\n                e,\n            )\n\n            # If it's already a custom extraction error, re-raise\n            if isinstance(e, ExtractionError):\n                raise\n            # If it's a known invalid file error, wrap it\n            if isinstance(e, (ValueError, OSError)):\n                raise InvalidFileError(\n                    f\"Invalid file: {filename} (handler: {handler_name}, error: {e})\"\n                ) from e\n            # Otherwise, wrap as general extraction error\n            raise ExtractionError(\n                f\"Extraction failed for file {filename} using {handler_name}: {e}\"\n            ) from e\n\n        logger.info(\n            \"Extraction successful for file %s (extracted %d characters)\",\n            filename,\n            len(result),\n        )\n        return result\n    finally:\n        safe_unlink(temp_path)\n        logger.debug(\"Temporary file %s deleted\", temp_path)\n</code></pre>"},{"location":"reference/sync/extractor/#textxtract.sync.extractor.SyncTextExtractor.extract(file_bytes)","title":"<code>file_bytes</code>","text":""},{"location":"reference/sync/extractor/#textxtract.sync.extractor.SyncTextExtractor.extract(filename)","title":"<code>filename</code>","text":""},{"location":"reference/sync/extractor/#textxtract.sync.extractor.SyncTextExtractor.extract(config)","title":"<code>config</code>","text":""},{"location":"reference/sync/extractor/#textxtract.sync.extractor.SyncTextExtractor.extract_async","title":"extract_async  <code>async</code>","text":"<pre><code>extract_async(file_bytes, filename, config=None)\n</code></pre> <p>Async interface for compatibility; delegates to sync extract.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always, as sync extractor does not support async.</p> Source code in <code>textxtract/sync/extractor.py</code> <pre><code>async def extract_async(\n    self, file_bytes: bytes, filename: str, config: Optional[dict] = None\n) -&gt; str:\n    \"\"\"\n    Async interface for compatibility; delegates to sync extract.\n\n    Raises:\n        NotImplementedError: Always, as sync extractor does not support async.\n    \"\"\"\n    raise NotImplementedError(\n        \"Synchronous extractor does not support async extraction. Use AsyncTextExtractor instead.\"\n    )\n</code></pre>"},{"location":"reference/sync/extractor/#textxtract.sync.extractor-functions","title":"Functions","text":""},{"location":"reference/tests/__init__/","title":"Tests Module","text":"<p>Test suite for textxtract package.</p> <p>Modules:</p> Name Description <code>test_async</code> <p>Comprehensive tests for AsyncTextExtractor using all sample files.</p> <code>test_edge_cases</code> <p>Edge case tests for text extractor.</p> <code>test_exceptions</code> <p>Unit tests for custom exceptions.</p> <code>test_sync</code> <p>Comprehensive tests for SyncTextExtractor using all sample files.</p>"},{"location":"reference/tests/__init__/#textxtract.tests-modules","title":"Modules","text":""},{"location":"reference/tests/__init__/#textxtract.tests.test_async","title":"test_async","text":"<p>Comprehensive tests for AsyncTextExtractor using all sample files.</p> <p>Functions:</p> Name Description <code>test_async_extractor_all_types</code> <p>Attributes:</p> Name Type Description <code>TEST_FILES_DIR</code>"},{"location":"reference/tests/__init__/#textxtract.tests.test_async-attributes","title":"Attributes","text":""},{"location":"reference/tests/__init__/#textxtract.tests.test_async.TEST_FILES_DIR","title":"TEST_FILES_DIR  <code>module-attribute</code>","text":"<pre><code>TEST_FILES_DIR = parent / 'files'\n</code></pre>"},{"location":"reference/tests/__init__/#textxtract.tests.test_async-classes","title":"Classes","text":""},{"location":"reference/tests/__init__/#textxtract.tests.test_async-functions","title":"Functions","text":""},{"location":"reference/tests/__init__/#textxtract.tests.test_async.test_async_extractor_all_types","title":"test_async_extractor_all_types  <code>async</code>","text":"<pre><code>test_async_extractor_all_types(filename, should_succeed)\n</code></pre> Source code in <code>textxtract/tests/test_async.py</code> <pre><code>@pytest.mark.parametrize(\n    \"filename,should_succeed\",\n    [\n        (\"text_file.txt\", True),\n        (\"text_file.text\", True),\n        (\"markdown.md\", True),\n        (\"text_file.pdf\", True),\n        (\"text_file.docx\", True),\n        (\"text_file.doc\", True),\n        (\"text_file.rtf\", True),\n        (\"text.html\", True),\n        (\"text.csv\", True),\n        (\"text.json\", True),\n        (\"text.xml\", True),\n        (\"text_zip.zip\", True),\n        (\"text_file.odt\", False),  # Not supported, should fail\n    ],\n)\n@pytest.mark.asyncio\nasync def test_async_extractor_all_types(filename, should_succeed):\n    extractor = AsyncTextExtractor()\n    file_path = TEST_FILES_DIR / filename\n    file_bytes = file_path.read_bytes()\n    try:\n        text = await extractor.extract_async(file_bytes, filename)\n        assert should_succeed, f\"Extraction should have failed for {filename}\"\n        assert isinstance(text, (str, list)), \"Extracted text should be str or list\"\n        assert text, \"Extracted text should not be empty\"\n    except FileTypeNotSupportedError:\n        assert not should_succeed, (\n            f\"FileTypeNotSupportedError unexpected for {filename}\"\n        )\n    except (ExtractionError, InvalidFileError):\n        assert not should_succeed, (\n            f\"ExtractionError/InvalidFileError unexpected for {filename}\"\n        )\n</code></pre>"},{"location":"reference/tests/__init__/#textxtract.tests.test_edge_cases","title":"test_edge_cases","text":"<p>Edge case tests for text extractor.</p> <p>Classes:</p> Name Description <code>TestEdgeCases</code> <p>Test edge cases and error conditions.</p> <code>TestErrorMessages</code> <p>Test that error messages are helpful and informative.</p>"},{"location":"reference/tests/__init__/#textxtract.tests.test_edge_cases-classes","title":"Classes","text":""},{"location":"reference/tests/__init__/#textxtract.tests.test_edge_cases.TestEdgeCases","title":"TestEdgeCases","text":"<p>Test edge cases and error conditions.</p> <p>Methods:</p> Name Description <code>test_async_context_manager_cleanup</code> <p>Test that async context manager properly cleans up.</p> <code>test_async_extractor_closed</code> <p>Test that closed async extractor raises error.</p> <code>test_concurrent_extractions</code> <p>Test multiple concurrent extractions.</p> <code>test_config_from_environment</code> <p>Test loading configuration from environment variables.</p> <code>test_config_validation</code> <p>Test configuration validation.</p> <code>test_context_manager_cleanup</code> <p>Test that context managers properly clean up resources.</p> <code>test_corrupted_pdf</code> <p>Test extraction from corrupted PDF.</p> <code>test_custom_config_per_extraction</code> <p>Test passing custom config per extraction call.</p> <code>test_empty_file</code> <p>Test extraction from empty file.</p> <code>test_handler_import_errors</code> <p>Test graceful handling of missing optional dependencies.</p> <code>test_large_file_rejection</code> <p>Test that very large files are rejected.</p> <code>test_malicious_filename</code> <p>Test that malicious filenames are rejected.</p> <code>test_memory_pressure_handling</code> <p>Test behavior under memory pressure.</p> <code>test_temp_file_cleanup_on_error</code> <p>Test that temporary files are cleaned up even when errors occur.</p> <code>test_unsupported_file_type</code> <p>Test extraction from unsupported file type.</p> <code>test_zip_security_checks</code> <p>Test ZIP handler security checks.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>class TestEdgeCases:\n    \"\"\"Test edge cases and error conditions.\"\"\"\n\n    def test_empty_file(self):\n        \"\"\"Test extraction from empty file.\"\"\"\n        extractor = SyncTextExtractor()\n        empty_content = b\"\"\n\n        with pytest.raises(ValueError, match=\"File is empty\"):\n            extractor.extract(empty_content, \"empty.txt\")\n\n    def test_large_file_rejection(self):\n        \"\"\"Test that very large files are rejected.\"\"\"\n        extractor = SyncTextExtractor()\n        # Create content larger than default limit\n        large_content = b\"x\" * (101 * 1024 * 1024)  # 101MB\n\n        with pytest.raises(ValueError, match=\"File size.*exceeds\"):\n            extractor.extract(large_content, \"large.txt\")\n\n    def test_malicious_filename(self):\n        \"\"\"Test that malicious filenames are rejected.\"\"\"\n        extractor = SyncTextExtractor()\n        content = b\"test content\"\n\n        malicious_names = [\n            \"../../../etc/passwd\",\n            \"..\\\\..\\\\windows\\\\system32\\\\config\",\n            \"/absolute/path/file.txt\",\n            \"file\\x00name.txt\",  # Null byte injection\n            \"a\" * 300 + \".txt\",  # Very long filename\n        ]\n\n        expected_errors = [\n            \"path traversal detected\",\n            \"path traversal detected\",\n            \"absolute path not allowed\",\n            \"contains null byte\",\n            \"Filename too long\",\n        ]\n\n        for malicious_name, expected_error in zip(malicious_names, expected_errors):\n            with pytest.raises(ValueError, match=expected_error):\n                extractor.extract(content, malicious_name)\n\n    def test_unsupported_file_type(self):\n        \"\"\"Test extraction from unsupported file type.\"\"\"\n        extractor = SyncTextExtractor()\n        content = b\"test content\"\n\n        with pytest.raises(FileTypeNotSupportedError):\n            extractor.extract(content, \"file.unsupported\")\n\n    def test_corrupted_pdf(self):\n        \"\"\"Test extraction from corrupted PDF.\"\"\"\n        extractor = SyncTextExtractor()\n        # Create fake PDF content\n        corrupted_pdf = b\"%%PDF-1.4\\n%corrupted content\"\n\n        with pytest.raises((ExtractionError, InvalidFileError)):\n            extractor.extract(corrupted_pdf, \"corrupted.pdf\")\n\n    @pytest.mark.asyncio\n    async def test_async_extractor_closed(self):\n        \"\"\"Test that closed async extractor raises error.\"\"\"\n        async with AsyncTextExtractor() as extractor:\n            pass  # Context manager closes extractor\n\n        content = b\"test content\"\n        with pytest.raises(RuntimeError, match=\"Extractor has been closed\"):\n            await extractor.extract_async(content, \"test.txt\")\n\n    def test_config_validation(self):\n        \"\"\"Test configuration validation.\"\"\"\n        # Invalid encoding\n        with pytest.raises(ValueError, match=\"Invalid encoding\"):\n            ExtractorConfig(encoding=\"invalid-encoding\")\n\n        # Invalid logging level\n        with pytest.raises(ValueError, match=\"Invalid logging level\"):\n            ExtractorConfig(logging_level=\"INVALID\")\n\n        # Invalid timeout\n        with pytest.raises(ValueError, match=\"Timeout must be a positive number\"):\n            ExtractorConfig(timeout=-1)\n\n        # Invalid max file size\n        with pytest.raises(\n            ValueError, match=\"Max file size must be a positive integer\"\n        ):\n            ExtractorConfig(max_file_size=-1)\n\n    def test_config_from_environment(self):\n        \"\"\"Test loading configuration from environment variables.\"\"\"\n        with patch.dict(\n            \"os.environ\",\n            {\n                \"TEXT_EXTRACTOR_ENCODING\": \"latin-1\",\n                \"TEXT_EXTRACTOR_LOG_LEVEL\": \"DEBUG\",\n                \"TEXT_EXTRACTOR_TIMEOUT\": \"30.0\",\n                \"TEXT_EXTRACTOR_MAX_FILE_SIZE\": \"50000000\",\n            },\n        ):\n            config = ExtractorConfig()\n            assert config.encoding == \"latin-1\"\n            assert config.logging_level == \"DEBUG\"\n            assert config.timeout == 30.0\n            assert config.max_file_size == 50000000\n\n    @pytest.mark.asyncio\n    async def test_concurrent_extractions(self):\n        \"\"\"Test multiple concurrent extractions.\"\"\"\n        import asyncio\n\n        async with AsyncTextExtractor(max_workers=2) as extractor:\n            content = b\"test content\"\n\n            # Run multiple extractions concurrently\n            tasks = [\n                extractor.extract_async(content, f\"test_{i}.txt\") for i in range(5)\n            ]\n\n            results = await asyncio.gather(*tasks)\n            assert len(results) == 5\n            assert all(result == \"test content\" for result in results)\n\n    def test_context_manager_cleanup(self):\n        \"\"\"Test that context managers properly clean up resources.\"\"\"\n        with SyncTextExtractor() as extractor:\n            content = b\"test content\"\n            result = extractor.extract(content, \"test.txt\")\n            assert result == \"test content\"\n        # No specific cleanup needed for sync extractor\n\n    @pytest.mark.asyncio\n    async def test_async_context_manager_cleanup(self):\n        \"\"\"Test that async context manager properly cleans up.\"\"\"\n        extractor = AsyncTextExtractor()\n\n        async with extractor:\n            content = b\"test content\"\n            result = await extractor.extract_async(content, \"test.txt\")\n            assert result == \"test content\"\n\n        # Verify extractor is closed\n        assert extractor._closed\n\n    def test_zip_security_checks(self):\n        \"\"\"Test ZIP handler security checks.\"\"\"\n        from textxtract.handlers.zip import ZIPHandler\n\n        handler = ZIPHandler()\n\n        # Test path traversal detection\n        assert handler._is_unsafe_path(\"../../../etc/passwd\")\n        assert handler._is_unsafe_path(\"..\\\\..\\\\windows\\\\system32\")\n        assert handler._is_unsafe_path(\"/absolute/path\")\n        assert handler._is_unsafe_path(\"C:\\\\windows\\\\system32\")\n\n        # Test safe paths\n        assert not handler._is_unsafe_path(\"safe/file.txt\")\n        assert not handler._is_unsafe_path(\"folder/subfolder/file.txt\")\n\n    def test_memory_pressure_handling(self):\n        \"\"\"Test behavior under memory pressure.\"\"\"\n        # This would require more sophisticated testing in a real scenario\n        # For now, just test that large text files are handled gracefully\n        extractor = SyncTextExtractor()\n\n        # Create a large text file\n        large_text = \"Large content line\\n\" * 100000  # ~1.7MB of text\n        large_content = large_text.encode(\"utf-8\")\n\n        # Should work fine for reasonable sizes\n        result = extractor.extract(large_content, \"large.txt\")\n        assert len(result) &gt; 1000000\n\n    def test_handler_import_errors(self):\n        \"\"\"Test graceful handling of missing optional dependencies.\"\"\"\n        # Mock import error for PDF handler\n        with patch(\"textxtract.core.registry.logger\") as mock_logger:\n            # This would test the registry's handling of import errors\n            # The actual test would need to mock the import process\n            pass\n\n    def test_temp_file_cleanup_on_error(self):\n        \"\"\"Test that temporary files are cleaned up even when errors occur.\"\"\"\n        extractor = SyncTextExtractor()\n\n        # Use a handler that will definitely fail\n        with pytest.raises(FileTypeNotSupportedError):\n            extractor.extract(b\"content\", \"file.unsupported\")\n\n        # Verify no temp files are left behind\n        # This is tricky to test directly, but the safe_unlink in finally blocks should handle it\n\n    def test_custom_config_per_extraction(self):\n        \"\"\"Test passing custom config per extraction call.\"\"\"\n        extractor = SyncTextExtractor()\n        content = b\"test content\"\n\n        # Test with custom encoding\n        result = extractor.extract(content, \"test.txt\", {\"encoding\": \"utf-8\"})\n        assert result == \"test content\"\n\n        # Test with custom max file size\n        with pytest.raises(ValueError):\n            extractor.extract(content, \"test.txt\", {\"max_file_size\": 5})\n</code></pre>"},{"location":"reference/tests/__init__/#textxtract.tests.test_edge_cases.TestEdgeCases-functions","title":"Functions","text":"test_async_context_manager_cleanup <code>async</code> <pre><code>test_async_context_manager_cleanup()\n</code></pre> <p>Test that async context manager properly cleans up.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>@pytest.mark.asyncio\nasync def test_async_context_manager_cleanup(self):\n    \"\"\"Test that async context manager properly cleans up.\"\"\"\n    extractor = AsyncTextExtractor()\n\n    async with extractor:\n        content = b\"test content\"\n        result = await extractor.extract_async(content, \"test.txt\")\n        assert result == \"test content\"\n\n    # Verify extractor is closed\n    assert extractor._closed\n</code></pre> <code></code> test_async_extractor_closed <code>async</code> <pre><code>test_async_extractor_closed()\n</code></pre> <p>Test that closed async extractor raises error.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>@pytest.mark.asyncio\nasync def test_async_extractor_closed(self):\n    \"\"\"Test that closed async extractor raises error.\"\"\"\n    async with AsyncTextExtractor() as extractor:\n        pass  # Context manager closes extractor\n\n    content = b\"test content\"\n    with pytest.raises(RuntimeError, match=\"Extractor has been closed\"):\n        await extractor.extract_async(content, \"test.txt\")\n</code></pre> <code></code> test_concurrent_extractions <code>async</code> <pre><code>test_concurrent_extractions()\n</code></pre> <p>Test multiple concurrent extractions.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>@pytest.mark.asyncio\nasync def test_concurrent_extractions(self):\n    \"\"\"Test multiple concurrent extractions.\"\"\"\n    import asyncio\n\n    async with AsyncTextExtractor(max_workers=2) as extractor:\n        content = b\"test content\"\n\n        # Run multiple extractions concurrently\n        tasks = [\n            extractor.extract_async(content, f\"test_{i}.txt\") for i in range(5)\n        ]\n\n        results = await asyncio.gather(*tasks)\n        assert len(results) == 5\n        assert all(result == \"test content\" for result in results)\n</code></pre> <code></code> test_config_from_environment <pre><code>test_config_from_environment()\n</code></pre> <p>Test loading configuration from environment variables.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>def test_config_from_environment(self):\n    \"\"\"Test loading configuration from environment variables.\"\"\"\n    with patch.dict(\n        \"os.environ\",\n        {\n            \"TEXT_EXTRACTOR_ENCODING\": \"latin-1\",\n            \"TEXT_EXTRACTOR_LOG_LEVEL\": \"DEBUG\",\n            \"TEXT_EXTRACTOR_TIMEOUT\": \"30.0\",\n            \"TEXT_EXTRACTOR_MAX_FILE_SIZE\": \"50000000\",\n        },\n    ):\n        config = ExtractorConfig()\n        assert config.encoding == \"latin-1\"\n        assert config.logging_level == \"DEBUG\"\n        assert config.timeout == 30.0\n        assert config.max_file_size == 50000000\n</code></pre> <code></code> test_config_validation <pre><code>test_config_validation()\n</code></pre> <p>Test configuration validation.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>def test_config_validation(self):\n    \"\"\"Test configuration validation.\"\"\"\n    # Invalid encoding\n    with pytest.raises(ValueError, match=\"Invalid encoding\"):\n        ExtractorConfig(encoding=\"invalid-encoding\")\n\n    # Invalid logging level\n    with pytest.raises(ValueError, match=\"Invalid logging level\"):\n        ExtractorConfig(logging_level=\"INVALID\")\n\n    # Invalid timeout\n    with pytest.raises(ValueError, match=\"Timeout must be a positive number\"):\n        ExtractorConfig(timeout=-1)\n\n    # Invalid max file size\n    with pytest.raises(\n        ValueError, match=\"Max file size must be a positive integer\"\n    ):\n        ExtractorConfig(max_file_size=-1)\n</code></pre> <code></code> test_context_manager_cleanup <pre><code>test_context_manager_cleanup()\n</code></pre> <p>Test that context managers properly clean up resources.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>def test_context_manager_cleanup(self):\n    \"\"\"Test that context managers properly clean up resources.\"\"\"\n    with SyncTextExtractor() as extractor:\n        content = b\"test content\"\n        result = extractor.extract(content, \"test.txt\")\n        assert result == \"test content\"\n</code></pre> <code></code> test_corrupted_pdf <pre><code>test_corrupted_pdf()\n</code></pre> <p>Test extraction from corrupted PDF.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>def test_corrupted_pdf(self):\n    \"\"\"Test extraction from corrupted PDF.\"\"\"\n    extractor = SyncTextExtractor()\n    # Create fake PDF content\n    corrupted_pdf = b\"%%PDF-1.4\\n%corrupted content\"\n\n    with pytest.raises((ExtractionError, InvalidFileError)):\n        extractor.extract(corrupted_pdf, \"corrupted.pdf\")\n</code></pre> <code></code> test_custom_config_per_extraction <pre><code>test_custom_config_per_extraction()\n</code></pre> <p>Test passing custom config per extraction call.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>def test_custom_config_per_extraction(self):\n    \"\"\"Test passing custom config per extraction call.\"\"\"\n    extractor = SyncTextExtractor()\n    content = b\"test content\"\n\n    # Test with custom encoding\n    result = extractor.extract(content, \"test.txt\", {\"encoding\": \"utf-8\"})\n    assert result == \"test content\"\n\n    # Test with custom max file size\n    with pytest.raises(ValueError):\n        extractor.extract(content, \"test.txt\", {\"max_file_size\": 5})\n</code></pre> <code></code> test_empty_file <pre><code>test_empty_file()\n</code></pre> <p>Test extraction from empty file.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>def test_empty_file(self):\n    \"\"\"Test extraction from empty file.\"\"\"\n    extractor = SyncTextExtractor()\n    empty_content = b\"\"\n\n    with pytest.raises(ValueError, match=\"File is empty\"):\n        extractor.extract(empty_content, \"empty.txt\")\n</code></pre> <code></code> test_handler_import_errors <pre><code>test_handler_import_errors()\n</code></pre> <p>Test graceful handling of missing optional dependencies.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>def test_handler_import_errors(self):\n    \"\"\"Test graceful handling of missing optional dependencies.\"\"\"\n    # Mock import error for PDF handler\n    with patch(\"textxtract.core.registry.logger\") as mock_logger:\n        # This would test the registry's handling of import errors\n        # The actual test would need to mock the import process\n        pass\n</code></pre> <code></code> test_large_file_rejection <pre><code>test_large_file_rejection()\n</code></pre> <p>Test that very large files are rejected.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>def test_large_file_rejection(self):\n    \"\"\"Test that very large files are rejected.\"\"\"\n    extractor = SyncTextExtractor()\n    # Create content larger than default limit\n    large_content = b\"x\" * (101 * 1024 * 1024)  # 101MB\n\n    with pytest.raises(ValueError, match=\"File size.*exceeds\"):\n        extractor.extract(large_content, \"large.txt\")\n</code></pre> <code></code> test_malicious_filename <pre><code>test_malicious_filename()\n</code></pre> <p>Test that malicious filenames are rejected.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>def test_malicious_filename(self):\n    \"\"\"Test that malicious filenames are rejected.\"\"\"\n    extractor = SyncTextExtractor()\n    content = b\"test content\"\n\n    malicious_names = [\n        \"../../../etc/passwd\",\n        \"..\\\\..\\\\windows\\\\system32\\\\config\",\n        \"/absolute/path/file.txt\",\n        \"file\\x00name.txt\",  # Null byte injection\n        \"a\" * 300 + \".txt\",  # Very long filename\n    ]\n\n    expected_errors = [\n        \"path traversal detected\",\n        \"path traversal detected\",\n        \"absolute path not allowed\",\n        \"contains null byte\",\n        \"Filename too long\",\n    ]\n\n    for malicious_name, expected_error in zip(malicious_names, expected_errors):\n        with pytest.raises(ValueError, match=expected_error):\n            extractor.extract(content, malicious_name)\n</code></pre> <code></code> test_memory_pressure_handling <pre><code>test_memory_pressure_handling()\n</code></pre> <p>Test behavior under memory pressure.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>def test_memory_pressure_handling(self):\n    \"\"\"Test behavior under memory pressure.\"\"\"\n    # This would require more sophisticated testing in a real scenario\n    # For now, just test that large text files are handled gracefully\n    extractor = SyncTextExtractor()\n\n    # Create a large text file\n    large_text = \"Large content line\\n\" * 100000  # ~1.7MB of text\n    large_content = large_text.encode(\"utf-8\")\n\n    # Should work fine for reasonable sizes\n    result = extractor.extract(large_content, \"large.txt\")\n    assert len(result) &gt; 1000000\n</code></pre> <code></code> test_temp_file_cleanup_on_error <pre><code>test_temp_file_cleanup_on_error()\n</code></pre> <p>Test that temporary files are cleaned up even when errors occur.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>def test_temp_file_cleanup_on_error(self):\n    \"\"\"Test that temporary files are cleaned up even when errors occur.\"\"\"\n    extractor = SyncTextExtractor()\n\n    # Use a handler that will definitely fail\n    with pytest.raises(FileTypeNotSupportedError):\n        extractor.extract(b\"content\", \"file.unsupported\")\n</code></pre> <code></code> test_unsupported_file_type <pre><code>test_unsupported_file_type()\n</code></pre> <p>Test extraction from unsupported file type.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>def test_unsupported_file_type(self):\n    \"\"\"Test extraction from unsupported file type.\"\"\"\n    extractor = SyncTextExtractor()\n    content = b\"test content\"\n\n    with pytest.raises(FileTypeNotSupportedError):\n        extractor.extract(content, \"file.unsupported\")\n</code></pre> <code></code> test_zip_security_checks <pre><code>test_zip_security_checks()\n</code></pre> <p>Test ZIP handler security checks.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>def test_zip_security_checks(self):\n    \"\"\"Test ZIP handler security checks.\"\"\"\n    from textxtract.handlers.zip import ZIPHandler\n\n    handler = ZIPHandler()\n\n    # Test path traversal detection\n    assert handler._is_unsafe_path(\"../../../etc/passwd\")\n    assert handler._is_unsafe_path(\"..\\\\..\\\\windows\\\\system32\")\n    assert handler._is_unsafe_path(\"/absolute/path\")\n    assert handler._is_unsafe_path(\"C:\\\\windows\\\\system32\")\n\n    # Test safe paths\n    assert not handler._is_unsafe_path(\"safe/file.txt\")\n    assert not handler._is_unsafe_path(\"folder/subfolder/file.txt\")\n</code></pre>"},{"location":"reference/tests/__init__/#textxtract.tests.test_edge_cases.TestErrorMessages","title":"TestErrorMessages","text":"<p>Test that error messages are helpful and informative.</p> <p>Methods:</p> Name Description <code>test_file_size_error_message</code> <p>Test that file size errors include actual vs allowed size.</p> <code>test_unsupported_extension_message</code> <p>Test that unsupported extension errors include helpful info.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>class TestErrorMessages:\n    \"\"\"Test that error messages are helpful and informative.\"\"\"\n\n    def test_unsupported_extension_message(self):\n        \"\"\"Test that unsupported extension errors include helpful info.\"\"\"\n        extractor = SyncTextExtractor()\n\n        with pytest.raises(FileTypeNotSupportedError) as exc_info:\n            extractor.extract(b\"content\", \"file.xyz\")\n\n        error_msg = str(exc_info.value)\n        assert \"xyz\" in error_msg\n        assert \"Supported extensions\" in error_msg\n\n    def test_file_size_error_message(self):\n        \"\"\"Test that file size errors include actual vs allowed size.\"\"\"\n        extractor = SyncTextExtractor()\n        large_content = b\"x\" * 1000\n\n        with pytest.raises(ValueError) as exc_info:\n            extractor.extract(large_content, \"test.txt\", {\"max_file_size\": 500})\n\n        error_msg = str(exc_info.value)\n        assert \"1,000 bytes\" in error_msg\n        assert \"500 bytes\" in error_msg\n</code></pre>"},{"location":"reference/tests/__init__/#textxtract.tests.test_edge_cases.TestErrorMessages-functions","title":"Functions","text":"test_file_size_error_message <pre><code>test_file_size_error_message()\n</code></pre> <p>Test that file size errors include actual vs allowed size.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>def test_file_size_error_message(self):\n    \"\"\"Test that file size errors include actual vs allowed size.\"\"\"\n    extractor = SyncTextExtractor()\n    large_content = b\"x\" * 1000\n\n    with pytest.raises(ValueError) as exc_info:\n        extractor.extract(large_content, \"test.txt\", {\"max_file_size\": 500})\n\n    error_msg = str(exc_info.value)\n    assert \"1,000 bytes\" in error_msg\n    assert \"500 bytes\" in error_msg\n</code></pre> <code></code> test_unsupported_extension_message <pre><code>test_unsupported_extension_message()\n</code></pre> <p>Test that unsupported extension errors include helpful info.</p> Source code in <code>textxtract/tests/test_edge_cases.py</code> <pre><code>def test_unsupported_extension_message(self):\n    \"\"\"Test that unsupported extension errors include helpful info.\"\"\"\n    extractor = SyncTextExtractor()\n\n    with pytest.raises(FileTypeNotSupportedError) as exc_info:\n        extractor.extract(b\"content\", \"file.xyz\")\n\n    error_msg = str(exc_info.value)\n    assert \"xyz\" in error_msg\n    assert \"Supported extensions\" in error_msg\n</code></pre>"},{"location":"reference/tests/__init__/#textxtract.tests.test_exceptions","title":"test_exceptions","text":"<p>Unit tests for custom exceptions.</p> <p>Functions:</p> Name Description <code>test_extraction_error</code> <code>test_extraction_timeout_error</code> <code>test_file_type_not_supported_error</code> <code>test_invalid_file_error</code>"},{"location":"reference/tests/__init__/#textxtract.tests.test_exceptions-classes","title":"Classes","text":""},{"location":"reference/tests/__init__/#textxtract.tests.test_exceptions-functions","title":"Functions","text":""},{"location":"reference/tests/__init__/#textxtract.tests.test_exceptions.test_extraction_error","title":"test_extraction_error","text":"<pre><code>test_extraction_error()\n</code></pre> Source code in <code>textxtract/tests/test_exceptions.py</code> <pre><code>def test_extraction_error():\n    e = ExtractionError(\"error\")\n    assert str(e) == \"error\"\n</code></pre>"},{"location":"reference/tests/__init__/#textxtract.tests.test_exceptions.test_extraction_timeout_error","title":"test_extraction_timeout_error","text":"<pre><code>test_extraction_timeout_error()\n</code></pre> Source code in <code>textxtract/tests/test_exceptions.py</code> <pre><code>def test_extraction_timeout_error():\n    e = ExtractionTimeoutError(\"timeout\")\n    assert str(e) == \"timeout\"\n</code></pre>"},{"location":"reference/tests/__init__/#textxtract.tests.test_exceptions.test_file_type_not_supported_error","title":"test_file_type_not_supported_error","text":"<pre><code>test_file_type_not_supported_error()\n</code></pre> Source code in <code>textxtract/tests/test_exceptions.py</code> <pre><code>def test_file_type_not_supported_error():\n    e = FileTypeNotSupportedError(\"not supported\")\n    assert str(e) == \"not supported\"\n</code></pre>"},{"location":"reference/tests/__init__/#textxtract.tests.test_exceptions.test_invalid_file_error","title":"test_invalid_file_error","text":"<pre><code>test_invalid_file_error()\n</code></pre> Source code in <code>textxtract/tests/test_exceptions.py</code> <pre><code>def test_invalid_file_error():\n    e = InvalidFileError(\"invalid\")\n    assert str(e) == \"invalid\"\n</code></pre>"},{"location":"reference/tests/__init__/#textxtract.tests.test_sync","title":"test_sync","text":"<p>Comprehensive tests for SyncTextExtractor using all sample files.</p> <p>Functions:</p> Name Description <code>test_sync_extractor_all_types</code> <p>Attributes:</p> Name Type Description <code>TEST_FILES_DIR</code>"},{"location":"reference/tests/__init__/#textxtract.tests.test_sync-attributes","title":"Attributes","text":""},{"location":"reference/tests/__init__/#textxtract.tests.test_sync.TEST_FILES_DIR","title":"TEST_FILES_DIR  <code>module-attribute</code>","text":"<pre><code>TEST_FILES_DIR = parent / 'files'\n</code></pre>"},{"location":"reference/tests/__init__/#textxtract.tests.test_sync-classes","title":"Classes","text":""},{"location":"reference/tests/__init__/#textxtract.tests.test_sync-functions","title":"Functions","text":""},{"location":"reference/tests/__init__/#textxtract.tests.test_sync.test_sync_extractor_all_types","title":"test_sync_extractor_all_types","text":"<pre><code>test_sync_extractor_all_types(filename, should_succeed)\n</code></pre> Source code in <code>textxtract/tests/test_sync.py</code> <pre><code>@pytest.mark.parametrize(\n    \"filename,should_succeed\",\n    [\n        (\"text_file.txt\", True),\n        (\"text_file.text\", True),\n        (\"markdown.md\", True),\n        (\"text_file.pdf\", True),\n        (\"text_file.docx\", True),\n        (\"text_file.doc\", True),\n        (\"text_file.rtf\", True),\n        (\"text.html\", True),\n        (\"text.csv\", True),\n        (\"text.json\", True),\n        (\"text.xml\", True),\n        (\"text_zip.zip\", True),\n        (\"text_file.odt\", False),  # Not supported, should fail\n    ],\n)\ndef test_sync_extractor_all_types(filename, should_succeed):\n    extractor = SyncTextExtractor()\n    file_path = TEST_FILES_DIR / filename\n    file_bytes = file_path.read_bytes()\n    try:\n        text = extractor.extract(file_bytes, filename)\n        assert should_succeed, f\"Extraction should have failed for {filename}\"\n        assert isinstance(text, (str, list)), \"Extracted text should be str or list\"\n        assert text, \"Extracted text should not be empty\"\n    except FileTypeNotSupportedError:\n        assert not should_succeed, (\n            f\"FileTypeNotSupportedError unexpected for {filename}\"\n        )\n    except (ExtractionError, InvalidFileError):\n        assert not should_succeed, (\n            f\"ExtractionError/InvalidFileError unexpected for {filename}\"\n        )\n</code></pre>"}]}